[{"title":"2-SAT 问题总结","url":"/2023/02/18/2-SAT-%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","content":"<h1 id=\"2-SAT-问题总结\"><a href=\"#2-SAT-问题总结\" class=\"headerlink\" title=\"2-SAT 问题总结\"></a>2-SAT 问题总结</h1><h2 id=\"形式\"><a href=\"#形式\" class=\"headerlink\" title=\"形式\"></a>形式</h2><p>$n$ 个变量，每个变量<strong>只有</strong>两种取值，给定 $m$ 个对两个变量取值限制的条件，判断是否有一种取值方式，使所有条件都能得到满足。2-SAT 里面的 $2$ 代表每个变量只有两种取值，SAT 代表满足性。</p>\n<p>设第 $i$ 个变量的取值有两种：$A_{i,0},A_{i,1}$，所有的条件都可以写成若 $i$ 变量取 $A_{i,p}$，则第 $j$ 个变量必须取 $A_{j,q}$。</p>\n<span id=\"more\"></span>\n<p>考虑转化为图论问题，建立 $2n$ 个点，其中一个变量 $i$ 的两种取值分别对应 $i$ 和 $i+n$，我们用一条有向边表示起点选了，终点就必须选，即从 $i+p\\cdot n$ 到 $j+q\\cdot n$ 连边。</p>\n<p>注意到命题若 $A_{i,p}$，则 $A_{j,q}$，表示着 $A_{i,p}$ 只能对应 $A_{j,q}$，所以当 $j$ 取 $A_{j,1-q}$ 时，$i$ 就只能取 $A_{i,1-p}$，即一个命题的逆否命题也为真，所以还需要连从 $j+(1-q)\\cdot n$ 到 $i+(1-p)\\cdot n$ 的边。</p>\n<p>先思考一下这样做的意义：从 $i$ 连到 $j$ 表示 $i$ 可以推出 $j$，而显然 $i\\rightarrow j$,$j\\rightarrow p$，可以得到 $i\\rightarrow p$，而这在图中通过边的传递得以体现。为什么建有向边？因为一个命题的逆命题不一定成立。</p>\n<p>如果点 $i$ 和 $i+n$ 在同一个强连通分量中，会发生什么呢？$A_{i,0}$ 和 $A_{i,1}$ 能互相推出，显然矛盾。也就是说，我们只要对原图缩点，判断所有的 $i$ 和 $i+n$ 是否在一个强连通分量中，就可以知道有没有解了。</p>\n<p>有的人可能会问：如果 $A_{i,0}$ 能推出 $A_{i,1}$ 那不矛盾吗？</p>\n<p>确实不矛盾。</p>\n<p>你可以把 $A_{i,0}$ 推出 $A_{i,1}$ 看成 $A_{i,0}$ 一定不能选，所有选 $A_{i,0}$ 的最后都会选到 $A_{i,1}$ 上，这也是我们让一个点不被选择的常用方法。</p>\n<p>那么，具体怎么求出解呢？我们肯定不能随便选一个，比如上面的例子：$A_{i,0}$ 能推出 $A_{i,1}$，虽然它们不在一个强连通分量中，但是显然只能选 $A_{i,1}$。</p>\n<p>但是，我们可以从上面的例子中得到启发：要尽量选后面的，也就是先找到的强连通分量，如果我们每找到一个强连通分量，就给定一个递增的编号，就等价于选编号小的那个。</p>\n<p>具体的看模板题代码吧。</p>\n<h2 id=\"例0\"><a href=\"#例0\" class=\"headerlink\" title=\"例0\"></a>例0</h2><p><a href=\"https://www.luogu.com.cn/problem/P4782\">P4782 【模板】2-SAT 问题</a></p>\n<p>显然这种题不可能直接给赤裸裸的限制，还是要转化一下的。</p>\n<p>$x_i$ 为 $a$ 或 $x_j$ 为 $b$，代表着至少要有一个成立，于是只要其中有一个不成立，就说明另一个肯定成立。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,head[N],tot,dfn[N],low[N],cnt,sta[N],ins[N],tp,scc,c[N],opp[N],ans[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tdfn[u] = low[u] = ++cnt;</span><br><span class=\"line\">\tsta[++tp] = u,ins[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!dfn[v])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(v);</span><br><span class=\"line\">\t\t\tlow[u] = <span class=\"built_in\">min</span>(low[u],low[v]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ins[v]) low[u] = <span class=\"built_in\">min</span>(low[u],dfn[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dfn[u] == low[u])&#123;</span><br><span class=\"line\">\t\tscc++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tv = sta[tp],tp--;</span><br><span class=\"line\">\t\t\tins[v] = <span class=\"number\">0</span>,c[v] = scc;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (v == u) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> id1,id2,a,b;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;id1&gt;&gt;a&gt;&gt;id2&gt;&gt;b;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(id1+(a?<span class=\"number\">0</span>:n),id2+(b?n:<span class=\"number\">0</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(id2+(b?<span class=\"number\">0</span>:n),id1+(a?n:<span class=\"number\">0</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n*<span class=\"number\">2</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!dfn[i]) <span class=\"built_in\">dfs</span>(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[i] == c[i+n])&#123;</span><br><span class=\"line\">\t\t\tflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\topp[i] = i+n,opp[i+n] = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!flag)&#123;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;IMPOSSIBLE\\n&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;POSSIBLE\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tans[i] = (c[i]&gt;c[opp[i]]);</span><br><span class=\"line\">\t\tcout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>练习：<a href=\"https://www.luogu.com.cn/problem/P4171\">P4171 [JSOI2010] 满汉全席</a></p>\n<h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><p><a href=\"https://www.luogu.com.cn/problem/P3825\">P3825 [NOI2017] 游戏</a></p>\n<p>乍一看，好像每个 map 都有三个限制，众所周知，3-SAT 是 NPC 问题，所以此题无解？</p>\n<p>Nonono，其实除了 $x$ 之外，其他的地图都规定了能跑哪两辆车，我们只用判断这俩在不在一个 SCC 内部即可。</p>\n<p>难的就是这个 $x$ 地图，它三个车都能跑。</p>\n<p>不过，这也是可以转化的，算一遍只能跑 $1,2$ 车的，再算一遍只能跑 $2,3$ 车的就行了。</p>\n<p>对于每个 $x$ 地图，我们枚举它能跑的车的两种情况（即上面所说的），所有情况只有 $2^k$ 种，再乘上每次 2-SAT 的复杂度 $n$，可以通过。</p>\n<p>不过，这里要注意一个细节：有些限制，在一种情况种可能是不存在的。</p>\n<p>假设这个 $x$ 图只能跑 $2,3$，存在一个限制说如果 $x$ 图跑 $1$，某图就必须跑 $2$，显然它是无论如何都不可能生效的，无视它即可。</p>\n<p>但是，万一有限制说，如果某图跑 $2$，$x$ 图就必须跑 $1$，侧面说明了某图是一定不可能跑 $2$ 的，对于这种一定不可能的问题，在文章开头已经讨论过，我们只需要把它连向某图唯一能跑的点即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1.5e5</span>+<span class=\"number\">10</span>,M = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,d,m,head[N],tot,ban[N],pos[<span class=\"number\">15</span>],tt,dfn[N],low[N],cnt,sta[N],ins[N],tp,scc,c[N],ans[N];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[M*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">opr</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> id1,id2;</span><br><span class=\"line\">\t<span class=\"type\">char</span> s1,s2;</span><br><span class=\"line\">&#125; a[M];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tdfn[u] = low[u] = ++cnt;</span><br><span class=\"line\">\tsta[++tp] = u,ins[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!dfn[v])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(v);</span><br><span class=\"line\">\t\t\tlow[u] = <span class=\"built_in\">min</span>(low[u],low[v]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ins[v]) low[u] = <span class=\"built_in\">min</span>(low[u],dfn[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dfn[u] == low[u])&#123;</span><br><span class=\"line\">\t\tscc++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tv = sta[tp],tp--,ins[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tc[v] = scc;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (v == u) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;d&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;a&#x27;</span>) ban[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;b&#x27;</span>) ban[i+n] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;c&#x27;</span>) ban[i+<span class=\"number\">2</span>*n] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> pos[++tt] = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;a[i].id1&gt;&gt;a[i].s1&gt;&gt;a[i].id2&gt;&gt;a[i].s2;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;d);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>)*(<span class=\"number\">3</span>*n+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(dfn,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>)*(<span class=\"number\">3</span>*n+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(low,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>)*(<span class=\"number\">3</span>*n+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t\ttot = cnt = scc = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tt;j++) ban[pos[j]] = ban[pos[j]+<span class=\"number\">2</span>*n] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tt;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((<span class=\"number\">1</span>&lt;&lt;(j<span class=\"number\">-1</span>))&amp;i) ban[pos[j]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> ban[pos[j]+<span class=\"number\">2</span>*n] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> x = a[j].s1-<span class=\"string\">&#x27;A&#x27;</span>,y = a[j].s2-<span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (ban[a[j].id1+x*n]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (ban[a[j].id2+y*n])&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;=<span class=\"number\">2</span>;k++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (k!=x &amp;&amp; !ban[a[j].id1+k*n]) pos = k;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">add</span>(a[j].id1+x*n,a[j].id1+pos*n);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(a[j].id1+x*n,a[j].id2+y*n);</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> pos1 = <span class=\"number\">0</span>,pos2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;=<span class=\"number\">2</span>;k++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (k!=x &amp;&amp; !ban[a[j].id1+k*n]) pos1 = k;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (k!=y &amp;&amp; !ban[a[j].id2+k*n]) pos2 = k;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(a[j].id2+n*pos2,a[j].id1+n*pos1);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=<span class=\"number\">3</span>*n;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!dfn[j] &amp;&amp; !ban[j]) <span class=\"built_in\">dfs</span>(j);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> pos1 = <span class=\"number\">0</span>,pos2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;=<span class=\"number\">2</span>;k++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!ban[j+n*k])&#123;</span><br><span class=\"line\">\t\t\t\t\tpos1 = k;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">2</span>;k&gt;=<span class=\"number\">0</span>;k--)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!ban[j+n*k])&#123;</span><br><span class=\"line\">\t\t\t\t\tpos2 = k;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (c[j+pos1*n] == c[j+pos2*n])&#123;</span><br><span class=\"line\">\t\t\t\tflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (flag)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> pos1 = <span class=\"number\">0</span>,pos2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;=<span class=\"number\">2</span>;k++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (!ban[j+n*k])&#123;</span><br><span class=\"line\">\t\t\t\t\t\tpos1 = k;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">2</span>;k&gt;=<span class=\"number\">0</span>;k--)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (!ban[j+n*k])&#123;</span><br><span class=\"line\">\t\t\t\t\t\tpos2 = k;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (c[j+n*pos1]&lt;c[j+n*pos2]) ans[j] = pos1;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> ans[j] = pos2;</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;<span class=\"built_in\">char</span>(ans[j]+<span class=\"string\">&#x27;A&#x27;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例3\"><a href=\"#例3\" class=\"headerlink\" title=\"例3\"></a>例3</h2><p><a href=\"https://www.luogu.com.cn/problem/P6378\">P6378 [PA2010] Riddle</a></p>\n<p>每条边至少有一个点是关键点，等价于如果一个点不是，则另一个点必须是。我们把这个限制加入。</p>\n<p>每个部分恰有一个，就是一个点如果被选择，其他的点都不能选，这样直接连边可能有 $n^2$ 条，需要优化。</p>\n<p>这里采用前后缀优化建图。</p>\n<p>建立一些前缀点，从第 $i$ 个前缀点出发，能够到达所有 $1$~$i$ 个点不选的点。同理建立后缀点。</p>\n<p>具体的，一个前缀点连两条边，一条连到上一个前缀点，这样就能访问到上一个前缀点能访问的所有点，另一个连到第 $i$ 个不选的点，于是就可以访问到所有 $1$~$i$ 了。后缀点同理。</p>\n<p>于是，我们只用了 $O(n)$ 条边，就解决了原来需要 $O(n^2)$ 条解决的问题，前后缀思想在 2-SAT 的建图中很有用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">4e6</span>+<span class=\"number\">10</span>,M = <span class=\"number\">1e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,k,head[N],tot,w,a[M],cnt,pre[M],suf[M],dfn[N],low[N],sta[N],ins[N],tp,scc,c[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tdfn[u] = low[u] = ++cnt;</span><br><span class=\"line\">\tsta[++tp] = u,ins[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!dfn[v])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(v);</span><br><span class=\"line\">\t\t\tlow[u] = <span class=\"built_in\">min</span>(low[u],low[v]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ins[v]) low[u] = <span class=\"built_in\">min</span>(low[u],dfn[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dfn[u] == low[u])&#123;</span><br><span class=\"line\">\t\tscc++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tv = sta[tp],tp--;</span><br><span class=\"line\">\t\t\tins[v] = <span class=\"number\">0</span>,c[v] = scc;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (v == u) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y+n);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x+n);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcnt = n*<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;w;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=w;j++) cin&gt;&gt;a[j];</span><br><span class=\"line\">\t\tsuf[w] = ++cnt;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(suf[w],a[w]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=w<span class=\"number\">-1</span>;j&gt;=<span class=\"number\">2</span>;j--)&#123;</span><br><span class=\"line\">\t\t\tsuf[j] = ++cnt;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(suf[j],suf[j+<span class=\"number\">1</span>]),<span class=\"built_in\">add</span>(suf[j],a[j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpre[<span class=\"number\">1</span>] = ++cnt;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(pre[<span class=\"number\">1</span>],a[<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">2</span>;j&lt;=w<span class=\"number\">-1</span>;j++)&#123;</span><br><span class=\"line\">\t\t\tpre[j] = ++cnt;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(pre[j],pre[j<span class=\"number\">-1</span>]),<span class=\"built_in\">add</span>(pre[j],a[j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=w;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (j!=<span class=\"number\">1</span>) <span class=\"built_in\">add</span>(a[j]+n,pre[j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (j!=w) <span class=\"built_in\">add</span>(a[j]+n,suf[j+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = cnt;</span><br><span class=\"line\">\tcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tmp;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!dfn[i]) <span class=\"built_in\">dfs</span>(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[i] == c[i+n])&#123;</span><br><span class=\"line\">\t\t\tflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;(flag?<span class=\"string\">&quot;TAK&quot;</span>:<span class=\"string\">&quot;NIE&quot;</span>)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例4\"><a href=\"#例4\" class=\"headerlink\" title=\"例4\"></a>例4</h2><p><a href=\"https://www.luogu.com.cn/problem/CF1215F\">Radio Stations</a></p>\n<p>算是上一道题的加强版。</p>\n<p>至少有一个，等价于一个没有，则另一个必须有。</p>\n<p>最多有一个，等价于一个有，则另一个必须没有。</p>\n<p>但是，还要限制交集不为空，我们考虑暴力去做，就是对于每个点，我们都找到所有和它交集为空的，则如果选了这个点，那么它们都不能选。</p>\n<p>考虑用前后缀优化建图。</p>\n<p>排序，二分一下不能选的点的边界，之后把前后缀连上就行了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1.6e6</span>+<span class=\"number\">10</span>,MM = <span class=\"number\">4e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,p,M,head[N],tot,pre[N],suf[N],dfn[N],low[N],cnt,sta[N],ins[N],tp,scc,c[N],ans[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[MM];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">aa</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,id;</span><br><span class=\"line\">&#125; a[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(aa x,aa y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x.l&lt;y.l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp2</span><span class=\"params\">(aa x,aa y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x.r&lt;y.r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp3</span><span class=\"params\">(aa x,aa y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x.id&lt;y.id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findr</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> rr = a[x].r;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l = x+<span class=\"number\">1</span>,r = p,mid,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (l&lt;=r)&#123;</span><br><span class=\"line\">\t\tmid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[mid].l&gt;rr)&#123;</span><br><span class=\"line\">\t\t\tans = mid;</span><br><span class=\"line\">\t\t\tr = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> l = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findl</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ll = a[x].l;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l = <span class=\"number\">1</span>,r = x<span class=\"number\">-1</span>,mid,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (l&lt;=r)&#123;</span><br><span class=\"line\">\t\tmid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[mid].r&lt;ll)&#123;</span><br><span class=\"line\">\t\t\tans = mid;</span><br><span class=\"line\">\t\t\tl = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tdfn[u] = low[u] = ++cnt;</span><br><span class=\"line\">\tsta[++tp] = u,ins[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!dfn[v])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(v);</span><br><span class=\"line\">\t\t\tlow[u] = <span class=\"built_in\">min</span>(low[u],low[v]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ins[v]) low[u] = <span class=\"built_in\">min</span>(low[u],dfn[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dfn[u] == low[u])&#123;</span><br><span class=\"line\">\t\tscc++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tv = sta[tp],tp--;</span><br><span class=\"line\">\t\t\tins[v] = <span class=\"number\">0</span>,c[v] = scc;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (v == u) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;p&gt;&gt;M&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y+p);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x+p);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=p;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].l&gt;&gt;a[i].r;</span><br><span class=\"line\">\t\ta[i].id = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x+p,y);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y+p,x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a+<span class=\"number\">1</span>,a+<span class=\"number\">1</span>+p,cmp);</span><br><span class=\"line\">\t<span class=\"type\">int</span> coun = p*<span class=\"number\">2</span>;</span><br><span class=\"line\">\tsuf[p] = ++coun;</span><br><span class=\"line\">\t<span class=\"built_in\">add</span>(suf[p],a[p].id);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=p<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">2</span>;i--)&#123;</span><br><span class=\"line\">\t\tsuf[i] = ++coun;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(suf[i],suf[i+<span class=\"number\">1</span>]),<span class=\"built_in\">add</span>(suf[i],a[i].id);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=p;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pos = <span class=\"built_in\">findr</span>(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pos) <span class=\"built_in\">add</span>(a[i].id+p,suf[pos]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a+<span class=\"number\">1</span>,a+<span class=\"number\">1</span>+p,cmp2);</span><br><span class=\"line\">\tpre[<span class=\"number\">1</span>] = ++coun;</span><br><span class=\"line\">\t<span class=\"built_in\">add</span>(pre[<span class=\"number\">1</span>],a[<span class=\"number\">1</span>].id);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=p<span class=\"number\">-1</span>;i++)&#123;</span><br><span class=\"line\">\t\tpre[i] = ++coun;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(pre[i],pre[i<span class=\"number\">-1</span>]),<span class=\"built_in\">add</span>(pre[i],a[i].id);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=p;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pos = <span class=\"built_in\">findl</span>(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pos) <span class=\"built_in\">add</span>(a[i].id+p,pre[pos]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">2</span>*p;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!dfn[i]) <span class=\"built_in\">dfs</span>(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a+<span class=\"number\">1</span>,a+<span class=\"number\">1</span>+p,cmp3);</span><br><span class=\"line\">\t<span class=\"type\">int</span> flag = <span class=\"number\">1</span>,cnt = <span class=\"number\">0</span>,l = <span class=\"number\">1</span>,r = M;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=p;i++)&#123;</span><br><span class=\"line\">\t\tans[i] = (c[i]&gt;c[i+p]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans[i])&#123;</span><br><span class=\"line\">\t\t\tcnt++;</span><br><span class=\"line\">\t\t\tl = <span class=\"built_in\">max</span>(l,a[i].l),r = <span class=\"built_in\">min</span>(r,a[i].r);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[i] == c[i+p])&#123;</span><br><span class=\"line\">\t\t\tflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!flag)&#123;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;l&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=p;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans[i]) cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例5\"><a href=\"#例5\" class=\"headerlink\" title=\"例5\"></a>例5</h2><p><a href=\"https://www.luogu.com.cn/problem/CF1697F\">Too Many Constraints</a></p>\n<p>这又是 2-SAT 中一种常见的题型：限制取值范围。</p>\n<p>由于取值很少，我们可以把一个位置拆成 $k$ 对点，第 $j$ 对点表示 $a_i\\leq j$ 是否成立，这样就转化为了 2-SAT 问题。</p>\n<ul>\n<li><p>约束1</p>\n<p>如果选了 $\\leq x$，那肯定要选 $\\leq x-1$，如果没选 $\\leq x-1$，即 $&gt;x-1$，又不能取 $x$，所以肯定 $&gt;x$。</p>\n<p>如果 $x = 1$，那么 $x-1$ 就不在取值范围内了，再想一下，这就相当于所有可能的解都 $&gt;x$，所以强制不选 $\\leq x$，即把选的点向不选的点连边。</p>\n</li>\n<li><p>约束2</p>\n<p>这里就比较困难了。</p>\n<p>2-SAT 问题的本质就是进行尽量多的限制，使得答案绝对满足所有条件，我们不仅要找合法的，也要把所有不合法的剔除。</p>\n<p>最显然的限制是枚举 $a_i,a_j$，要满足 $a_i+a_j\\leq x$。</p>\n<p>假设 $a_i\\leq p$，$a_j\\leq q$ 是它们对应的两个命题，则对于所有的 $p+q\\geq x-1$，如果其中一个命题不成立，另一个命题必须成立，否则它们加起来的下界也比 $x$ 大了。</p>\n<p>你可能会有疑惑：对于 $p+q\\geq x-1$ 的所有 $p,q$ 来说，我们如果只进行这样的限制，不是成了必要条件吗？</p>\n<p>这就要涉及到答案的统计方式了，我们找的是第一个满足 $\\leq $ 成立的值，因为它前面的都是 $&gt;$，而后面的都是 $\\leq$，显然只能选这个。</p>\n<p>你以为这就完了吗？No！</p>\n<p>万一这个 $x\\leq k$，那你选的数必须要 $\\leq x-1$。为什么这个限制不会被上面的囊括呢？因为上面的默认有一个可以不成立，但是一旦选的数 $\\geq x$，那另一个数就直接无解了啊！所以还要强制让这两个数 $\\leq x-1$。</p>\n</li>\n<li><p>约束3</p>\n<p>和约束2差不多，还是说一下附加限制。</p>\n<p>如果这个 $x\\geq k+2$，那么其中一个数 $\\leq 1$，另外一个数最小也得是 $k+1$，直接无解了，所以这两个数必须 $&gt;x-k-1$。</p>\n</li>\n<li><p>附附加限制</p>\n<p>一个数如果 $\\leq x$，那必然 $\\leq$ 所有 $&gt;x$ 的数。</p>\n<p>一个数如果 $&gt;x$，那必然 $&gt;$ 所有 $&lt; x$ 的数。</p>\n<p>题目中给定 $a$ 不降，所以 $a_i\\leq a_{i+1}$，即：</p>\n<p>$a_{i+1}\\leq x$ 时，$a_i\\leq x$；</p>\n<p>$a_i&gt;x$ 时，$a_{i+1}&gt;x$。</p>\n</li>\n</ul>\n<p>只需要把这亿点点限制加进去，就做完辣！（题如其名啊）</p>\n<p>这道题启示我们，2-SAT 问题一定要想到所有可能的不合法情况，把它们都限制掉，就是合法的了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">4e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,m,k,head[N],tot,dfn[N],low[N],cnt,sta[N],ins[N],tp,scc,c[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> k*(x<span class=\"number\">-1</span>)+y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tdfn[u] = low[u] = ++cnt;</span><br><span class=\"line\">\tsta[++tp] = u,ins[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!dfn[v])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(v);</span><br><span class=\"line\">\t\t\tlow[u] = <span class=\"built_in\">min</span>(low[u],low[v]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ins[v]) low[u] = <span class=\"built_in\">min</span>(low[u],dfn[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dfn[u] == low[u])&#123;</span><br><span class=\"line\">\t\tscc++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tv = sta[tp],tp--;</span><br><span class=\"line\">\t\t\tins[v] = <span class=\"number\">0</span>,c[v] = scc;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (v == u) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>)*(n*k*<span class=\"number\">2</span>+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(dfn,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>)*(n*k*<span class=\"number\">2</span>+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(low,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>)*(n*k*<span class=\"number\">2</span>+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t\ttot = cnt = scc = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> op,x,y,val;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(n*k,n*k*<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;op;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\tcin&gt;&gt;x&gt;&gt;val;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (val == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(x,val)+n*k,<span class=\"built_in\">get</span>(x,val));</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(x,val)+n*k,<span class=\"built_in\">get</span>(x,val<span class=\"number\">-1</span>)+n*k),<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(x,val<span class=\"number\">-1</span>),<span class=\"built_in\">get</span>(x,val));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (op == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;val;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (val&lt;=k)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(x,val<span class=\"number\">-1</span>),<span class=\"built_in\">get</span>(x,val<span class=\"number\">-1</span>)+n*k);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(y,val<span class=\"number\">-1</span>),<span class=\"built_in\">get</span>(y,val<span class=\"number\">-1</span>)+n*k);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=k;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">1</span>;p&lt;=k;p++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (j+p&gt;=val<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(x,j),<span class=\"built_in\">get</span>(y,p)+n*k),<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(y,p),<span class=\"built_in\">get</span>(x,j)+n*k);</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;val;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (val&gt;=k+<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(x,val-k<span class=\"number\">-1</span>)+n*k,<span class=\"built_in\">get</span>(x,val-k<span class=\"number\">-1</span>));</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(y,val-k<span class=\"number\">-1</span>)+n*k,<span class=\"built_in\">get</span>(y,val-k<span class=\"number\">-1</span>));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=k;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">1</span>;p&lt;=k;p++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (j+p&lt;val)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(x,j)+n*k,<span class=\"built_in\">get</span>(y,p)),<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(y,p)+n*k,<span class=\"built_in\">get</span>(x,j));</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=k;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(i+<span class=\"number\">1</span>,j)+n*k,<span class=\"built_in\">get</span>(i,j)+n*k),<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(i,j),<span class=\"built_in\">get</span>(i+<span class=\"number\">1</span>,j));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;k;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(i,j)+n*k,<span class=\"built_in\">get</span>(i,j+<span class=\"number\">1</span>)+n*k);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"built_in\">get</span>(i,j+<span class=\"number\">1</span>),<span class=\"built_in\">get</span>(i,j));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> lim = n*k*<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!dfn[i]) <span class=\"built_in\">dfs</span>(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n*k;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (c[i] == c[i+n*k])&#123;</span><br><span class=\"line\">\t\t\t\tflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!flag)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=k;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (c[<span class=\"built_in\">get</span>(i,j)]&gt;c[<span class=\"built_in\">get</span>(i,j)+n*k])&#123;</span><br><span class=\"line\">\t\t\t\t\tcout&lt;&lt;j&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","2-SAT","图论","缩点"]},{"title":"3.31 杂谈","url":"/2024/03/31/3-31-%E6%9D%82%E8%B0%88/","content":"<h1 id=\"3-31-杂谈\"><a href=\"#3-31-杂谈\" class=\"headerlink\" title=\"3.31 杂谈\"></a>3.31 杂谈</h1><p>最近再次染上感冒，赋闲在家，闲来无事，再谈谈人生。</p>\n<p>人，最难的是保持理性。</p>\n<p>无论是明知跑步大出汗仍食冰棒的我，还是厌倦学习拼命追番的我，亦或是整日面对电脑不想睡觉的我，三年前如何，现在还是如何。</p>\n<span id=\"more\"></span>\n<p>喜欢夜晚的理由？夜的黑与静谧使内心沉静，使欲望消解，似乎整个人更加成熟。但是，我是终究要面对阳光的。</p>\n<p>炎热的夏季，即将到来。身上的衣服，脱了一件又一件，内心也日渐焦虑。望着比我高出四五十分的同学，我竟不知怎么办才好。</p>\n<p>逃避主义，正要占领我的心灵，我不想再高谈阔论，因为现在的我，连最基本的理性，都无法保持啊！</p>\n<p>高考前的日夜，这么煎熬，又这么易逝。黄色的花，要么向阳而生，要么在秋风中凋零，但身处花苞中的我们，又怎能看见世界的精彩，怎能预知自己的未来？</p>\n<p>写上一些激励的话，无疑是最简单的，但又有什么用呢？面对无边黑暗，面对险峻高峰的，永远是你独自一人。</p>\n<p>忽然对哲学很感兴趣，研究世界构造的，确实高深许多，学习的源泉，大抵就是这一时的冲动吧。</p>\n<p>但当你行至千里，内心的激情早已不再，又是什么，支撑着你，继续前进呢？</p>\n<p>我想，是你的无知，只有对无知感到愤怒，才会奋不顾身，才会义无反顾。我们，生来便要穷世界之理，无论面对的是高考，还是人类，还是宇宙。</p>\n<p>也许，我该感谢生病在家的两天，让我整理自己，补充能量，再次出发。</p>\n<p>这次，多一些锐气，多一些沉稳，多一些坚持。</p>\n<p>​                                                                                        写给四月的自己</p>\n","tags":["Life"]},{"title":"ABC 254 D 题解","url":"/2022/10/26/ABC-254-D-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"ABC-254-D-题解\"><a href=\"#ABC-254-D-题解\" class=\"headerlink\" title=\"ABC 254 D 题解\"></a>ABC 254 D 题解</h1><p>考虑一个数$x$的分解：</p>\n<p>$x = p_1^{c_1}\\cdot p_2^{c_2}\\cdots p_n^{c_n}$</p>\n<p>显然，只有当两个数乘起来时，所有质因数的指数都是$2$的倍数时才能是一个平方数。</p>\n<span id=\"more\"></span>\n<h2 id=\"自己想的\"><a href=\"#自己想的\" class=\"headerlink\" title=\"自己想的\"></a>自己想的</h2><p>发现两个数能否凑成一对和指数有关，但是和指数具体是多少没有很大关系，只用知道指数的奇偶性就行了。</p>\n<p>$200000$里面大概有$20000$个质数，我们把每个数的指数看成一个长度为$20000$的串，其中指数是奇数的为$1$，偶数为$0$，最后就是求有多少个和它相同的数。</p>\n<p>可以直接把这些数扔进map里面，每次查询和它相同的数的个数，可以用$O(n\\log n)$的时间解决这个问题。</p>\n<p>之后就是怎么把一个数的分解算出来。直接$O(\\sqrt n)$分解必然超时，由于这里都是连续的数，所以想到筛子。</p>\n<p>线性筛太快了，我不会在上面做改动，于是大概可以通过魔改埃氏筛达到接近$O(21\\cdot n \\log n)$的复杂度。</p>\n<p>（以上为纯口胡，到埃氏筛的时候就觉得这个算法不对劲，因为写起来一定很长，不符合ABC的风格）</p>\n<p>所以看了眼题解。。。</p>\n<h2 id=\"题解说的\"><a href=\"#题解说的\" class=\"headerlink\" title=\"题解说的\"></a>题解说的</h2><p>设$f(i)$表示$i$中最大的平方因子，也就是说，$\\frac{i}{f(i)}$就是$i$中所有指数为奇数的质因子的乘积。</p>\n<p>先$O(n)$预处理出所有平方因子，再通过这些平方因子$O(n\\log n)$预处理出所有$f(i)$。</p>\n<p>之后就是求对于一个$i$，所有$\\frac{i\\cdot j}{f(i)\\cdot f(j)}$为平方因子的$j$的数量。</p>\n<p>然后因为所有$\\frac{i}{f(i)}$质因子的指数都是1，所以只用找所有$\\frac{i}{f(i)} = \\frac{j}{f(j)}$的数就行了。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">4e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,f[N];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> cnt[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>)*(n+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = i*i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=x;j&lt;=n;j+=x) f[j] = <span class=\"built_in\">min</span>(f[j],j/x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cnt[f[i]]++;</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans+=cnt[f[i]];</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>其实这两个算法殊途同归，但是实现上却有明显的差异，究其原因，大概是对性质的挖掘还不够深，不知道把求每个数的分解转化为求每个数指数$\\mod 2$之后的形式会更快，更好写。</p>\n<p>也许，这就是思维的重要性吧。</p>\n","tags":["Editorial","数学"]},{"title":"ABC248 E 题解","url":"/2022/04/16/ABC248-E-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"ABC248-E-题解\"><a href=\"#ABC248-E-题解\" class=\"headerlink\" title=\"ABC248 E 题解\"></a>ABC248 E 题解</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>计算几何用向量，把初中的知识扔到垃圾桶里面！</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"赛时错解\"><a href=\"#赛时错解\" class=\"headerlink\" title=\"赛时错解\"></a>赛时错解</h3><p>赛时的时候大概想的是把任意两点之间的直线方程写出来，之后计算有多少个相同的直线方程就可以了。</p>\n<p>这样看上去是不是很对？而且复杂度也是恰到好处的$O(n^3\\log n)$。</p>\n<span id=\"more\"></span>\n<p>随便造一组数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">3 2</span><br><span class=\"line\">-1000000000 -1000000000</span><br><span class=\"line\">1000000000 -999999999</span><br><span class=\"line\">1000000000 -999999998</span><br></pre></td></tr></table></figure>\n<p>可以发现在这样的精度下，结果精确到了小数点后第10位，这时，如果坐标比较随机，这样我们拿一个点的$(x,y)$通过$x\\cdot k+b-y=0$来判断是否在一条直线上，精度误差会非常大，就可能得到不在这条直线上的结论。</p>\n<p>什么意思呢？看这组数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">3 2</span><br><span class=\"line\">526541302 530345686</span><br><span class=\"line\">658662535 384363763</span><br><span class=\"line\">362264287 332982928</span><br></pre></td></tr></table></figure>\n<p>这个斜率我们是拿除法算出来的，但是当我们再乘回去时，就损失了非常大的精度（至少9位，如果除法非常准确的话），这就导致一个点的$x\\cdot k+b-y=0.000000000058208$，比我设定的精度$1e-12$大，所以得到了错误的结果（赛时我还一直在想如何增加精度，但是这样只是增加了小数点的位数，除法损失的精度依然不能弥补）。</p>\n<p>所以，我们最好在答案要求保留几位小数或值域不大时使用初中的方法。</p>\n<p>但是，这道题值域为$[-1e9,1e9]$，明摆着不放long double过，我们需要使用更高级的方法判断共线——向量。</p>\n<h3 id=\"向量正解\"><a href=\"#向量正解\" class=\"headerlink\" title=\"向量正解\"></a>向量正解</h3><p>还记得这个公式吗：若$\\overrightarrow {AB} = k\\cdot\\overrightarrow{AC}$，则$A,B,C$三点共线。</p>\n<p>于是，设$A = (x_1,y_1),B = (x_2,y_2),C = (x_3,y_3)$，则$(x_1-x_2)\\cdot(y_1-y_3) = (x_1-x_3)\\cdot (y_1-y_2)$。</p>\n<p>我们可以用乘法判断三点是否共线，只要枚举两点，再看和它们共线的点有多少个就行了。</p>\n<p>至于重复，由于这个$n$很小，可以直接用$vis[i][j]$表示是否访问过第$i$个点和第$j$个点组成的直线。</p>\n<p>总时间复杂度$O(n^3)$。</p>\n<p>（这貌似是我第一次用向量解决OI问题）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">6e3</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,vis[N][N],ans;</span><br><span class=\"line\">__int128 x[N],y[N];</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">read</span><span class=\"params\">(__int128 &amp;x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp;</span><br><span class=\"line\">\tcin&gt;&gt;tmp;</span><br><span class=\"line\">\tx = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;Infinity&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">read</span>(x[i]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">read</span>(y[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=i+<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\ta.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\t\ta.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t\ta.<span class=\"built_in\">push_back</span>(j);</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> cnt = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">1</span>;p&lt;=n;p++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (p == i || p == j || vis[p][i] || vis[p][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((x[i]-x[j])*(y[i]-y[p]) == (y[i]-y[j])*(x[i]-x[p]))&#123;</span><br><span class=\"line\">\t\t\t\t\tcnt++;</span><br><span class=\"line\">\t\t\t\t\ta.<span class=\"built_in\">push_back</span>(p);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x:a)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> y:a)&#123;</span><br><span class=\"line\">\t\t\t\t\tvis[x][y] = vis[y][x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tans+=(cnt&gt;=k);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","数学","计算几何"]},{"title":"ABC154F 题解","url":"/2022/11/21/ABC154F-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"ABC154F-题解\"><a href=\"#ABC154F-题解\" class=\"headerlink\" title=\"ABC154F 题解\"></a>ABC154F 题解</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>显然，答案可以拆成二维前缀和的形式。</p>\n<p>于是，问题变为求 $\\sum_{i=1}^n\\sum_{j=1}^m f(i,j)$。</p>\n<p>先看 $f(n,m)$ 怎么求。</p>\n<span id=\"more\"></span>\n<p>有一个非常显然的 dp：$f(n,m) = f(n-1,m)+f(n,m-1)$。</p>\n<p>这样直接做是 $O(nm)$ 的。</p>\n<p>因为每一步具有一般性，考虑其组合意义：</p>\n<p>有 $n$ 个 $1$ 和 $m$ 个 $0$，求组成的排列个数。</p>\n<p>显然是 $C(n+m,m)$。</p>\n<p>但是，用这个东西算上面的答案式，时间复杂度还是 $O(nm)$。</p>\n<p>考虑到答案是一个连续的和式，其必然有特殊性，可以快速计算。</p>\n<p>考虑构造差分：</p>\n<p>$f(n,m)-f(n-1,m) = f(n,m-1)$</p>\n<p>$f(n-1,m)-f(n-2,m) = f(n-1,m-1)$</p>\n<p>$f(n-2,m)-f(n-3,m) = f(n-2,m-1)$</p>\n<p>于是，$f(n,m)-f(n-k,m) = \\sum_{i=n-k+1}^nf(i,m-1)$。</p>\n<p>我们只需要知道 $1$ 到 $n$ 的和即可，特殊化：</p>\n<p>$\\sum_{i=1}^nf(i,m-1) = f(n,m)-f(0,m)$</p>\n<p>$\\sum_{i=1}^nf(i,m) = f(n,m+1)-f(0,m+1)$</p>\n<p>但是，$f(0,m+1)$ 这个状态没有被定义，考虑还是挪到 $2$。</p>\n<p>$\\sum_{i=2}^nf(i,m) = f(n,m+1)-f(1,m+1)$</p>\n<p>$i = 1$ 的直接 $O(n)$ 求即可。</p>\n<p>现在，我们还不能求 $f(i,m)$，考虑将这一部分也暴力求。</p>\n<p>时间复杂度为 $O(n)$。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>,lim = <span class=\"number\">2e6</span>+<span class=\"number\">2</span>,N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> r1,c1,r2,c2;</span><br><span class=\"line\">ll jie[N],inv[N];</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">ksm</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tll ret = <span class=\"number\">1</span>,bas = x;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ret = ret*bas%mod;</span><br><span class=\"line\">\t\tbas = bas*bas%mod;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">C</span><span class=\"params\">(<span class=\"type\">int</span> n,<span class=\"type\">int</span> m)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> jie[n]*inv[n-m]%mod*inv[m]%mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> n,<span class=\"type\">int</span> m)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">C</span>(n+m,m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">calc</span><span class=\"params\">(<span class=\"type\">int</span> r,<span class=\"type\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!r || !c) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\tll ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;c;i++)&#123;</span><br><span class=\"line\">\t\tret = (ret+<span class=\"built_in\">f</span>(r,i+<span class=\"number\">1</span>)-<span class=\"built_in\">f</span>(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>))%mod;</span><br><span class=\"line\">\t\tret = (ret+<span class=\"built_in\">f</span>(<span class=\"number\">1</span>,i))%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=r;i++) ret = (ret+<span class=\"built_in\">f</span>(i,c))%mod;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;r1&gt;&gt;c1&gt;&gt;r2&gt;&gt;c2;</span><br><span class=\"line\">\tjie[<span class=\"number\">0</span>] = <span class=\"number\">1</span>,inv[<span class=\"number\">0</span>] = <span class=\"built_in\">ksm</span>(jie[<span class=\"number\">0</span>],mod<span class=\"number\">-2</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\tjie[i] = jie[i<span class=\"number\">-1</span>]*i%mod;</span><br><span class=\"line\">\t\tinv[i] = <span class=\"built_in\">ksm</span>(jie[i],mod<span class=\"number\">-2</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;((<span class=\"built_in\">calc</span>(r2,c2)-<span class=\"built_in\">calc</span>(r1<span class=\"number\">-1</span>,c2)-<span class=\"built_in\">calc</span>(r2,c1<span class=\"number\">-1</span>)+<span class=\"built_in\">calc</span>(r1<span class=\"number\">-1</span>,c1<span class=\"number\">-1</span>))%mod+mod)%mod&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","数学","组合数学"]},{"title":"ABC281E Least Elements 题解","url":"/2023/01/18/ABC281E-Least-Elements-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"ABC281E-Least-Elements-题解\"><a href=\"#ABC281E-Least-Elements-题解\" class=\"headerlink\" title=\"ABC281E Least Elements 题解\"></a>ABC281E Least Elements 题解</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>去年的12月份，在**期间闲得无聊，就看了看当时的at，发现这道题比较可做，于是一直咕到了现在。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>对于这种连续区间问题，答案很明显，就是算变化。</p>\n<p>先用二叉堆维护初始问题的答案，假设现在向右移动一格。</p>\n<span id=\"more\"></span>\n<p>那么最左边的数不能要了，如果它本来就不在前 $k$ 小，那么不会产生影响，如果在，就删除它，加入之前不在的最小的数。</p>\n<p>最右边会加一个数，如果它不在现在的前 $k$ 小，不用管，如果在，就删除最大的一个数。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> mp make_pair</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,k,a[N],del[N],ins[N];</span><br><span class=\"line\">ll ans[N];</span><br><span class=\"line\">pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; tmp[N];</span><br><span class=\"line\">priority_queue&lt;pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; &gt; q1,q2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (q1.<span class=\"built_in\">size</span>()&lt;k) q1.<span class=\"built_in\">push</span>(<span class=\"built_in\">mp</span>(a[i],i));</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a[i]&lt;q1.<span class=\"built_in\">top</span>().first)&#123;</span><br><span class=\"line\">\t\t\tq2.<span class=\"built_in\">push</span>(<span class=\"built_in\">mp</span>(-q1.<span class=\"built_in\">top</span>().first,q1.<span class=\"built_in\">top</span>().second));</span><br><span class=\"line\">\t\t\tq1.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\tq1.<span class=\"built_in\">push</span>(<span class=\"built_in\">mp</span>(a[i],i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> q2.<span class=\"built_in\">push</span>(<span class=\"built_in\">mp</span>(-a[i],i));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\ttmp[i] = q1.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">\t\tans[<span class=\"number\">1</span>]+=q1.<span class=\"built_in\">top</span>().first;</span><br><span class=\"line\">\t\tq1.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans[<span class=\"number\">1</span>]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++) q1.<span class=\"built_in\">push</span>(tmp[i]),ins[tmp[i].second] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sz = k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n-m+<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">\t\tans[i] = ans[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pos1 = i<span class=\"number\">-1</span>,pos2 = i+m<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!q1.<span class=\"built_in\">empty</span>() &amp;&amp; q1.<span class=\"built_in\">top</span>().second&lt;i<span class=\"number\">-1</span>) q1.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ins[pos1])&#123;</span><br><span class=\"line\">\t\t\tans[i]-=a[pos1];</span><br><span class=\"line\">\t\t\tins[pos1] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tsz--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!q1.<span class=\"built_in\">empty</span>() &amp;&amp; q1.<span class=\"built_in\">top</span>().second&lt;i) q1.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\tq2.<span class=\"built_in\">push</span>(<span class=\"built_in\">mp</span>(-a[pos2],pos2));</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!q2.<span class=\"built_in\">empty</span>() &amp;&amp; q2.<span class=\"built_in\">top</span>().second&lt;i) q2.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sz&lt;k)&#123;</span><br><span class=\"line\">\t\t\tq1.<span class=\"built_in\">push</span>(<span class=\"built_in\">mp</span>(-q2.<span class=\"built_in\">top</span>().first,q2.<span class=\"built_in\">top</span>().second));</span><br><span class=\"line\">\t\t\tans[i]+=a[q2.<span class=\"built_in\">top</span>().second];</span><br><span class=\"line\">\t\t\tins[q2.<span class=\"built_in\">top</span>().second] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tq2.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\tsz++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (-q2.<span class=\"built_in\">top</span>().first&lt;q1.<span class=\"built_in\">top</span>().first)&#123;</span><br><span class=\"line\">\t\t\tans[i]-=q1.<span class=\"built_in\">top</span>().first;</span><br><span class=\"line\">\t\t\tins[q1.<span class=\"built_in\">top</span>().second] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> tmp1 = -q1.<span class=\"built_in\">top</span>().first,tmp2 = q1.<span class=\"built_in\">top</span>().second;</span><br><span class=\"line\">\t\t\tq1.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\tq1.<span class=\"built_in\">push</span>(<span class=\"built_in\">mp</span>(-q2.<span class=\"built_in\">top</span>().first,q2.<span class=\"built_in\">top</span>().second));</span><br><span class=\"line\">\t\t\tq2.<span class=\"built_in\">push</span>(<span class=\"built_in\">mp</span>(tmp1,tmp2));</span><br><span class=\"line\">\t\t\tins[q2.<span class=\"built_in\">top</span>().second] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tans[i]+=a[q2.<span class=\"built_in\">top</span>().second];</span><br><span class=\"line\">\t\t\tq2.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","贪心"]},{"title":"ABC276G 题解","url":"/2022/11/21/ABC276G-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"ABC276G-题解\"><a href=\"#ABC276G-题解\" class=\"headerlink\" title=\"ABC276G 题解\"></a>ABC276G 题解</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>赛时一直想不出来，果然还是我的组合数学太菜了。真就没做出来过一道计数题啊！</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>第一步非常神仙，我们把 $A$ 这个序列差分，得到一个序列 $B$。</p>\n<p>考虑 $B$ 需要满足的限制：</p>\n<ol>\n<li>$\\sum B_i = A_N\\leq M$。显然，差分数组加起来是最后一个数，并且序列不降，所以这个数是最大的，一定满足 $\\leq M$。</li>\n<li>$B_i\\mod 3 = 1\\  or \\ 2(2\\leq i\\leq n)$。因为题目中要求前后两个数模 $3$ 不同余，所以差分之后，模意义下的差显然不能为 $0$。</li>\n<li>$B_i\\geq 0$，因为序列不降。</li>\n</ol>\n<span id=\"more\"></span>\n<p>可以发现，这一步转化并没有损失任何信息（甚至所有的条件都有了对应），所以 $B$ 序列的个数即为 $A$ 序列的个数。</p>\n<p>想一想为什么要做转化：如果直接用 $A$，我们还需要限制 $A_{i-1}$ 的大小来满足不降的条件，无法转化为普通的组合问题，所以这样转化实际上简化了计算。</p>\n<p>之后，考虑将所有 $B_i$ 写成 $3k+r$ 的形式，如果能求出 $k$ 的排列数和 $r$ 的排列数，显然两两任意组合都合法，于是把它们两个乘起来就行了。</p>\n<p>先考虑 $k$，每个位置上填多少其实无所谓，我们只需要限制 $k$ 的和即可。</p>\n<p>思考一下，我们为什么要限制 $k$？如果 $k$ 太大了，可能导致最终加起来超过 $M$，仅此而已。</p>\n<p>于是，可以得到一个最初的限制：$\\sum_{i=1}^n3k_i+r_i\\leq M$。</p>\n<p>把 $r$ 移到右边去，左边就仅和 $k$ 相关了：$3\\sum k_i\\leq M-\\sum r_i$。</p>\n<p>于是，得到 $\\sum k_i\\leq \\lfloor \\frac{M-\\sum r_i}{3}\\rfloor$。</p>\n<p>也就是说，我们要求一个非负的，和为 $x$ 的序列的数量，使用插板法（多重集的组合数）得到答案为 $\\binom{x+n-1}{n-1}$。</p>\n<p>做一个前缀和即为和 $\\leq x$ 的序列的数量了。</p>\n<p>接下来，我们限制 $r$。</p>\n<p>$r$ 唯一的限制就是只能取 $1$ 和 $2$，其他的都不用管，因为 $k$ 也是随 $r$ 而发生变化的。</p>\n<p>考虑枚举 $1$ 的个数，假设现在有 $k$ 个 $1$，相当于在 $n$ 个数里面选 $k$ 个，即为 $\\binom{n}{k}$。</p>\n<p>最后，算一下时间复杂度：</p>\n<p>枚举 $r$ 是 $O(n)$ 的，$k$ 的计算可以 $O(n)$ 预处理出来每个值的答案，询问就是 $O(1)$ 的，计算组合数可以预处理出阶乘和对应的逆元，时间复杂度为 $O(n\\log n)$，时限 $4s$，可以通过。如果担心卡 $\\log$，可以替换为 $O(n+\\log n)$ 线性求逆元。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e7</span>+<span class=\"number\">10</span>,mod = <span class=\"number\">998244353</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,lim;</span><br><span class=\"line\">ll jie[N][<span class=\"number\">2</span>],inv[N],pre[N],ans;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ksm</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tll ret = <span class=\"number\">1</span>,bas = x;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ret = ret*bas%mod;</span><br><span class=\"line\">\t\tbas = bas*bas%mod;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">precalc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tjie[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = jie[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) jie[i][<span class=\"number\">0</span>] = jie[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>]*i%mod;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) jie[i][<span class=\"number\">1</span>] = jie[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]*jie[i][<span class=\"number\">0</span>]%mod;</span><br><span class=\"line\">\tll tmp = <span class=\"built_in\">ksm</span>(jie[lim][<span class=\"number\">1</span>],mod<span class=\"number\">-2</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=lim;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">\t\tinv[i] = tmp*jie[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]%mod;</span><br><span class=\"line\">\t\ttmp = tmp*jie[i][<span class=\"number\">0</span>]%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tinv[<span class=\"number\">0</span>] = inv[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">C</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> jie[x][<span class=\"number\">0</span>]*inv[x-y]%mod*inv[y]%mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">calck</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tpre[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) pre[i] = (pre[i<span class=\"number\">-1</span>]+<span class=\"built_in\">C</span>(i+n<span class=\"number\">-1</span>,n<span class=\"number\">-1</span>))%mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">calcr</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">2</span>;j++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> sum = j+i+(n<span class=\"number\">-1</span>-i)*<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (m-sum&gt;=<span class=\"number\">0</span>) ans = (ans+<span class=\"built_in\">C</span>(n<span class=\"number\">-1</span>,i)*pre[(m-sum)/<span class=\"number\">3</span>]%mod)%mod;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\tlim = n+m;</span><br><span class=\"line\">\t<span class=\"built_in\">precalc</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">calck</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">calcr</span>();</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","数学","组合数学"]},{"title":"Blog is open now!","url":"/2022/01/24/Blog-is-open-now/","content":"<h2 id=\"博客迁移已完成，之后的东西大概都在这里写了\"><a href=\"#博客迁移已完成，之后的东西大概都在这里写了\" class=\"headerlink\" title=\"博客迁移已完成，之后的东西大概都在这里写了\"></a>博客迁移已完成，之后的东西大概都在这里写了</h2><p>由于多重原因，洛谷博客据说要没了，昨晚考虑把博客迁移到这里来，经过一中午和一下午的努力，博客迁移工作终于完成了，之后的东西就都在这里写吧。</p>\n<p><a href=\"https://imgtu.com/i/7TSqln\"><img src=\"https://s4.ax1x.com/2022/01/24/7TSqln.png\" alt=\"截图\"></a></p>\n","tags":["Life"]},{"title":"Announcement","url":"/2022/08/03/Announcement/","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"1b64bf7b245062cd795b6e1ba0ad4a7fd614692947cba116051dc132ce85db3a\">1175ba61b191a60c3cf2c2c851ae0aed93d0282311d2614a472a1718e5a2d224ba8f51bf00f89deae52e95801de009802c2d714e40e0dceaca91cb87fc9af2586daaab52a3a21bdd5a2530c6a882817f26ec3a978e5b8d98289317b030fced188d8bd0dc733a058e95423c0e274fc724ba0b1656e434edb6683447dffb80cd5369eba31a3308d61fc19cb05e23ed9a4586d17ced200d4e5741a72de762519c3b60fd70b97f80f8d4161bd75b748f714da178981a854fefcdfaa9fce13321e98aa9676a275f23c8841bfc137b411df936ad93230919c45b069d5286b26d986e43e36f65f46baf26c645ef3de54f2b0a76d337f88ebaf24bd759132b1ff0fe78b78a12e06a130bfafcdf5664329ec2f54d9d059f30ae4f9c5897406aef1a91f9a4defeed88f02a170459133bcc2f7287e47210094960dfa2bd88874ff9bb402c0dee7d26c9109f8ed36ece27994e53a2eb52362cb6aa86daf99c47934b3f29fbf871e4164905771ac47b47c004338a7da3f29f52f180cbd09063f195fcd6b369cd05b19ed87ee5b4f49dccd0dfe559924002b8a10de56b3d361a352c6bc45f4a2f2739767e84cad4bcafa53d8c0b30ebb4b3ed2de00c39104d8513009e2f1c903f7970d73387b70d941e764976378ed3e42749898ad8531352180ca6a185a8782d1d9c8b03738a733d11f7f62b58460f97bb40b2d1b5cc63cc1230a22d0fdff1d61dcbb48b3548f9f0837ea8e5c30b8d3ca6d8706f99a987552e1bd8cf9142e53c98db3553ee431cb13e8d0817d1008eeec7e1457879da79bc01c0fdd61ce9a76235b1fb1f7715457e39dab5de4521b935c6bbd03ed5e7c6a11d1abf3bacc6e728c21972ff4eaee30c2835e5549b107f954a2d950af1e65c542a903fae55b56b50f3954d7621ebecda7c316e32208313c6c928a517d03358a9e7502caa99c29c95532e89bf58db668bbd0f07bb4ed0c6879fad17c95b0d1145f2814825e1f56f8e779d96166fa6132ae4f0f3e6d94e2b08d3d8823674a1cfd55700ba69ce30ae2b73633ba2d72d7486f8e9a17b1d38d31992258898d7fbb7e39d34ec6d9a925c4e177401b72ec691af65a5374f0a9a4baad4774a68a402ffef253bf27f11dc8010abe3f9cbd952d56debd7633d5d2d7185379dfc06113dc271449a90477edd685c03c9b110ed828a832b3f6e640459ee546b47c6e4f50e25500f3b440fb852d4ca7eb6d239856a29998bcc6b06f67cc6d67ff3f06fd8b60051ba5c0277bdf2313dfaf7e369ecc35dc9f1fef1e71ba87b5baa507dfe5b76faf05335f19d6db652d9aa3b8d0cebab3f750167969cfc59adfadd403dd52adcb487e924e575847296a21e28fe6a1de0e6b9fe49014b8dd125f2bebd6e36bed4caab8e5368c1b90cb9cf7a43121de073f90f8e42c7c0d6aae5ae59971a1b69c822ef7ea533be7f9a5424f005f137a81888c9d112a91bd7cbf2610d9b82222f82504fc794fe793df9c88bf0c381fcdc1d2efed947fa6097285c22c83c4f26ab255e8acea209f13ec503bad903fad2a4bb48a9a295f5ea7302da6b4c1e7e7ff84f7669085e7175dccd95510a02dad3f989b194deaaaf110e61d97f8591093e376ea4f45d1b8b847531d6c8c53919d1fc4c3098f3b429d342af6c63775fd13b94086067949cc93795e54ba1b131eecd9ffe7702f65e9457466c8127ff2cff66b319dbb72de85387897341c113145c1304a69e0db8fe5a731fea56ab656bd46ad1404a29ccea42dba5c3c9d5354ea0ef2a862361acc2ed6ab3cc2fec55020f9e5ffc71345900994a231b187e8513aa339e348591fc2b1ea65c889b2e1085bb2b20809d77bd9dc25fa4d6e60a074d61a10a3387a6fbcef00608d7b3a142eb1c767c07162992f6c9ba47d037ff8291755b7c95bdf4fa85aa5b285efd8a3674e34ac2f52fda809b75b595910f23035a6fbff5d71de06ce544c2902f65c802b5a52dfa5ac89d7db924d32a6a0a9c508ee3a20387350ee298ad8ffd7a3a50d0ae11a311aee6b1ff83e1bb97478985bb86ef9dbacbf77ed18255ffece70311994fbffc64f90f98186c655f74058f120678f2382129c1a796a3a17e5cb3759d87a1485cf795451227ba8458e66d2230b87c9b05982db8e7eb773472c0e8a2a7cb8d520d435c699fd1f5b0ba990bf37f21b9a722dbb0b15eacc448a448161fc7c125757d70c170b79431a13ed584ec2bf7fe94b562489a95b5429c254e5d9b493cd560e1d207eccd5831e222b2ed25cb402695e89aef3b44563cfe9c0e66f8d70694434906eb57494d502f0257238525f92a883eb7c24f50c83131c9adb671e58acdd348f580411b3cecf780bb1bd3381ba0f5251de4436f23244765ddfdd2a13c353c321509ec19a0285282efe983d6b0ddbd2077729dbfd8cb9cebbece4e92e50db33654032f19423429fcb72b08ffff2951837aa2933cbfcee346f20a3121834f073060d8310ff75acb9def3649481017a4b2d1ffbceec6b8e794f39ea73f</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">Enter Your Password Here</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","tags":["Secret"]},{"title":"CDQ 分治","url":"/2022/11/04/CDQ-%E5%88%86%E6%B2%BB/","content":"<h1 id=\"CDQ-分治\"><a href=\"#CDQ-分治\" class=\"headerlink\" title=\"CDQ 分治\"></a>CDQ 分治</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>CDQ 分治基于归并排序，在一些只有询问的题中，能简化代码，避免使用冗长的数据结构；在包含修改，但不要求强制在线的题中，通过加入一个全新的维度——时间轴，来简化代码，在和数据结构解法相同的理论复杂度下（常数较大，原因之后再说）解决问题，代码量却大大减少。</p>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>学习 CDQ 分治，首先要掌握归并排序。</p>\n<p>模板：<a href=\"https://www.luogu.com.cn/problem/P1908\">P1908 逆序对</a></p>\n<span id=\"more\"></span>\n<p>这道题用到了 CDQ 的核心思想：只计算左边的块对右边的块的贡献。</p>\n<p>我们进行归并排序的时候，总是先把序列分成两段，假设我们每次合并的时候，都算完了两个块内各自产生的逆序对数，那么它们合并起来，产生的逆序对，只用加上左块对右块的贡献即可。</p>\n<p>我们模拟一下归并排序的过程：</p>\n<p>维护两个指针，分别指向两个块的起点。</p>\n<p>选择两个指针中较小的一个，加入到排序后的数组中。</p>\n<p>重复此过程，直到其中一个指针到达了块的终点。</p>\n<p>产生逆序对是什么时候呢？显然是左块的指针比右块大。产生了多少呢？由于左块中比这个数大的都可以产生逆序对，所以从这个指针开始，到终点，都可以产生。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ms</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">ms</span>(l,mid);</span><br><span class=\"line\">\t<span class=\"built_in\">ms</span>(mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\t<span class=\"type\">int</span> p1 = l,p2 = mid+<span class=\"number\">1</span>,cnt = l<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p1&lt;=mid &amp;&amp; p2&lt;=r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[p1]&lt;=a[p2]) tmp[++cnt] = a[p1],p1++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> tmp[++cnt] = a[p2],p2++,ans+=mid-p1+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p1&lt;=mid) tmp[++cnt] = a[p1++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p2&lt;=r) tmp[++cnt] = a[p2++];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=l;i&lt;=r;i++) a[i] = tmp[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><p><a href=\"https://www.luogu.com.cn/problem/P3374\">P3374 【模板】树状数组 1</a></p>\n<p>众所周知，离线算法比较擅长处理不带修的问题，但是这道题有单点修改，怎么办？</p>\n<p>我们引入一个新的维度——时间轴，来使这些询问有序。</p>\n<p>对于询问区间和的操作，我们可以将它分成两个前缀和相减。</p>\n<p>于是，我们只需要求出前缀和即可，考虑使用归并排序，使操作按照位置排序。</p>\n<p>由于操作原来是按时间轴排好的，所以我们只用计算左边的修改对右边的查询的贡献。</p>\n<p>也就是说，统计左边修改的前缀和，累加到右边的询问操作中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cdq</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cdq</span>(l,mid),<span class=\"built_in\">cdq</span>(mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>,p = l,q = mid+<span class=\"number\">1</span>,o = l<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p&lt;=mid &amp;&amp; q&lt;=r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[p]&lt;a[q])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[p].ty == <span class=\"number\">1</span>) sum+=a[p].val;</span><br><span class=\"line\">\t\t\ttmp[++o] = a[p++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[q].ty == <span class=\"number\">2</span>) ans[a[q].val]-=sum;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[q].ty == <span class=\"number\">3</span>) ans[a[q].val]+=sum;</span><br><span class=\"line\">\t\t\ttmp[++o] = a[q++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p&lt;=mid) tmp[++o] = a[p++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (q&lt;=r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[q].ty == <span class=\"number\">2</span>) ans[a[q].val]-=sum;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[q].ty == <span class=\"number\">3</span>) ans[a[q].val]+=sum;</span><br><span class=\"line\">\t\ttmp[++o] = a[q++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=l;i&lt;=r;i++) a[i] = tmp[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"正题\"><a href=\"#正题\" class=\"headerlink\" title=\"正题\"></a>正题</h2><p><a href=\"https://www.luogu.com.cn/problem/P4169\">P4169 [Violet]天使玩偶/SJY摆棋子</a></p>\n<p>询问的是最近的曼哈顿距离，就先把绝对值拆掉，之后分成 $4$ 类考虑。</p>\n<p>现在，假设我们要找 $x,y$ 都比询问的点小的，也就是找到 $x+y$ 最大的一个，这个可以用树状数组维护。</p>\n<p>发现还带修改，所以要再维护一个时间轴维度。</p>\n<p>于是，我们先按照时间轴排序询问，再以 $x$ 为关键字归并排序，顺便维护 $x+y$ 的最大值其中为了保证 $x,y$ 都小，需要把树状数组中的下标用 $y$ 表示，相当于变相的以 $y$ 为关键字排序。</p>\n<p>注意常数优化。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">6e5</span>+<span class=\"number\">10</span>,M = <span class=\"number\">1e6</span>+<span class=\"number\">10</span>,lim = <span class=\"number\">1e6</span>+<span class=\"number\">1</span>,inf = <span class=\"number\">1e9</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,tr[M],tot,tot2,ans[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">opt</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> op,x,y,id;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"type\">const</span> opt &amp;b)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x == b.x?op&lt;b.op:x&lt;b.x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; a[N],tmp[N],bak[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;x&lt;=lim;x+=(x&amp;(-x))) tr[x] = <span class=\"built_in\">max</span>(tr[x],v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;x;x-=(x&amp;(-x))) ret = <span class=\"built_in\">max</span>(ret,tr[x]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret?ret:-inf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clr</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;x&lt;=lim;x+=(x&amp;(-x))) tr[x] = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cdq</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cdq</span>(l,mid),<span class=\"built_in\">cdq</span>(mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\t<span class=\"type\">int</span> p = l,q = mid+<span class=\"number\">1</span>,o = l;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p&lt;=mid &amp;&amp; q&lt;=r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[p]&lt;a[q])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[p].op == <span class=\"number\">1</span>) <span class=\"built_in\">update</span>(a[p].y,a[p].x+a[p].y);</span><br><span class=\"line\">\t\t\ttmp[o++] = a[p++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[q].op == <span class=\"number\">2</span>) ans[a[q].id] = <span class=\"built_in\">min</span>(ans[a[q].id],a[q].x+a[q].y-<span class=\"built_in\">query</span>(a[q].y));</span><br><span class=\"line\">\t\t\ttmp[o++] = a[q++];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p&lt;=mid) tmp[o++] = a[p++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (q&lt;=r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[q].op == <span class=\"number\">2</span>) ans[a[q].id] = <span class=\"built_in\">min</span>(ans[a[q].id],a[q].x+a[q].y-<span class=\"built_in\">query</span>(a[q].y));</span><br><span class=\"line\">\t\ttmp[o++] = a[q++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp = l,q = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p&lt;=mid &amp;&amp; q&lt;=r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[p]&lt;a[q])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[p].op == <span class=\"number\">1</span>) <span class=\"built_in\">clr</span>(a[p].y);</span><br><span class=\"line\">\t\t\tp++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> q++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=l;i&lt;=r;i++) a[i] = tmp[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\ttot++;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[tot].x&gt;&gt;a[tot].y;</span><br><span class=\"line\">\t\ta[tot].y++;</span><br><span class=\"line\">\t\ta[tot].op = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\ttot++;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[tot].op&gt;&gt;a[tot].x&gt;&gt;a[tot].y;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[tot].op == <span class=\"number\">2</span>) a[tot].id = ++tot2;</span><br><span class=\"line\">\t\ta[tot].y++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot2;i++) ans[i] = inf;</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(bak,a,<span class=\"built_in\">sizeof</span>(a));</span><br><span class=\"line\">\t<span class=\"built_in\">cdq</span>(<span class=\"number\">1</span>,tot);</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(a,bak,<span class=\"built_in\">sizeof</span>(bak));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\ta[i].x = (lim-a[i].x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">cdq</span>(<span class=\"number\">1</span>,tot);</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(a,bak,<span class=\"built_in\">sizeof</span>(bak));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\ta[i].y = (lim-a[i].y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">cdq</span>(<span class=\"number\">1</span>,tot);</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(a,bak,<span class=\"built_in\">sizeof</span>(bak));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\ta[i].x = (lim-a[i].x),a[i].y = (lim-a[i].y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">cdq</span>(<span class=\"number\">1</span>,tot);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot2;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>练习：<a href=\"https://www.luogu.com.cn/problem/P2163\">P2163 [SHOI2007]园丁的烦恼</a></p>\n","tags":["Knowledge","离线","分治"]},{"title":"CF D题汇总","url":"/2024/07/22/CF-D%E9%A2%98%E6%B1%87%E6%80%BB/","content":"<h1 id=\"CF-D题汇总\"><a href=\"#CF-D题汇总\" class=\"headerlink\" title=\"CF D题汇总\"></a>CF D题汇总</h1><h2 id=\"最近更新\"><a href=\"#最近更新\" class=\"headerlink\" title=\"最近更新\"></a>最近更新</h2><p>2024.8.11 添加1994D。</p>\n<h2 id=\"1988D\"><a href=\"#1988D\" class=\"headerlink\" title=\"1988D\"></a>1988D</h2><p><a href=\"https://codeforces.com/contest/1988/problem/D\">Link</a></p>\n<p>考点：复杂度观察，朴素做法优化。</p>\n<p>原先考虑的是黑白染色，之后发现不太行。虽然说理论上都可以两次删完（奇偶层），但不一定最优。</p>\n<p>考虑这样的情况，一条 $4$ 个节点的链，链的首尾都是 $10000$，中间都是 $1$，显然先删首尾，再删两次中间，共三次最优。</p>\n<span id=\"more\"></span>\n<p>dp 并不限制染色的数量，染色数量最大可以为 $n$，但是复杂度过高，为 $O(n^2)$。</p>\n<p>现在有一棵染完色的树，假设颜色从 $1$ 到 $k$，那么这个染成 $k$ 的节点，和它相连的所有点，至少包含 $1$ 到 $k-1$。</p>\n<p>定义 $f(i)$ 表示最大值为 $i$ 所需要的最少节点数量，从上面，至少有 $f(k)\\geq 1+\\sum_{i=1}^{k-1} f(i)$。手推一下，即可发现 $f(k)\\geq 2^{k-1}$。</p>\n<p>于是，染色数最大就是 $\\log n$ 级别的了。复杂度成功降成 $O(n\\log n)$。</p>\n<p>所以，有时不要放弃朴素做法，多观察，可能稍加优化就过了。</p>\n<p><a href=\"https://codeforces.com/contest/1988/submission/271897214\">Code</a></p>\n<h2 id=\"1990D\"><a href=\"#1990D\" class=\"headerlink\" title=\"1990D\"></a>1990D</h2><p><a href=\"https://codeforces.com/contest/1990/problem/D\">Link</a></p>\n<p>考点：观察</p>\n<p>一行最多被操作两次。如果操作三次及以上，显然最多也只会影响上下三行，不如用一行染白的操作搞三次。</p>\n<p>不好确定贪心策略，大概率是 dp。</p>\n<p>用正方形删，要么删前面两个，要么删前面四个，否则肯定要删三次以上。</p>\n<p>dp 转移就四种，要么不管或全删，要么删前面两个，要么删后面两个，要么删四个。</p>\n<p><a href=\"https://codeforces.com/contest/1990/submission/271896982\">Code</a></p>\n<h2 id=\"1994D\"><a href=\"#1994D\" class=\"headerlink\" title=\"1994D\"></a>1994D</h2><p><a href=\"https://codeforces.com/problemset/problem/1994/D\">Link</a></p>\n<p>考点：鸽巢原理</p>\n<p>通过观察样例，发现根本没有 NO，一般有 NO 的题绝对会给个例子启发思路，于是考虑一定有解。</p>\n<p>连边的顺序没有要求，但每次都要减少一个连通块，所以考虑先从限制大的开始连，即倒序连接。</p>\n<p>之后发现，缩点后每次有 $x+1$ 个点，但只需要 $\\mod x$ 即可连边，也就是说，肯定有两个点，它们 $\\mod x$ 的值相同，相减后一定能被 $x$ 整除，可以连边，于是可以保证有解。</p>\n<p>重点在于倒序思考。（我还以为要排序啥的）</p>\n<p><a href=\"https://codeforces.com/contest/1994/submission/275750548\">Code</a></p>\n<h2 id=\"2003D2\"><a href=\"#2003D2\" class=\"headerlink\" title=\"2003D2\"></a>2003D2</h2><p><a href=\"https://codeforces.com/contest/2003/problem/D2\">Link</a></p>\n<p>考点：DP，建图</p>\n<p>建议先看 D1，比较简单，每一个数列进行操作时，根据当前 $x$ 的不同，会得到两个不同的值，记为 $a,b$。</p>\n<p>显然，当 $x = a$ 时，会得到 $b$，$x \\neq a$ 时，会得到 $a$。</p>\n<p>此题中，每个数列只能用一次，所以不能无限套娃。如果要得到最大值，需要在一个数列操作后，用另一个数列再次操作，考虑从每个数列的 $a$ 向 $b$ 连边，如果当前在某个点，显然可以通过数列操作去所有出边，到达最大的点即为所求。</p>\n<p>问题在于，我们最开始可以在哪些点。显然不能从 $b$ 出发，只能从 $a$ 走，但如果最初的 $x$ 值不在 $a$ 里面，我们就需要先对一个数列操作得到 $a$，之后这个数列就用不了了。这等效于在图中的任意节点，删掉某一条出边，所能达到的最大节点。这是一个经典的 DP 问题，我选择从所有 $0$ 入度的点深搜维护 DP 数组。</p>\n<p>如果初始的 $x$ 在 $a$ 或 $b$ 里面，就可以从所有出边走了，可以在上面的 DP 中顺便维护。</p>\n<p><a href=\"https://codeforces.com/contest/2003/submission/278335509\">Code</a></p>\n","tags":["Editorial"]},{"title":"CF160D 题解","url":"/2023/02/01/CF160D-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"CF160D-题解\"><a href=\"#CF160D-题解\" class=\"headerlink\" title=\"CF160D 题解\"></a>CF160D 题解</h1><p>传送门：<a href=\"https://www.luogu.com.cn/problem/CF160D\">Edges in MST</a></p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>考虑 Kruskal 算法的过程，每次加入一个边权最小，且两个端点未被连通的边，加入 MST 中。</p>\n<span id=\"more\"></span>\n<p>如果一个边，它在比它边权小的边完成了上述过程后，两个端点已经连通，那么就不会加入 MST 中，这样的边对应的答案是 none。</p>\n<p>不好判断的地方在 any 和 at least one，即区分一个边是否能被替代。</p>\n<p>一个边能被替代，则替代它的一定是和它边权相等的边，因为如果边权不等，那么最小生成树的边权和会发生变化，不符合最小。</p>\n<p>现在，找到那些边权相等的边，把它们先都加入已经确定在最小生成树的边中。</p>\n<p>现在，我们显然得到了一个新的图，而其中的边，其实必要的只有我们新加的边权相等的边，因为原来的边连接的点全部连通，组成了许多连通块，当然就可以缩成几个点。</p>\n<p>假设我们已经缩点完毕，那么新加的边中，如果去掉一条边，整个图还是连通，而这个边在所有边加入之前，它的两个端点并未连通，就说明这个边处于一个环中，我们在环中不一定要选这个边让整个环连通，即它的答案是 at least one。至于那些去掉之后，整个图裂成两半的边，就是必需的，答案是 any。</p>\n<p>这些必需的边，不就是割边吗，问题转化为求割边，可以用 Tarjan $O(n)$ 解决。</p>\n<p>需要注意的是，我们使用并查集完成缩点，即一个连通块内的所有点都是并查集上祖先的点，每次完成加边后，由于整个图已经连通，要把这些边删掉，以保证时间复杂度。</p>\n<p>这样一来，时间复杂度为 $O(n+n\\log n) = O(n\\log n)$。</p>\n<p>总的来说，是一道不错的考察对 MST 的理解的题。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,head[N],tot,f[N],ans[N],dfn[N],low[N],cnt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,id;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ed</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,w,id;</span><br><span class=\"line\">&#125; ee[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(ed x,ed y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x.w&lt;y.w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x == f[x]) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> f[x] = <span class=\"built_in\">get</span>(f[x]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> id)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].id = id;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tdfn[u] = low[u] = ++cnt;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!dfn[v])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(v,edge[i].id);</span><br><span class=\"line\">\t\t\tlow[u] = <span class=\"built_in\">min</span>(low[u],low[v]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dfn[u]&lt;low[v]) ans[edge[i].id] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (edge[i].id!=fa) low[u] = <span class=\"built_in\">min</span>(low[u],dfn[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\tee[i] = &#123;x,y,z,i&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(ee+<span class=\"number\">1</span>,ee+<span class=\"number\">1</span>+m,cmp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) f[i] = i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>,j;i&lt;=m;i = j)&#123;</span><br><span class=\"line\">\t\tj = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (ee[j].w == ee[j<span class=\"number\">-1</span>].w &amp;&amp; j&lt;=m) j++;</span><br><span class=\"line\">\t\ttot = cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> x = <span class=\"built_in\">get</span>(ee[k].x),y = <span class=\"built_in\">get</span>(ee[k].y);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x == y)&#123;</span><br><span class=\"line\">\t\t\t\tans[ee[k].id] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(x,y,ee[k].id),<span class=\"built_in\">add</span>(y,x,ee[k].id);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> x = <span class=\"built_in\">get</span>(ee[k].x),y = <span class=\"built_in\">get</span>(ee[k].y);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x == y) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!dfn[x]) <span class=\"built_in\">dfs</span>(x,ee[k].id);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!dfn[y]) <span class=\"built_in\">dfs</span>(y,ee[k].id);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> x = <span class=\"built_in\">get</span>(ee[k].x),y = <span class=\"built_in\">get</span>(ee[k].y);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x == y) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tf[x] = y,head[x] = head[y] = dfn[x] = dfn[y] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans[i] == <span class=\"number\">1</span>) cout&lt;&lt;<span class=\"string\">&quot;any&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ans[i] == <span class=\"number\">-1</span>) cout&lt;&lt;<span class=\"string\">&quot;none&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;at least one&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","最小生成树","Tarjan"]},{"title":"Codeforces Round 850 Div2","url":"/2023/02/07/Codeforces-Round-850-Div2/","content":"<h1 id=\"Codeforces-Round-850-Div2\"><a href=\"#Codeforces-Round-850-Div2\" class=\"headerlink\" title=\"Codeforces Round 850 Div2\"></a>Codeforces Round 850 Div2</h1><h2 id=\"A1-amp-A2\"><a href=\"#A1-amp-A2\" class=\"headerlink\" title=\"A1&amp;A2\"></a>A1&amp;A2</h2><p>我们发现，一个区间内的数可以合并计算。黑白色的统计，由于每个点上的颜色只和它的奇偶性有关，且只有长度为奇数的区间内黑白色数量不同，把和端点颜色相同的颜色数量 $+1$ 即可。</p>\n<p>时间复杂度 $O(t\\sqrt n)$。</p>\n<p><a href=\"https://codeforces.com/contest/1786/submission/192416714\">A1</a></p>\n<p><a href=\"https://codeforces.com/contest/1786/submission/192417517\">A2</a></p>\n<span id=\"more\"></span>\n<h2 id=\"B\"><a href=\"#B\" class=\"headerlink\" title=\"B\"></a>B</h2><p>注意到不能有巧克力涂到区间外，所以每个喷口都必然对应一个蛋糕，且第 $i$ 个喷口对应第 $i$ 个蛋糕。</p>\n<p>考虑到限制只有喷口的区间是蛋糕的区间的子区间，设我们把喷口全部平移了 $k_i$ 个单位，则：</p>\n<p>$b_i+k_i+h\\leq a_i+w$</p>\n<p>$b_i+k_i-h\\geq a_i-w$</p>\n<p>得到 $k_i$ 的取值范围：</p>\n<p>$a_i-b_i-w+h\\leq k_i\\leq a_i-b_i+w-h$</p>\n<p>所有喷口都要对应蛋糕，所以这些 $k_i$ 要有交集，即其中左端点最大的一个比右端点最小的一个小。</p>\n<p>时间复杂度 $O(n\\log n)$。</p>\n<p><a href=\"https://codeforces.com/contest/1786/submission/192407583\">B</a></p>\n<h2 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C\"></a>C</h2><p>操作 $2$ 能连续进行，说明序列中有 $1,2,\\cdots$ 这样连续的一堆数（不计重复的）。</p>\n<p>考虑 $2$ 操作使用的时间。</p>\n<p>假设使用 $2$ 操作之后的数为 $a’_1,a’_2,\\cdots,a’_n$。</p>\n<p>则我们把之后对 $a’$ 进行的操作 $1$ 放到前面，并不会使答案更劣，因为所有怪的血量都减少，之前不能进行操作的怪被包括进来了，所以操作 $2$ 进行的次数会更多，从而使操作 $1$ 的次数更少。</p>\n<p>容易想到，先进行操作 $1$，把序列转化为一个操作 $2$ 可以带走的形式，即一堆连续的数。</p>\n<p>时间复杂度 $O(n\\log n)$。</p>\n<p><a href=\"https://codeforces.com/contest/1786/submission/192411058\">C</a></p>\n<h2 id=\"D\"><a href=\"#D\" class=\"headerlink\" title=\"D\"></a>D</h2><p>比较容易想的解法是找到所有人可以提供和需要的数，存到一个二维的 set 中，第一维表示需要啥，第二维表示提供啥。</p>\n<p>依次枚举每个人，找到它需要的和可以提供的，再看看有没有人需要它能提供的，提供它所需要的。</p>\n<p>但如果没有这样的人呢？我们先找一个能提供它所需要的人。</p>\n<p>这个人需要的肯定不是当前枚举的人提供的，也不是自己能提供的，于是就是唯一的。</p>\n<p>所以这样做是最优的。</p>\n<p>复杂度 $O(n\\log n)$。</p>\n<p>还可以转化为图论问题，一个人提供的向需要的连边，之后消去双向的边，再看环的个数。其实本质上和模拟差不多，但是更优雅。<del>而且更快</del></p>\n<p><a href=\"https://codeforces.com/contest/1786/submission/192415840\">D</a></p>\n<h2 id=\"E\"><a href=\"#E\" class=\"headerlink\" title=\"E\"></a>E</h2><p>这道题的代码量较大，我调了大概2h。</p>\n<p>显然，我们需要计算每加入一个数，对答案产生的贡献。</p>\n<p>这个加入的数有几种情况：</p>\n<ol>\n<li><p>假设我们现在已经有了 $1,2,3\\cdots$ 这个连续的序列，加入一个 $3$ 或其他在这个序列中的数，显然不会对答案产生贡献。</p>\n</li>\n<li><p>在 $1,2,4,5,6\\cdots$ 中 $4$ 的位置，会对答案产生贡献，因为它要变成 $3$。</p>\n<p>具体讨论这种贡献。</p>\n<p>比它小的数该干啥干啥，不会受到影响。</p>\n<p>它自身对答案的贡献就是它减去它要变成的数。</p>\n<p>后面的数处理较为复杂，因为可能出现重复的数，我们继续讨论。</p>\n<ol>\n<li><p>后面没有重复的数</p>\n<p>所有比它大的数，要到达的目标数因它的出现而增大 $1$，并且无论怎么添加数，它们都不可能小于新的目标数（不重复），贡献全部 $-1$。</p>\n</li>\n<li><p>后面有重复的数</p>\n<p>随着目标数的变化，有一些数将不再适应目标数。</p>\n<p>比如 $3\\ 3\\ 3\\ 2\\ 1$，先加入三个 $3$，它们的目标数分别为 $1,2,3$，在加入 $2$ 的时候，$2$ 的目标数是 $1$，于是三个 $3$ 的目标数分别是 $2,3,4$，注意到最后一个 $3$ 是不可能通过减法到达 $4$ 的，于是需要把最后一个 $3$ 去掉。</p>\n<p>每次最多有 $1$ 个数被去掉。</p>\n<p>被去掉的条件，显然是在加入当前数之前，这些重复的数，离目标数最近距离为 $0$，加入之后就会矛盾，所以要维护数值相同的数中，离目标数最近的距离。</p>\n<p>具体判断是否存在数被去掉，就等价于判断区间最小值是否为 $0$，可以用线段树维护。</p>\n<p>注意，我们判断的所有数，都必须要出现 $\\geq 2$ 次，所以还需要维护出现次数，并在合并时只合并出现 $2$ 次及以上的区间。</p>\n<p>在找到这个需要被去掉的数时，在它前面的数，还是会因为当前数的加入而贡献 $-1$，不要忘记这个贡献。</p>\n<p>具体实现因人而异，我自认为写的比较复杂和冗长，就不展开讲解我的实现思路了。</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>时间复杂度 $O(n\\log n)$。</p>\n<p><a href=\"https://codeforces.com/contest/1784/submission/192441539\">E</a></p>\n","tags":["图论","Editorial","贪心","线段树"]},{"title":"Counting Swaps 题解","url":"/2022/04/11/Counting-Swaps-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Counting-Swaps-题解\"><a href=\"#Counting-Swaps-题解\" class=\"headerlink\" title=\"Counting Swaps 题解\"></a>Counting Swaps 题解</h1><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我们得到的序列是$p_1,p_2\\cdots p_n$，如果从每个$i$向$p_j=i$的$j$连一条边，那么我们的目标就是使这个图中存在$n$个自环。</p>\n<h3 id=\"观察题目，得到猜想\"><a href=\"#观察题目，得到猜想\" class=\"headerlink\" title=\"观察题目，得到猜想\"></a>观察题目，得到猜想</h3><span id=\"more\"></span>\n<p><strong>结论1：这个图必然由若干个环构成。</strong></p>\n<p>由于点$i$连向$p_j=i$的$j$和$p_i$，所以每个点必然连接着两条边。如果图中有不是环的东西，那么必然存在一个点，其只有一条出边，这与每个点都连接两条边矛盾，所以原命题成立。</p>\n<p><strong>思考1：交换$p_i$和$p_j$会对原图产生什么影响？</strong></p>\n<p>之前连向$p_i$的是$p_q=i$的$q$和编号为$p_i$的点。</p>\n<p>显然，根据连边的规则，从编号为$p_i$的点连向$j$的边不会改变，但是另一条边变成了从$p_{q’}=j$连向$p_i$的边。</p>\n<p>另一个点连接的两个点分别是编号为$p_j$和$p_{q’’}=i$。</p>\n<p>其实手动模拟一下可能会更清晰。</p>\n<p>这样，这两个点就交换了各自的一条边，形成了两个环。</p>\n<p>形式化的说，如果原来的环是$v_1\\rightarrow v_2\\cdots v_n\\to v_1$，交换$i,j$（令$i&lt;j$）之后的环就变成了$v_i\\to v_{i+1}\\cdots v_j\\to v_i$和$v_1\\to v_2\\cdots v_i\\to v_{j+1}\\cdots v_n\\to v_1$。</p>\n<p>得到结论：在一个长度为$n$的环内交换$i,j$，会变成两个长度为$j-i$和$n-j+i$的环。</p>\n<p><strong>结论2：将一个包含$m$个点的环拆成$m$个自环，最少需要$m-1$次操作。</strong></p>\n<p>用数学归纳法证明。</p>\n<p>在$m=1$时，自己本身就是自环了，不用拆，需要$1-1 = 0$次操作。</p>\n<p>假设对于任意$i\\in [1,m-1]$，都只需要$m-1$次操作，那么对于一个长度为$m$的环，我们可以</p>\n<p>任取两个点$i,j$，交换它们，根据思考1，环将变成$j-i$和$m-j+i$两个环。</p>\n<p>而将这两个环拆成自环需要$j-i-1+m-j+i-1 = m-2$次操作，加上交换$i,j$这一次操作，总共需要$m-1$次操作。</p>\n<p>于是，原命题成立。</p>\n<h3 id=\"进一步思考\"><a href=\"#进一步思考\" class=\"headerlink\" title=\"进一步思考\"></a>进一步思考</h3><p>现在，我们已经知道了最小的次数是$n-$环的个数，要求总共有多少种交换的方法能够达到这个次数。</p>\n<p>设$F_n$表示用最少的次数将一个长度为$n$的环变为$n$个自环的方案数，根据思考1和结论2，我们可以把这个环拆成大小为$x$和$y$的两个环，设$T_(x,y)$表示有多少种方法拆成大小为$x$和$y$的两个环：</p>\n<p>当$x=y$时，$T(x,y) = n/2$，从$i$和$i+x$切没有区别。</p>\n<p>当$x\\neq y$时，$T(x,y) = n$，在任意一个点$i$切都是不同的方案。</p>\n<p>于是，$F_n = \\sum T(x,y)\\cdot F_x\\cdot F_y\\cdot \\frac{(n-2)!}{(x-1)!\\cdot (y-1)!}$。</p>\n<p>最后乘的那个东西可以看作有$x$个0和$y$个1的排列数，直接用多重集的排列数计算即可。</p>\n<p>至于为啥$x$个0都是相同的，因为区分操作的情况在计算$F_x$的时候就已经计算过了，所以这里可以把它们当成相同的。</p>\n<p>因为每个自环计算方案是独立的，所以我们要把所有的方案数乘起来，再像上面一样乘一个多重集的排列数：</p>\n<p>$ans = F_{l_1}\\cdot F_{l_2}\\cdots F_{l_k}\\cdot \\frac{(n-k)!}{(l_1-1)!\\cdot (l_2-1)! \\cdots (l_k-1)!}$。</p>\n<p>这样，我们可以$O(n^2)$推出所有我们需要的$F_i$值，之后乘起来，加个乘法逆元，总复杂度为$O(n^2\\log n)$。</p>\n<p>之后好像就没法优化了，除非你把$F_i$的前几项放到OEIS上去。。。</p>\n<p>于是，我们借助网络得到$F_i$的通向公式：$F_i = i^{i-2}$，这样复杂度就变成了$O(n\\log n)$。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>总之，这是一道非常不错（毒瘤）的组合入门题（至少<a href=\"https://www.luogu.com.cn/discuss/53018\">小粉兔是这么说的</a>），考察了对加法原理和乘法原理的理解、数学归纳法的使用、多重集的排列数的了解，需要一定的猜测和证明能力，组合数学的基础才能完全理解。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"$Code$\"></a>$Code$</h2><p>要在处理所有询问之前把$F_i$和阶乘预处理出来，这样复杂度才是对的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,p = <span class=\"number\">1e9</span>+<span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,a[N],head[N],tot,l[N],cnt,vis[N],jie[N],f[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ksm</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> p)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">1</span>,bas = x;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ans = ans*bas%p;</span><br><span class=\"line\">\t\tbas = bas*bas%p;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tf[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=<span class=\"number\">100000</span>;i++) f[i] = <span class=\"built_in\">ksm</span>(i,i<span class=\"number\">-2</span>,p);</span><br><span class=\"line\">\tjie[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">100000</span>;i++) jie[i] = jie[i<span class=\"number\">-1</span>]*i%p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\tvis[x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tl[cnt]++;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[v]) <span class=\"built_in\">dfs</span>(v);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">long</span> <span class=\"type\">long</span>)*(n+<span class=\"number\">100</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(l,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">long</span> <span class=\"type\">long</span>)*(n+<span class=\"number\">100</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">long</span> <span class=\"type\">long</span>)*(n+<span class=\"number\">100</span>));</span><br><span class=\"line\">\t\ttot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(a[i],i);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(i,a[i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\t\tcnt++;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">dfs</span>(i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans = <span class=\"number\">1</span>,num = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class=\"line\">\t\t\tans*=f[l[i]];</span><br><span class=\"line\">\t\t\tans%=p;</span><br><span class=\"line\">\t\t\tnum*=jie[l[i]<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t\tnum%=p;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans*=jie[n-cnt]*<span class=\"built_in\">ksm</span>(num,p<span class=\"number\">-2</span>,p)%p;</span><br><span class=\"line\">\t\tans%=p;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","数学","组合数学"]},{"title":"CSP2022 假期计划 题解","url":"/2022/10/31/CSP2022-%E5%81%87%E6%9C%9F%E8%AE%A1%E5%88%92-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"CSP2022-假期计划-题解\"><a href=\"#CSP2022-假期计划-题解\" class=\"headerlink\" title=\"CSP2022 假期计划 题解\"></a>CSP2022 假期计划 题解</h1><h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给你一个 $n$ 个点 $m$ 条边的无向图，点有点权，求一个从 $1$ 出发回到 $1$ 的路径，使得该路径上存在 $4$ 个<strong>不同</strong>的点，相邻两点之间经过的点和首尾两个点到 $1$ 经过的点个数均不超过 $k$ 个，且这 $4$ 个点的点权和最大。</p>\n<span id=\"more\"></span>\n<h2 id=\"赛时思路\"><a href=\"#赛时思路\" class=\"headerlink\" title=\"赛时思路\"></a>赛时思路</h2><p>这里的 $n$ 较小，提示我们可以使用 $O(n^2)$ 左右的算法。</p>\n<p>还有一个很特殊的是：这里只需要经过 $4$ 个点，暂时不知道有什么用。</p>\n<p>发现点之间的距离 $\\leq k$ 其实和 $k$ 只有一点关系，因为决定性因素是它们之间的最短路。</p>\n<p>反正这里的边都是 $1$，我们可以直接 BFS 算出两点间距离，时间复杂度为 $O(n^2)$。</p>\n<p>现在，如果在这些两点间距离不超过 $k$ 的点之间连边，就转化为 $k = 0$ 的问题了。</p>\n<p><del>没想到一开始以为送分的特殊性质是最难的。</del></p>\n<p>不过，这里的 $m$ 可能达到 $n^2$ 级别，这似乎也意味着时间复杂度跟它没啥关系。</p>\n<p>直接 dfs？不行，复杂度太高。<del>但是如果控制好时间，有可能拿到比预期高的分。</del></p>\n<h2 id=\"赛后补题\"><a href=\"#赛后补题\" class=\"headerlink\" title=\"赛后补题\"></a>赛后补题</h2><p>在网上看到一位大佬的题解，很有启发。</p>\n<p>在这里讲讲应该如何想到正解。</p>\n<p>观察这个路径，我们 dfs 超时的原因在于没办法利用到最后回到 $1$ 的性质，只能暴力特判。但如果你换一种角度看：</p>\n<p>$1-A-B-C-D-1\\iff 1-A-B\\ \\ C-D-1$</p>\n<p>其实，这可以分解成两个相等的子问题，知道这个性质后，随便搞搞即可得到 $O(n^3)$ 算法。</p>\n<p>发现难点其实在不重复（否则随便 dp 一下就是 $O(n^2)$ 算法了），我们如果盯着 $A,D$ 看，是非常不好确定 $B,C$ 的，因为它们既要满足和前面的距离不超过 $k$ 的限制，也要满足它们之间距离不超过 $k$ 的限制，不好做。</p>\n<p>考虑先预处理出来对于每个 $B$ 或 $C$，可能的 $A$ 或 $D$ 有哪些，如果你前面已经预处理出来两点之间距离的话，这个也是 $O(n^2)$ 的。</p>\n<p>$B$ 和 $C$ 之间的距离限制在枚举时就可以 $O(1)$ 解决，现在的限制就是 $A$ 和 $D$ 不能相同，$C$ 和 $A$ 不能相同，$B$ 和 $D$ 不能相同。</p>\n<p>不要急着枚举，我们发现，现在的问题其实是一个最优化问题，而不是可行性问题，也就是说，我们不用保存所有可能，只用保存可能最优的结果即可。</p>\n<p>设 $val[i]$ 表示 $B$ 或 $C$ 为 $i$ 时，$A+B$ 或 $C+D$ 的最大价值，由于 $B$ 或 $C$ 是确定的，相当于我们只需要维护 $A$ 或 $D$ 的最大价值。</p>\n<p>如果不考虑限制，显然是两个最大的一加。</p>\n<p>考虑限制，最坏的情况大概：</p>\n<p>$A$ 和 $D$ 相同，换 $A$，可能和 $C$ 相同，再换，这下绝对不可能相同了。如果换 $D$，可能和 $B$ 相同，再换，OK。</p>\n<p>有人可能会问：欸，不对啊，万一两边都换一次，$A$ 和 $D$ 又相同了呢，这样不就无限换下去了？</p>\n<p>你可真是个大聪明，但是想一想，既然你两边都换了一次，说明现在 $A \\neq B$，$C\\neq D$，那再怎么样，也不可能两边同时换，所以还是只用维护最大值、次大值和次次大值。</p>\n<p>所以，我们最终只用维护满足限制的 $A$ 或 $D$ 的最大、次大和次次大价值，就解决了此题！</p>\n<p>代码就不放了，常数巨大，跑的飞慢，还是建议看其他大佬的代码。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>回想一下解题的艰辛历程，其实最重要的还是从枚举 $A,D$ 转为枚举 $B,C$，这对能否解出几乎是决定性的，也是这道题区分度所在。</p>\n<p>为什么想到，究其原因，是因为这样转化能使限制减少：$B$ 和 $C$ 紧密连接，多了一个距离 $\\leq k$ 的限制，而 $A$ 和 $D$ 毫无关系，算法优劣，高下立判。</p>\n<p>所以，在思考问题时，不要盯着一点不放<del>比如我</del>，也不要没有方向的思考<del>怎么又是我</del>，深究问题本质（比如最后一步转化的最优化问题提示只需存储可能的最优解），针对性的思考，才能称霸赛场，叱咤风云！</p>\n<p>确实是一道好题！</p>\n","tags":["图论","Editorial"]},{"title":"Crash的数字表格 题解","url":"/2022/05/26/Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Crash的数字表格-题解\"><a href=\"#Crash的数字表格-题解\" class=\"headerlink\" title=\"Crash的数字表格 题解\"></a>Crash的数字表格 题解</h1><p>$\\sum_{i=1}^n\\sum_{j=1}^mlcm(i,j)$</p>\n<p>把$lcm$写成$\\gcd$的形式：</p>\n<p>$\\sum_{i=1}^n\\sum_{j=1}^m\\frac{ij}{\\gcd(i,j)}$</p>\n<p>枚举$\\gcd$：</p>\n<p>$\\sum_{d=1}^{min(n,m)}\\sum_{i=1}^n\\sum_{j=1}^m\\frac{ij}{d}[\\gcd(i/d,j/d) = 1]$</p>\n<span id=\"more\"></span>\n<p>设$i’=i/d$,$j’=j/d$，代入：</p>\n<p>$\\sum_{d=1}^{min(n,m)}\\sum_{i’=1}^{n/d}\\sum_{j’=1}^{m/d}i’j’d[gcd(i’,j’) = 1]$</p>\n<p>把$\\gcd$变成$\\mu$：</p>\n<p>$\\sum_{d=1}^{min(n,m)}d\\sum_{i’=1}^{n/d}\\sum_{j’=1}^{m/d}i’j’\\sum_{k|\\gcd(i’,j’)}\\mu(k)$</p>\n<p>枚举$k$：</p>\n<p>$\\sum_{d=1}^{min(n,m)}d\\sum_{k=1}^{min(n/d,m/d)}\\mu(k)k^2\\sum_{i’=1}^{n/kd}i’\\sum_{j’=1}^{m/kd}j’$</p>\n<p>后面的东西可以用等差数列优化：</p>\n<p>$\\sum_{d=1}^{min(n,m)}d\\sum_{k=1}^{min(n/d,m/d)}\\mu(k)k^2XY$</p>\n<p>前面的东西也可以用前缀和直接求出：</p>\n<p>$\\sum_{d=1}^{min(n,m)}d\\sum_{k=1}^{min(n/d,m/d)}Z\\frac{(1+\\frac{n}{kd})\\frac{n}{kd}}{2}\\cdot \\frac{(1+\\frac{m}{kd})\\cdot \\frac{m}{kd}}{2}$</p>\n<p>预处理出$\\mu$值和前缀和时间复杂度为$O(n)$，这个式子可以用两次数论分块，第一次分$n/d$和$m/d$相等，第二次分$n/kd$和$m/kd$相等，之后直接计算即可。总时间复杂度为$O(n)$。</p>\n","tags":["Editorial","数论","莫比乌斯反演"]},{"title":"DIVCNT2 题解","url":"/2022/06/25/DIVCNT2-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"DIVCNT2-题解\"><a href=\"#DIVCNT2-题解\" class=\"headerlink\" title=\"DIVCNT2 题解\"></a>DIVCNT2 题解</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>求$\\sum_{i=1}^n\\sigma(i^2)$，此处$\\sigma(i)$表示$i$的约数个数。</p>\n<p>$n\\leq 10^{12}$</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先考虑化简 $\\sigma(x^2)$：</p>\n<p>设 $x = p_1^{c_1}\\cdot p_2^{c_2}\\cdots p_k^{c_k}$，则 $x^2 = p_1^{2c_1}\\cdot p_2^{2c_2}\\cdots p_k^{2c_k}$。</p>\n<p>$\\sigma(x^2) = (2c_1+1)\\cdot (2c_2+1)\\cdots (2c_k+1)$</p>\n<p>好像化不下去了。（不过题解第一篇好像就是这样化的，有时间研究一下）</p>\n<p>换一种化法：</p>\n<p>$\\sum_{i=1}^n\\sum_{j|i}\\sum_{k|i}[\\gcd(j,k) = 1]$</p>\n<p>提出 $j$、$k$：</p>\n<p>$\\sum_{j=1}^n\\sum_{k=1}^n[\\gcd(j,k) = 1]\\sum_{j|i,k|i}1$</p>\n<p>由于只有 $\\gcd(j,k) = 1$ 时才有贡献，所以：</p>\n<p>$\\sum_{j=1}^n\\sum_{k=1}^n[\\gcd(j,k) = 1]\\sum_{jk|i}1$</p>\n<p>后面的东西可以化简：</p>\n<p>$\\sum_{j=1}^n\\sum_{k=1}^n[\\gcd(j,k) = 1]\\frac{n}{jk}$</p>\n<p>之后，令 $T = dk$：</p>\n<p>$\\sum_{T=1}^n\\frac{n}{T}\\sum_{j|T}[\\gcd(j,\\frac{T}{j}) = 1]$</p>\n<p>反演：</p>\n<p>$\\sum_{T=1}^n\\frac{n}{T}\\sum_{j|T}\\sum_{d|\\gcd(j,\\frac{T}{j})}\\mu(d)$</p>\n<p>枚举 $d$：</p>\n<p>$\\sum_{d=1}^n\\mu(d)\\sum_{T=1}^{n}\\frac{n}{T}\\sum_{j|T,d|\\frac{T}{j}}1$</p>\n<p>发现 $j$、$\\frac{T}{j}$ 都要满足是 $d$ 的倍数，就先给 $T$ 两个 $d$ ，之后就只用计算 $T$ 的约数个数就行了（此处的 $\\sigma(T)$ 和题目中意思相同）：</p>\n<p>$\\sum_{d=1}^{n}\\mu(d)\\sum_{T=1}^{\\frac{n}{d^2}}\\frac{n}{Td^2}\\sigma(T)$</p>\n<p>整除分块后，前面的 $\\mu$ 最大不超过 $10^6$，故可以直接预处理出来，只用考虑后面的东西怎么求就行了：</p>\n<p>$\\sum_{i=1}^n\\frac{n}{i}\\sigma(i)$</p>\n<p>对前面的系数整除分块，后面的 $\\sigma$ 很大的时候可以使用整除分块求解，加一个记忆化就是杜教筛的复杂度了（我不会分析，但是看上去长得就差不多嘛）。</p>\n<p>由于这个 $\\frac{n}{d^2}$ 非常小，所以复杂度不会太离谱。</p>\n<p>总时间复杂度为 $O(n^{\\frac{2}{3}})$，有亿点卡常。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ull;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">8e7</span>+<span class=\"number\">10</span>,M = <span class=\"number\">1e6</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,vis[N],pri[N/<span class=\"number\">10</span>],tot,mu[M+<span class=\"number\">10</span>],lim;</span><br><span class=\"line\">ll a[<span class=\"number\">10005</span>];</span><br><span class=\"line\">ull d[N];</span><br><span class=\"line\">map&lt;ll,ull&gt; mp;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\td[<span class=\"number\">1</span>] = mu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&lt;=M) mu[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\td[i] = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i*pri[j]&lt;=M &amp;&amp; vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i%pri[j]) d[i*pri[j]] = (d[i]&lt;&lt;<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> d[i*pri[j]] = (d[i]&lt;&lt;<span class=\"number\">1</span>)-d[i/pri[j]]; <span class=\"comment\">//每个数都被它的最小质因子筛一次 </span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) d[i]+=d[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ull <span class=\"title\">getdd</span><span class=\"params\">(ull x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&lt;=lim) <span class=\"keyword\">return</span> d[x];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mp.<span class=\"built_in\">count</span>(x)) <span class=\"keyword\">return</span> mp[x];</span><br><span class=\"line\">\tull ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (ull l = <span class=\"number\">1</span>,r;l&lt;=x;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tr = x/(x/l);</span><br><span class=\"line\">\t\tans+=(r-l+<span class=\"number\">1</span>)*(x/l);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mp[x] = ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ull <span class=\"title\">getd</span><span class=\"params\">(ull x)</span></span>&#123;</span><br><span class=\"line\">\tull ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (ull l=<span class=\"number\">1</span>,r;l&lt;=x;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tr = x/(x/l);</span><br><span class=\"line\">\t\tans+=(<span class=\"built_in\">getdd</span>(r)-<span class=\"built_in\">getdd</span>(l<span class=\"number\">-1</span>))*(x/l);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\tll Max = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=t;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tMax = <span class=\"built_in\">max</span>(Max,a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Max&lt;=<span class=\"number\">100000</span>) lim = <span class=\"number\">1000000</span>;</span><br><span class=\"line\">  \t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Max&lt;=<span class=\"number\">1000000000ll</span>) lim = <span class=\"number\">5000000</span>;</span><br><span class=\"line\">  \t<span class=\"keyword\">else</span> lim = <span class=\"number\">80000000</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tull ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=t;i++)&#123;</span><br><span class=\"line\">\t\tans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;<span class=\"number\">1ll</span>*j*j&lt;=a[i];j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!mu[j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tans+=<span class=\"built_in\">getd</span>(a[i]/j/j)*mu[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>莫比乌斯反演中考的无非就是约数啊，$\\gcd$ 啊，约数个数啊，这要求你对它们的性质了如指掌。</p>\n<p>比如这道题中，第一步的变形就是约数个数和中的常见套路，之后的不断更换求和指标也是常用技巧。</p>\n<p>当出现 $i\\cdot j$ 时，要用 $T$ 把它代替，这样才能有更多限制。</p>\n<p>不要遗漏式子中任何重要的信息，即使是小小的 $\\gcd(i,j) = 1$ 也包含 $i$、$j$ 互质这一重要条件。</p>\n<p>推式子时要想清楚式子的意义，在推不通时想更多的思路，更换更好的求和指标，最后才能到达成功的彼岸。</p>\n<p>式子即哲学，结果即真理。</p>\n","tags":["Editorial","数论","莫比乌斯反演","杜教筛"]},{"title":"Game on Tree 3 题解","url":"/2022/10/27/Game-on-Tree-3-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Game-on-Tree-3-题解\"><a href=\"#Game-on-Tree-3-题解\" class=\"headerlink\" title=\"Game on Tree 3 题解\"></a>Game on Tree 3 题解</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>Alice 和 Bob 玩游戏。有一个有根树（根为 $1$），有一个球在 $1$ 上。每轮开始，Bob 可以选择一个节点，将点权变为 $0$，Alice 在<strong>此操作后</strong>，可以将球移动到它的儿子节点。在每轮结束时，Alice 也可以选择结束游戏，如果移动到了叶子节点，游戏结束。最终的得分为结束时球所在的点的权值，Alice 想让得分最大，而 Bob 想让得分最小，问你最大得分。</p>\n<span id=\"more\"></span>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>观察，发现只要能得到 $\\geq x$ 分，那么 $&lt;x$ 的分数就不用算了，答案具有单调性，于是可以二分答案。</p>\n<p>假设现在我们要判断得分 $\\geq x$ 是否可行，Bob 显然只用考虑对那些分数 $\\geq x$ 的点操作，把这样的点对 Bob 操作次数的贡献设为 $1$，其他点设为 $0$。</p>\n<p>假设现在在点 $u$，设 $f[u]$ 为 Alice 操作前，Bob 使 $u$ 的子树中的点都变成 $0$ <strong>至少</strong>要操作多少次。</p>\n<p>由于这里是至少，所以我们要假设 Bob 无法猜测 Alice 的移动，所作的移动纯粹是在 Alice 移动之前的决策。</p>\n<p>所以需要把所有 Alice 可能走的地方都变成 $0$，即 $\\sum_{v\\in son_u}f[v]$。</p>\n<p>但是，Bob 总是在 Alice 之前做决策，所以可以在 $u$ 这里进行一次操作，原先所需的操作次数减 $1$，还要考虑到当 $u$ 的贡献为 $1$ 时，Bob 也需要把这个点变成 $0$，增加 $1$ 的代价，于是得到状态转移方程：</p>\n<p>$f[u] = \\max(\\sum_{v\\in son_u}f[v]-1,0)+(v[u] = 1)$</p>\n<p>Bob 必胜，当且仅当 $f[1] = 0$。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,a[N],head[N],tot,b[N],f[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v,sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tf[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t\tsum+=f[v];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsum = <span class=\"built_in\">max</span>(sum<span class=\"number\">-1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tf[u] = sum+b[u];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) b[i] = (a[i]&gt;=x);</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> f[<span class=\"number\">1</span>]!=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l = <span class=\"number\">0</span>,r = <span class=\"number\">0</span>,mid,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tr = <span class=\"built_in\">max</span>(r,a[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y),<span class=\"built_in\">add</span>(y,x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (l&lt;=r)&#123;</span><br><span class=\"line\">\t\tmid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">chk</span>(mid))&#123;</span><br><span class=\"line\">\t\t\tans = mid;</span><br><span class=\"line\">\t\t\tl = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = mid<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","DP","二分"]},{"title":"LCM SUM 题解","url":"/2022/05/26/LCM-SUM-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"LCM-SUM-题解\"><a href=\"#LCM-SUM-题解\" class=\"headerlink\" title=\"LCM SUM 题解\"></a>LCM SUM 题解</h1><h2 id=\"推式子\"><a href=\"#推式子\" class=\"headerlink\" title=\"推式子\"></a>推式子</h2><p>$\\sum_{i=1}^n lcm(i,n)$</p>\n<p>把$lcm$变为$\\gcd$：</p>\n<p>$\\sum_{i=1}^n\\frac{i\\cdot n}{\\gcd(i,n)}$</p>\n<p>枚举$\\gcd$：</p>\n<p>$\\sum_{d|n}\\sum_{i=1}^n\\frac{i\\cdot n}{d}[gcd(\\frac{i}{d},\\frac{n}{d}) = 1]$</p>\n<span id=\"more\"></span>\n<p>设$t = \\frac{i}{d}$：</p>\n<p>$\\sum_{d|n}\\sum_{t=1}^{\\frac{n}{d}}tn[\\gcd(t,\\frac{n}{d}) = 1]$</p>\n<p>这里的$\\frac{n}{d}$看着很不爽，且这里都是约数，所以可以直接用$d$替换$\\frac{n}{d}$：</p>\n<p>$n\\sum_{d|n}\\sum_{t=1}^{d}t[\\gcd(t,d) = 1]$</p>\n<h2 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h2><p>这不就是求和$d$互质的数的和吗？</p>\n<p>因为$gcd(a,b) = gcd(a,b-a)$，所以不互质的数成对出现，平均值为$\\frac{n}{2}$，所以和$d$互质的数的和为$\\frac{d\\cdot \\varphi(d)}{2}$。</p>\n<p>注意当$d=1$时，这个值为$1$。</p>\n<p>预处理的时间复杂度为$O(n)$，每组数据求约数的时间复杂度为$O(\\sqrt n)$，后面的查询是$O(1)$的。</p>\n<p>总时间复杂度为$O(n+T\\sqrt n)$。</p>\n<h2 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h2><p>可以用莫比乌斯反演吗？</p>\n<p>把$\\gcd$用$\\mu$替换掉：</p>\n<p>$n\\sum_{d|n}\\sum_{t=1}^dt\\sum_{k|gcd(t,d)}\\mu(k)$</p>\n<p>枚举$k$：</p>\n<p>$n\\sum_{k=1}^n\\mu(k)\\sum_{d|n,k|d}\\sum_{t=1}^{d}t$</p>\n<p>注意到$k$为$d$的约数，$d$为$n$的约数，即$k$为$n$的约数，所以可以缩小$k$的枚举范围：</p>\n<p>$n\\sum_{k|n}\\mu(k)\\sum_{d|n,k|d}\\frac{d^2+d}{2}$</p>\n<p>之后，设$d’ = \\frac{d}{k}$，代入式中：</p>\n<p>$n\\sum_{k|n}\\mu(k)\\sum_{d’|\\frac{n}{k}}k\\frac{d’^2+d’}{2}$</p>\n<p>把$k$提出去：</p>\n<p>$n\\sum_{k|n}\\mu(k)k\\sum_{d’|\\frac{n}{k}}\\frac{d’^2+d’}{2}$</p>\n<p>我们只对后面的进行分析，前面的直接$O(\\sqrt n)$暴力求解：</p>\n<p>$\\sum_{d’|\\frac{n}{k}}\\frac{d’^2+d’}{2}$</p>\n<p>枚举$d’$，对它的所有倍数贡献$\\frac{d’^2+d’}{2}$，把所有$\\frac{n}{k}$的和都预处理出来，每次查询可以做到$O(1)$。</p>\n<p>预处理$\\mu$和$sum[\\frac{n}{k}]$的时间复杂度为$O(n+n\\log n)$，每组数据枚举$k$的时间复杂度为$O(\\sqrt n)$，求和时间复杂度为$O(1)$。</p>\n<p>于是，算法的总时间复杂度为$O(n\\log n+T\\sqrt n)$。</p>\n","tags":["Editorial","数论","莫比乌斯反演"]},{"title":"Global Round 23 D 题解","url":"/2022/10/23/Global-Round-23-D-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Global-Round-23-D-题解\"><a href=\"#Global-Round-23-D-题解\" class=\"headerlink\" title=\"Global Round 23 D 题解\"></a>Global Round 23 D 题解</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>观察到，如果确定了一个点经过的次数，那它的儿子的次数基本确定了，且只受这个点的控制。</p>\n<p>所以这道题大概是个子树类 dp。</p>\n<p>具体来说，假设一个点经过了 $num$ 次，它有 $k$ 个儿子，考虑儿子走的次数。</p>\n<p>由于任意两个儿子之间的次数差不超过 $1$，所以所有儿子必然至少走过 $\\lfloor \\frac{num}{k}\\rfloor$ 次，还要选择 $num\\mod k$ 个儿子再走一次。</p>\n<span id=\"more\"></span>\n<p>题目要求答案最大，所以可以直接贪心，选择儿子中贡献最大的 $num\\mod k$ 个。</p>\n<p>可以考虑每次对每个儿子 $dfs$ 两遍，分别代表走 $\\lfloor \\frac{num}{k}\\rfloor$ 和 $\\lfloor \\frac{num}{k}\\rfloor+1$ 次，选择两者差值最大的 $num\\mod k$ 个。</p>\n<p>这里一定要以你要走的次数去 $dfs$，而不能仅仅依靠 $dfs(v,1)$ 来判断谁更优，因为次数不同，方案可能截然不同。</p>\n<p>而且，也不能选择走 $\\lfloor \\frac{num}{k}\\rfloor+1$ 次中最大的几个，因为在加上它的贡献的同时，还要减去走 $\\lfloor \\frac{num}{k}\\rfloor$ 次的贡献。</p>\n<p>由于是树形 dp，所以复杂度是经典的 $O(n\\log n)$。</p>\n<p>但是，这样写会有大常数，因为每次要 $dfs$ 两遍。建议还是对每一次求出的值记忆化一下，容易证明这样做只会有 $n$ 个状态，所以就是严格的 $O(n\\log n)$ 了。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,k,head[N],tot,s[N],cnt[N];</span><br><span class=\"line\">ll f[N],tmp[N];</span><br><span class=\"line\">map&lt;pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;,ll&gt; mp;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mp.<span class=\"built_in\">count</span>(<span class=\"built_in\">make_pair</span>(u,num))) <span class=\"keyword\">return</span> mp[<span class=\"built_in\">make_pair</span>(u,num)];</span><br><span class=\"line\">\t<span class=\"type\">int</span> v,bas = <span class=\"number\">0</span>,lim = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tf[u] = <span class=\"number\">1ll</span>*num*s[u];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt[u]) bas = num/cnt[u],lim = num%cnt[u];</span><br><span class=\"line\">\tll tmp1,tmp2;</span><br><span class=\"line\">\tvector&lt;ll&gt; tmp;</span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;ll&gt;().<span class=\"built_in\">swap</span>(tmp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\ttmp1 = <span class=\"built_in\">dfs</span>(v,bas);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (lim) tmp2 = <span class=\"built_in\">dfs</span>(v,bas+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tf[u]+=tmp1;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (lim) tmp.<span class=\"built_in\">pb</span>(tmp2-tmp1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (lim)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(tmp.<span class=\"built_in\">begin</span>(),tmp.<span class=\"built_in\">end</span>(),<span class=\"built_in\">greater</span>&lt;<span class=\"type\">int</span>&gt;());</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;lim;i++) f[u]+=tmp[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmp[<span class=\"built_in\">make_pair</span>(u,num)] = f[u];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> f[u];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>)*(n+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(cnt,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>)*(n+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t\tmp.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\ttot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(x,i),cnt[x]++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;s[i];</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,k)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","动态规划","树形dp"]},{"title":"NOIP2021 Journal","url":"/2021/11/20/NOIP2021-Journal/","content":"<p>人生中第一场NOIP，就这样落幕了</p>\n<h1 id=\"Day-1\"><a href=\"#Day-1\" class=\"headerlink\" title=\"Day -1\"></a>Day -1</h1><p>随便打了几个板子，发现没有什么需要复习的，因为所学实在太少，心态也十分放松，大概是知道自己状态不好，在短时间内也无法挽救，不会的知识实在太多，而能熟练运用的又太少，感觉再做什么也无济于事了。</p>\n<p><del>于是看了Person Of Interest Season 4，突然很想写一个能和我对话、保护我、洞悉世事的程序</del></p>\n<p>是的，考试的前一天就这样平凡地过去了  </p>\n<span id=\"more\"></span>\n<h1 id=\"Day-1-1\"><a href=\"#Day-1-1\" class=\"headerlink\" title=\"Day 1\"></a>Day 1</h1><p>大概7：50就进了考场，找到自己的座位，却发现电脑没开。于是自行打开，却发现有两个Windows10？等了一会，老师说用第二个，于是不那么顺利地进入了系统。</p>\n<p>先把缺省源打了，之后打了个对拍器，发现没关同步，于是加了两行代码到缺省源里，设置了编译选项，准备工作完成。</p>\n<p>大概在打完后不就，发现试卷的密码在大屏幕上，好像是IronHeart之类的（<del>钢铁雄心？？？</del>），难道出题人是Paradox玩家？但是没时间想那么多了，解压完成后就立刻打开了试题。</p>\n<p>照例先开第一题，发现题目说的东西很奇怪，而且数据范围也并非线性：$1e7$，这$O(nlogn)$都有点悬，不会要$O(n)$吧，但是这样也小了个七八倍，反正就很奇怪。</p>\n<p>之后仔细看了下题，发现只要把每一个符合条件的数的倍数都标记一遍就行了？（好像这便是著名的$O(nlogn)$算法）</p>\n<p>但是我觉得题目肯定不会这么简单，这样写肯定是要被卡的，于是研究了很久的性质，发现只要标记一个符合条件的数的质数倍就行了，因为合数肯定可以表示为若干个质数的乘积。</p>\n<p>但是即使这样写，也可能有TLE的风险，因为这样筛并不是绝对线性的，例如<strong>宇宙所有问题的终极答案$42$</strong>，它既可以表示成$14\\times3 = 7\\times2\\times3$，也可以表示成$21\\times2 = 7\\times3\\times2$，这样数$42$就被标记了两次，显然还有更多这样的数，所以这样做就不是线性的</p>\n<p>如何让每个数只被标记一次呢？其实也很显然：只要一个数的倍数被分解为的质因数中最小的数小于等于要乘的质数，就行了，因为满足倍数被分解为若干个不降的质数的情况只有一种。很好，这样就是完全线性的了！</p>\n<p>但是我没想到的是，由于还要用一遍$Euler$筛筛出所有的质数，所以复杂度是两个$O(n)$的，实测跑的比广为流传的$O(nlogn)$算法还要慢。。。</p>\n<p>由于各种意想不到的$bug$，过了$1.5h$才打完T1且开拍了</p>\n<p>算了，反正T1写完了，按理说要看T2了，于是我就看了。</p>\n<p>第一眼是一个以$m+1$为指数的暴力，开心地在$30min$左右写完了，发现样例2要跑$11s$？感觉再优化也没什么希望了，就暂时放下了，开T3</p>\n<p>T3一看，就想到了ZROI上的一道题，然而看了好久，发现其本质不是一个东西，拿前缀和推也没啥性质，而且这个序列可能可以无限操作下去，很难有重复的情况，推了一堆没有用的东西，发现只剩下$1.5h$左右了，以我的水平顶多打几个暴力走人，于是看了眼T4，发现没啥希望，跟斗地主一样恶心，就回去看T2了</p>\n<p>突然发现这样搜索搜到了很多重复的情况，很明显是不优的，如果改成枚举每一位选了多少个，就可以用排列乘出所有的情况，复杂度有了小小的改善，于是开写</p>\n<p>写完之后，发现乘那个权值时<strong>int128爆了，于是开始写高精，发现不会$log$的取模，于是把写了$45min$的高精代码删了，又改成</strong>int128，感觉没啥希望了，于是写T3的暴力</p>\n<p>T3由于不知道要操作多少次，就找了一个有可能过$n&lt;=10$的点且不超时的$9$次放进去了，发现第二个样例都过不了，此时离考试结束只有$30min$不到了，于是把考生须知填了，之后开始打坐。</p>\n<p>所有程序的文件名检查完之后，又看了一眼题面，试图找到一点思路，突然发现T2说的是小于等于$k$，草！</p>\n<p>于是疯狂改，再边乘边取模，最后竟然过了样例2？很满意</p>\n<p>打铃，收卷，结束。</p>\n<p>是的，我的第一场NOIP就这样结束了，内心毫无波澜的提交了文件夹，看见人均200+，虽有失望，可是并没有为此懊恼，因为有那么多没学的，有那么多不会的$trick$，这也很公平。</p>\n<p>停课结束后，又要投入到紧张的$whk$学习中，虽然有那么多不会的，那又如何呢，总是要补的。</p>\n<p>其实，生活中许多不如意，是你欠你自己的，付出与回报不会成正比，但是要回报，必须付出些什么，而最不必的便是为这些付出懊恼，你欠的，总是要还回来的嘛。</p>\n<blockquote>\n<p>This is my final fit</p>\n<p>My final bellyache with</p>\n<p>No alarms and no surprises</p>\n<p>No alarms and no surprises please</p>\n</blockquote>\n","tags":["Life"]},{"title":"P2261 余数求和 题解","url":"/2022/04/01/P2261-%E4%BD%99%E6%95%B0%E6%B1%82%E5%92%8C-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"P2261-余数求和-题解\"><a href=\"#P2261-余数求和-题解\" class=\"headerlink\" title=\"P2261 余数求和 题解\"></a>P2261 余数求和 题解</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>好像每次看到这个题都挺懵的，思路不太好想。</p>\n<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给定$n$和$k$，求出$k \\ mod \\ 1+k \\ mod \\ 2+ \\cdot \\cdot \\cdot k \\ mod \\ n$。</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>这个东西看上去就不太能直接求。</p>\n<p>我们既然不能一眼看出怎么求，那就多看几眼。</p>\n<p>$k \\ mod \\ i = k-\\lfloor k/i \\rfloor \\cdot i$</p>\n<p>这样，我们要求的东西就变成了：$k \\cdot n - \\sum_{i=1}^{n} \\lfloor k/i \\rfloor \\cdot i$</p>\n<p>这个$\\lfloor k/i \\rfloor$显然在$i$更大时变化的几率会越来越小，我们想一想怎么把它变化的规律找出来。</p>\n<p>（事实上，这个好像是数论分块里的内容，只能说：见多识广啊）</p>\n<p>我们凭空捏造一个函数$g(x) = \\lfloor k/\\lfloor k/x \\rfloor \\rfloor$。</p>\n<p>$f(x) = k/x$是单调递减的，所以$g(x)\\geq\\lfloor k/(k/x) \\rfloor = x$，所以$\\lfloor k/g(x) \\rfloor \\leq \\lfloor k/x \\rfloor$。</p>\n<p>又因为$\\lfloor k/g(x) \\rfloor \\geq \\lfloor k/(k/\\lfloor k/x \\rfloor) \\rfloor = \\lfloor k/x \\rfloor$，所以$\\lfloor k/g(x) \\rfloor = \\lfloor k/x \\rfloor$。</p>\n<p>所以，对于任意$i \\in [x,\\lfloor k/ \\lfloor k/x \\rfloor \\rfloor]$，$\\lfloor k/i \\rfloor$都相等。</p>\n<p>而且，每个数都必然属于所有区间中的一个，所以我们可以枚举左右端点，里面的$\\lfloor k/i \\rfloor \\cdot i$就是等差数列求和。</p>\n<p>由于在$\\sqrt{k}$以内的$i$，最多有$\\sqrt{k}$个$\\lfloor k/i \\rfloor$，所以这个式子的取值最多有$\\sqrt{k}$种，而在$\\sqrt{k}$以外的$i$，$k/i\\leq \\sqrt{k}$，所以这个式子最多也有$\\sqrt{k}$种取值，那么对于所有的$i$，最多只有$2\\sqrt{k}$种取值，所以整个算法的时间复杂度为$O(\\sqrt{k})$。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">int</span> n,k;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r,ans = n*k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>;l&lt;=n;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (k/l == <span class=\"number\">0</span>) r = n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = <span class=\"built_in\">min</span>(k/(k/l),n);</span><br><span class=\"line\">\t\tans-=(r-l+<span class=\"number\">1</span>)*(k/l*l+k/l*r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","数学"]},{"title":"P3959 宝藏 题解","url":"/2022/03/28/P3959-%E5%AE%9D%E8%97%8F-%E9%A2%98%E8%A7%A3/","content":"<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给出一个$n$个节点，$m$条边的图，你可以选定一个节点，从这个节点开始遍历整个图，其中每走到一条新的边，就要花费$l*k$的代价，其中$l$是这条边的边权，$k$是从你选定的点到这条边的起点经过的宝藏屋的数量。</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"一些初步的想法\"><a href=\"#一些初步的想法\" class=\"headerlink\" title=\"一些初步的想法\"></a>一些初步的想法</h3><p>没有啥思路就直接暴搜。</p>\n<p>首先要枚举选择的起点，还要枚举选择的边，形式化的说，给每个边都定一个访问顺序，如果不访问就设为$0$，每个点都有$n+1$种选择，复杂度大概是$O(m^n)$的，啥都过不了。</p>\n<p>于是考虑优化。</p>\n<p>选定的边组成的必然是一棵树，这样才能使代价最小，而对于同一棵树而言，节点的选择顺序不会对答案有影响，所以我们可以枚举树，计算每个树的答案。枚举的过程是从$m$条边中选择$n-1$条，复杂度是$m\\cdot(m-1)\\cdot (m-2) \\cdot \\cdot \\cdot (m-n+1)$，计算每个树的答案可以直接换根dp解决，复杂度是$O(n)$的，这时，复杂度已经有了明显的改善。</p>\n<p>还有没有优化空间呢？有。</p>\n<p>因为我们是随便找出的$n-1$条边，它们不一定能构成树，而且题目里面有重边，显然我们只用选一个长度最小的就行了，这样边最多是$66$条，复杂度明显降低了。</p>\n<p>但是这里的$n$和$m$依旧不是一个量级的，我们能不能用$n$作为复杂度呢？</p>\n<p>我们直接搜索，重复状态很多，同一张图，选择不同的根，就会有$n$种状态，而我们用这个图转移到下一个图，只用从其中最小的状态转移，这样就减少了很多重复计算。</p>\n<p>既然状态有很多重复的，但是状态空间并不大，我们可以考虑使用<strong>状压DP</strong>优化。</p>\n<h3 id=\"一种错误的解法\"><a href=\"#一种错误的解法\" class=\"headerlink\" title=\"一种错误的解法\"></a>一种错误的解法</h3><p>设点$i$被选择为$1$，不被选择为$0$，这样我们可以表示在每个阶段中的状态。</p>\n<p>设$f[i]$表示压缩后的点的选择情况，我们枚举每个没有被选择，且能从已经被选择的其中一个点到达的点，选择一条路径到达那个点，这样就可以计算出要转移到的状态和最小值，如果存在一个更优解，就从这个状态继续转移。</p>\n<p>但是，一定是在有更优解的时候才会转移吗？</p>\n<p>如果一个点的深度比较小，但是这个点连向下一个点的边权比较大，我们可能会因为它转移到下一个状态时不是最优解而不再转移，但是如果让它继续转移下去，下面的点之间的边权较小，就有可能因为它的深度获益，这样可能会达到一个更优的解。</p>\n<p>所以，我认为这样做是错误的。</p>\n<p>据cyh大佬说，这是因为在同一个状态$s$中可能有一个点的深度不同，那么就不知道用哪个深度转移是最优的。</p>\n<h3 id=\"正确解法\"><a href=\"#正确解法\" class=\"headerlink\" title=\"正确解法\"></a>正确解法</h3><p>上面算法的错误在于没有限定深度，导致不同深度的时候转移不完全，我们其实可以限定一个当前的最大深度，之后把所有位于最大深度的点转移。</p>\n<p>设$f[i][j]$表示在最大深度为$i$，选择状态为$j$时的最小花费，那么$f[i][j] = max(f[i][j],f[i-1][k]+(i-1)\\cdot cost(j,k))$。</p>\n<p>我们先判断上一个状态的合法性：</p>\n<p>首先，这个状态要被转移过，否则转移它也没啥用，所以$f[i-1][k]$不等于初始值。</p>\n<p>其次，这个状态要满足从$k$能转移到$j$，这时就要考虑两个限制：</p>\n<ol>\n<li>$k$是$j$的一个子集，因为状态转移，选择的点只增不减。</li>\n<li>$j$是$expand(k)$的一个子集，$expand(k)$表示从$k$中已经选择的所有点往深度为$i$的点扩展，能够扩展到的所有点，则$j$必然在能够扩展到的点集内。</li>\n</ol>\n<p>我们再考虑如何计算扩展所需的花费$cost(j,k)$。</p>\n<p>先要找到所有被扩展的点，这个可以通过$j \\oplus k$计算出来。</p>\n<p>还要知道每个点被扩展所需的最小花费，由于每个$k$中的点深度都为$i-1$，所以到要扩展的点的经过的宝藏屋的数量是一样的，我们只用考虑路径长度就行了，而路径长度可以通过之前的$expand(k)$计算，即将所有能连向要扩展的点的路径长度取min。</p>\n<p>这样我们就完成了最重要的一步<strong>状态转移</strong>。</p>\n<p>之后就是初始化了，对于所有$x \\in [1,n]$，$f[1][(1&lt;&lt;x)] = 0$，因为是赞助商免费打通的，不需要费用，其他的都没有被转移，为了避免转移不合法的状态，其他的都设为$+ \\infty$。</p>\n<p>但是这样做，复杂度还不是最优的，因为$expand$和$cost$函数都会被重复计算很多次，我们可以预处理出来。</p>\n<p>时间复杂度：$O(n3^n+m2^n)$。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">25</span>,M = (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,edge[N][N],f[N][M],valid[M][M],cost[M][M],road[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">expand</span><span class=\"params\">(<span class=\"type\">int</span> i)</span></span>&#123; <span class=\"comment\">//复杂度为O(n^2) </span></span><br><span class=\"line\">\t<span class=\"type\">int</span> exp = i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;n;p++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!((<span class=\"number\">1</span>&lt;&lt;p)&amp;i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> q=<span class=\"number\">0</span>;q&lt;n;q++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (((<span class=\"number\">1</span>&lt;&lt;q)&amp;i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (edge[p][q]&lt;=<span class=\"number\">10000000</span>)&#123;</span><br><span class=\"line\">\t\t\t\troad[q] = <span class=\"built_in\">min</span>(road[q],edge[p][q]);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!((<span class=\"number\">1</span>&lt;&lt;q)&amp;exp)) exp+=(<span class=\"number\">1</span>&lt;&lt;q);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> exp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//这里枚举顺序换一下会有优化效果，但是我喜欢在里面算exp，所以就不改了 </span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123; <span class=\"comment\">//之前的集合</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(road,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(road));</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> exp = <span class=\"built_in\">expand</span>(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;n);j++)&#123; <span class=\"comment\">//转移的集合</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((i&amp;j) == i &amp;&amp; (exp&amp;j) == j)&#123; <span class=\"comment\">//合法</span></span><br><span class=\"line\">\t\t\t\tvalid[i][j] = <span class=\"number\">1</span>; </span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;n;p++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ((j&amp;(<span class=\"number\">1</span>&lt;&lt;p)) &amp;&amp; !(i&amp;(<span class=\"number\">1</span>&lt;&lt;p))) cost[i][j]+=road[p];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(edge,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(edge));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\tx--;</span><br><span class=\"line\">\t\ty--;</span><br><span class=\"line\">\t\tedge[x][y] = <span class=\"built_in\">min</span>(edge[x][y],z);</span><br><span class=\"line\">\t\tedge[y][x] = <span class=\"built_in\">min</span>(edge[y][x],z);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) f[<span class=\"number\">1</span>][<span class=\"number\">1</span>&lt;&lt;i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123; <span class=\"comment\">//枚举深度 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;n);j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;(<span class=\"number\">1</span>&lt;&lt;n);p++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (valid[j][p] &amp;&amp; f[i<span class=\"number\">-1</span>][j]&lt;=<span class=\"number\">100000000</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tf[i][p] = <span class=\"built_in\">min</span>(f[i][p],f[i<span class=\"number\">-1</span>][j]+(i<span class=\"number\">-1</span>)*cost[j][p]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> Min = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) Min = <span class=\"built_in\">min</span>(Min,f[i][(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\tcout&lt;&lt;Min&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","DP"]},{"title":"Pinely Round 1 D 题解","url":"/2022/11/21/Pinely-Round-1-D-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Pinely-Round-1-D-题解\"><a href=\"#Pinely-Round-1-D-题解\" class=\"headerlink\" title=\"Pinely Round 1 D 题解\"></a>Pinely Round 1 D 题解</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>组合数学一生之痛啊！</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>观察，发现每一位填什么和它前面的位关系不大，只和前面是否进位有关系。</p>\n<p>设 $c_i$ 表示是否进位，$c_{0} = 0$。</p>\n<span id=\"more\"></span>\n<p>分类讨论：</p>\n<ol>\n<li>$c_i = 0,c_{i-1} = 0$，$(0,0),(0,1),(1,0)$。</li>\n<li>$c_{i} = 0,c_{i-1} = 1$，$(0,0)$。</li>\n<li>$c_{i} = 1,c_{i-1} = 0$，$(1,1)$。</li>\n<li>$c_{i} = 1,c_{i-1} = 1$，$(0,1),(1,0),(1,1)$。</li>\n</ol>\n<p>发现，如果有 $p$ 个 $c_{i}\\neq c_{i-1}$，那么 $(a,b)$ 的数量就是 $3^{n-p}$ 个。</p>\n<p>我们现在要求的是有 $k$ 个进位的位置，即 $c$ 中有 $k$ 个 $0$。</p>\n<p>容易发现，含有 $p$ 个不同的位置的 $c$，会被分成 $0\\cdots1\\cdots0\\cdots$ 这样的 $p+1$ 段，其中全 $1$ 段占 $\\lfloor\\frac{p+1}{2}\\rfloor$ 段。</p>\n<p>考虑把 $1$ 放在一起考虑，我们就是要求 $k$ 个 $1$ 被分成 $\\lfloor\\frac{p+1}{2}\\rfloor$ 段的方案数 $\\times$ $n-k+1$ 个 $0$（注意 $c_0 = 0$，这是我们用来占位的，也要算进去）被分成 $p+1-\\lfloor\\frac{p+1}{2}\\rfloor$ 段的方案数。</p>\n<p>上面的东西可以预处理阶乘和 $3$ 的幂在 $O(1)$ 内计算，我们需要枚举所有 $p$ 的贡献，故总时间复杂度为 $O(n)$。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e6</span>+<span class=\"number\">10</span>,mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>,lim = <span class=\"number\">1e6</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k;</span><br><span class=\"line\">ll jie[N],inv[N],pw[N];</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">ksm</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tll ret = <span class=\"number\">1</span>,bas = x;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ret = ret*bas%mod;</span><br><span class=\"line\">\t\tbas = bas*bas%mod;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tjie[<span class=\"number\">0</span>] = pw[<span class=\"number\">0</span>] = inv[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) jie[i] = jie[i<span class=\"number\">-1</span>]*i%mod,pw[i] = pw[i<span class=\"number\">-1</span>]*<span class=\"number\">3</span>%mod;</span><br><span class=\"line\">\tinv[lim] = <span class=\"built_in\">ksm</span>(jie[lim],mod<span class=\"number\">-2</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=lim<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">1</span>;i--) inv[i] = inv[i+<span class=\"number\">1</span>]*(i+<span class=\"number\">1</span>)%mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">C</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&lt;y) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> jie[x]*inv[x-y]%mod*inv[y]%mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!k)&#123;</span><br><span class=\"line\">\t\tcout&lt;&lt;pw[n]&lt;&lt;endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = (i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>,y = i+<span class=\"number\">1</span>-x; <span class=\"comment\">//1和0的段的个数</span></span><br><span class=\"line\">\t\tans = (ans+pw[n-i]*<span class=\"built_in\">C</span>(k<span class=\"number\">-1</span>,x<span class=\"number\">-1</span>)%mod*<span class=\"built_in\">C</span>(n-k,y<span class=\"number\">-1</span>)%mod)%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","数学","组合数学"]},{"title":"Remove Directed Edges 题解","url":"/2022/05/26/Remove-Directed-Edges-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Remove-Directed-Edges-题解\"><a href=\"#Remove-Directed-Edges-题解\" class=\"headerlink\" title=\"Remove Directed Edges 题解\"></a>Remove Directed Edges 题解</h1><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先考虑删除一些边之后的情况，这时我们要求一个最大的点集，使其中任意两点之间都至少单向可达。</p>\n<p>这是一个常见的套路（虽然我并不知道），最大的点集即为最长的路径。</p>\n<span id=\"more\"></span>\n<p>证明：因为这是一个有向无环图，所以其中一条路径上的点必然互相可达，若有一个不再这个路径上的点也可达其他任意一个点，那么必然出现一条分支，因为没分叉之前的点都可达，所以它到没分叉之前的点的方向和另一条路径的方向相同，于是这两条路径必然无法到达。</p>\n<p>那么，如何求出这条链呢？</p>\n<p>由于这是一条有向无环图，那么必然有拓扑序，我们通过拓扑排序求出每个点的最大路径长度就行了。</p>\n<p>之后，我们考虑删除哪条边：对于一个包含在路径中的边，它必须要有至少两个入边和出边，这样才能保证选择它时不会出现断路。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">4e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,head[N],tot,indeg[N],odeg[N],degs[N],dis[N];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y);</span><br><span class=\"line\">\t\tindeg[y]++;</span><br><span class=\"line\">\t\todeg[x]++;</span><br><span class=\"line\">\t\tdegs[y]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tdis[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!degs[i]) q.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\tx = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (indeg[y]&gt;<span class=\"number\">1</span> &amp;&amp; odeg[x]&gt;<span class=\"number\">1</span>) dis[y] = <span class=\"built_in\">max</span>(dis[y],dis[x]+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\tdegs[y]--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!degs[y]) q.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans = <span class=\"built_in\">max</span>(ans,dis[i]);</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["图论","Editorial","拓扑排序"]},{"title":"P4662黑手党题解","url":"/2022/03/19/P4662%E9%BB%91%E6%89%8B%E5%85%9A%E9%A2%98%E8%A7%A3/","content":"<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给一个有 $n$ 个点和 $m$ 条边的图，现在给定一个源点 $a$ ，一个汇点 $b$ 和去掉每个点所需的费用，求出需要去掉哪些点，使 $a$ 和 $b$ 不再连通的费用最小。</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>我们发现，只要把点变成边，边权设为去掉这个点的费用，就变成了求一个网络的最小割，即最大流，于是考虑通过Dinic算法求出最大流。</p>\n<p>我们用拆点解决将点变成边的问题。首先，原来图中就有的边，是不允许去掉的，所以我们要保证它不会被割掉，将其边权设为正无穷。对于图中的点，我们可以把一个点拆成两个，一个称作入点，即有流量进入的点，一个称作出点，即流量流向别的地方的点，我们从入点向出点连边，边权设为费用，这样我们就将点转化为了边。而原来图中连的边，可以看作从一个点的出点连向另一个点的入点。</p>\n<p>之后，我们可以跑一遍Dinic求出最大流，这样我们就找到了最小割。<strong>需要注意的是，题目中说明源点 $a$ 和汇点 $b$ 也是可以去掉的，所以我们要从源点 $a$ 的入边到汇点 $b$ 的出边跑最大流，这样才能让源点 $a$ 和汇点 $b$ 都能被去掉</strong>。</p>\n<p>这一部分是比较常见的套路。</p>\n<p><strong>不太寻常的是题目中的输出，求的是构成最小割的一个方案。</strong></p>\n<p>我们再来思考最小割的意义：</p>\n<p>最小割，即去掉某些边后，网络的源点和汇点不再连通，且边权之和最小。</p>\n<p>显然，在求出最大流后的残量网络中，从源点一定无法到达汇点。</p>\n<p>也就是说，我们只要从源点 $a$ 开始走，走所能到达的点，一定会存在某一时刻走不动了，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/image-20220319170146094.png\" alt=\"\"></p>\n<p>此图中，从源点 $a$ 开始，一直走，直到走到了 $x$，发现后面再走 $y$ 和 $z$ 的边权都为 $0$ ，不能继续走了，就说明如果将 $y$ 和 $z$ 割掉，源点途径 $x$ 的路径就永远无法到达汇点，也就是说，所有满足这样，这条边指向的点（如 $x$ ）被访问，但是出发点（如 $y$ 和 $z$ ）没有被访问的点，都是需要被去除的点，这样才能构成一个割。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">6e2</span>+<span class=\"number\">10</span>,M = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,dis[N],now[N],in[N],out[N],vis[N];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; an;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[M*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">    edge[++tot].to = y;</span><br><span class=\"line\">    edge[tot].next = head[x];</span><br><span class=\"line\">    edge[tot].w = w;</span><br><span class=\"line\">    head[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(dis));</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">    dis[s] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    now[s] = head[s];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">            y = edge[i].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !dis[y])&#123;</span><br><span class=\"line\">                dis[y] = dis[x]+<span class=\"number\">1</span>;</span><br><span class=\"line\">                now[y] = head[y];</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> flow)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> flow;</span><br><span class=\"line\">    <span class=\"type\">int</span> v,res = flow,use;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=now[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">        v = edge[i].to;</span><br><span class=\"line\">        now[u] = i;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; dis[v] == dis[u]+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            use = <span class=\"built_in\">dfs</span>(v,<span class=\"built_in\">min</span>(edge[i].w,res));</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!use) dis[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            edge[i].w-=use;</span><br><span class=\"line\">            edge[i^<span class=\"number\">1</span>].w+=use;</span><br><span class=\"line\">            res-=use;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!res) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> flow-res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> v;</span><br><span class=\"line\">    vis[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">        v = edge[i].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !vis[v]) <span class=\"built_in\">dfs2</span>(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"comment\">//算出入点和出点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        in[i] = i*<span class=\"number\">2</span><span class=\"number\">-1</span>;</span><br><span class=\"line\">        out[i] = i*<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s = in[s];</span><br><span class=\"line\">    t = out[t];</span><br><span class=\"line\">    <span class=\"comment\">//读入与建图</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;x;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[i],out[i],x);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[i],in[i],<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[x],in[y],inf);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[y],out[x],<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(out[y],in[x],inf);</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(in[x],out[y],<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//Dinic求出最小割</span></span><br><span class=\"line\">    <span class=\"type\">int</span> flow,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (flow = <span class=\"built_in\">dfs</span>(s,inf)) ans+=flow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//求出一个方案使源点和汇点不连通</span></span><br><span class=\"line\">    <span class=\"built_in\">dfs2</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=tot;i+=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!vis[edge[i].to] &amp;&amp; vis[edge[i^<span class=\"number\">1</span>].to])&#123;</span><br><span class=\"line\">            an.<span class=\"built_in\">push_back</span>((edge[i^<span class=\"number\">1</span>].to+<span class=\"number\">1</span>)/<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(an.<span class=\"built_in\">begin</span>(),an.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> sz = an.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;sz;i++) cout&lt;&lt;an[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","网络流"]},{"title":"Round 810 D 题解","url":"/2022/07/25/Round-810-D-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Round-810-D-题解\"><a href=\"#Round-810-D-题解\" class=\"headerlink\" title=\"Round 810 D 题解\"></a>Round 810 D 题解</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>有 $n$ 处地方降雨，降雨的位置为 $x_i$，降雨量为 $p_i$，一个地方 $j$ 的降雨量为 $\\sum_{i=1}^np_i-|x_i-j|$，如果最大的降雨量大于等于 $m$，则说有洪水。现在对每一个 $i$，去掉第 $i$ 场雨，问你是否会发生洪水。</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先考虑最简单的情况：求一个点的降雨量。</p>\n<p>把对降雨量产生贡献的线段找出来，分为左右两边，则降雨量等于 $p_l+x_l-k_l\\cdot j+p_r-x_r+k_r\\cdot j$。</p>\n<p>我们考虑将一次降雨（一条线段代表其产生贡献的区间）分成左右两个端点加上中点这三个点。</p>\n<p>把贡献分成左右两块来算。</p>\n<p>先从左往右扫一遍，则每次扫到中点，都会产生贡献，扫到终点，就减掉贡献，维护一下 $p_l,x_l,k_l$。</p>\n<p>然后从右往左扫一遍，同理维护 $p_r,x_r,k_r$。</p>\n<p>这样可以求出关键点的降雨量。</p>\n<p>如何计算消去一个线段之后的最大降雨量呢？</p>\n<p>显然，在起点到中点的关键点都减去了右边一块的贡献，在中点到终点的关键点都减去了左边一块的贡献，这可以用线段树来维护。</p>\n<p>$p,l$ 的改变是个定值，但是 $j$ 的改变却不是个定值，怎么办？</p>\n<p>很简单，虽然 $j$ 的改变看上去不是个定值，但是对于同一个位置 $j$ 来说，不管谁不再产生贡献，它都会减去一个定值 $j$，所以我们可以再维护一个全部都减去 $j$ 的修改之后的值，每次取其中一段的最大值即可。</p>\n<p>另一边的计算同理。</p>\n<p>现在已经 0:48 了，懒得实现了，起床之后再搞吧。</p>\n<p><del>竟然搞了1.5h才搞出来，太太太菜了锕！</del></p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">6e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,m,tot,b[N],cnt,v[N],glp[N],glx[N],Maxl[N],Maxr[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">lin</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p,x,ty,orix;</span><br><span class=\"line\">&#125; l[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tre</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,Max;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">SegT</span>&#123;</span><br><span class=\"line\">\ttre tr[N*<span class=\"number\">4</span>];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">\t\ttr[node].Max = <span class=\"built_in\">max</span>(tr[node&lt;&lt;<span class=\"number\">1</span>].Max,tr[node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>].Max);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> flag)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">\t\t\ttr[node].l = tr[node].r = l;</span><br><span class=\"line\">\t\t\ttr[node].Max = v[l]+flag*b[l];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>,lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">build</span>(lc,l,mid,flag);</span><br><span class=\"line\">\t\t<span class=\"built_in\">build</span>(rc,mid+<span class=\"number\">1</span>,r,flag);</span><br><span class=\"line\">\t\ttr[node].l = tr[lc].l;</span><br><span class=\"line\">\t\ttr[node].r = tr[rc].r;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushup</span>(node);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span> <span class=\"number\">-0x3f3f3f3f</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r) <span class=\"keyword\">return</span> tr[node].Max;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(<span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>,l,r),<span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,l,r));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t1,t2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp1</span><span class=\"params\">(lin a,lin b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a.x&lt;b.x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcnt = tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;y&gt;&gt;x;</span><br><span class=\"line\">\t\t\tglp[i] = x;</span><br><span class=\"line\">\t\t\tglx[i] = y;</span><br><span class=\"line\">\t\t\tl[++tot].p = x;</span><br><span class=\"line\">\t\t\tl[tot].ty = <span class=\"number\">-1</span>; <span class=\"comment\">//左端点</span></span><br><span class=\"line\">\t\t\tl[tot].x = y-x;</span><br><span class=\"line\">\t\t\tl[tot].orix = y;</span><br><span class=\"line\">\t\t\tl[++tot].p = x;</span><br><span class=\"line\">\t\t\tl[tot].ty = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tl[tot].x = y; <span class=\"comment\">//中点 </span></span><br><span class=\"line\">\t\t\tl[tot].orix = y;</span><br><span class=\"line\">\t\t\tl[++tot].p = x;</span><br><span class=\"line\">\t\t\tl[tot].ty = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tl[tot].x = y+x; <span class=\"comment\">//右端点</span></span><br><span class=\"line\">\t\t\tl[tot].orix = y;</span><br><span class=\"line\">\t\t\tb[++cnt] = y-x;</span><br><span class=\"line\">\t\t\tv[cnt] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tb[++cnt] = y;</span><br><span class=\"line\">\t\t\tv[cnt] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tb[++cnt] = y+x;</span><br><span class=\"line\">\t\t\tv[cnt] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(b+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>+cnt);</span><br><span class=\"line\">\t\tcnt = <span class=\"built_in\">unique</span>(b+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>+cnt)-b<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(l+<span class=\"number\">1</span>,l+<span class=\"number\">1</span>+tot,cmp1);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pl = <span class=\"number\">0</span>,xl = <span class=\"number\">0</span>,cntl = <span class=\"number\">0</span>,now = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (l[now].x&lt;=b[i] &amp;&amp; now&lt;=tot)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (l[now].ty == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tpl+=l[now].p;</span><br><span class=\"line\">\t\t\t\t\txl+=l[now].orix;</span><br><span class=\"line\">\t\t\t\t\tcntl++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l[now].ty == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tpl-=l[now].p;</span><br><span class=\"line\">\t\t\t\t\txl-=l[now].orix;</span><br><span class=\"line\">\t\t\t\t\tcntl--;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tnow++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tv[i]+=pl+xl-cntl*b[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnow = tot;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pr = <span class=\"number\">0</span>,xr = <span class=\"number\">0</span>,cntr = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=cnt;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (l[now].x&gt;=b[i] &amp;&amp; now&gt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (l[now].ty == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tpr+=l[now].p;</span><br><span class=\"line\">\t\t\t\t\txr+=l[now].orix;</span><br><span class=\"line\">\t\t\t\t\tcntr++;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l[now].ty == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tpr-=l[now].p;</span><br><span class=\"line\">\t\t\t\t\txr-=l[now].orix;</span><br><span class=\"line\">\t\t\t\t\tcntr--;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tnow--;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tv[i]+=pr-xr+cntr*b[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) v[<span class=\"built_in\">lower_bound</span>(b+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>+cnt,glx[i])-b]-=glp[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++) Maxl[i] = <span class=\"built_in\">max</span>(Maxl[i<span class=\"number\">-1</span>],v[i]);</span><br><span class=\"line\">\t\tMaxr[cnt+<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=cnt;i&gt;=<span class=\"number\">1</span>;i--) Maxr[i] = <span class=\"built_in\">max</span>(Maxr[i+<span class=\"number\">1</span>],v[i]);</span><br><span class=\"line\">\t\tt1.<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,cnt,<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\tt2.<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,cnt,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> l = <span class=\"built_in\">lower_bound</span>(b+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>+cnt,glx[i]-glp[i])-b,mid = <span class=\"built_in\">lower_bound</span>(b+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>+cnt,glx[i])-b,r = <span class=\"built_in\">lower_bound</span>(b+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>+cnt,glx[i]+glp[i])-b;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> ans = <span class=\"built_in\">max</span>(Maxl[l<span class=\"number\">-1</span>],Maxr[r+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t\tans = <span class=\"built_in\">max</span>(ans,<span class=\"built_in\">max</span>(t1.<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,l,mid)-glp[i]+glx[i],t2.<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r)-glp[i]-glx[i]));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (ans&lt;=m) cout&lt;&lt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","线段树"]},{"title":"Surveillance 题解","url":"/2022/07/15/Surveillance-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"Surveillance-题解\"><a href=\"#Surveillance-题解\" class=\"headerlink\" title=\"Surveillance 题解\"></a>Surveillance 题解</h1><p>$\\color{lightgreen}Status: OK$</p>\n<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给你一个环和若干条覆盖环的线段，求覆盖整个环所需的最小的线段数量。<br><span id=\"more\"></span></p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>看到环，就要化环为链，先复制一份在后面，之后再把线段存进去。</p>\n<p>于是，问题变成了，在长度为 $2n$ 的链上，选出一些线段，使其能覆盖大于等于 $n$ 的链。</p>\n<p>这个问题是可以贪心的。假设现在在位置 $i$，那么要选的线段一定是覆盖位置 $i$，且右端点最大的线段，这样才能最优。</p>\n<p>这个东西可以用一个 set 或优先队列维护。</p>\n<p>但是，直接枚举起点，再这样搞，时间复杂度可能达到 $O(n^2\\log n)$，无法通过。</p>\n<p>我们可以对每一个位置，把它能跳到的最远的位置算出来，时间复杂度为 $O(n\\log n)$。</p>\n<p>之后利用倍增的思想，把每个位置跳 $2^i$ 次到达的位置算出来，这样枚举起点之后，每个起点的求解就是 $O(n\\log n)$ 了。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,st[N][<span class=\"number\">21</span>],ans;</span><br><span class=\"line\">set&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">lin</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r;</span><br><span class=\"line\">&#125; l[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(lin x,lin y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x.l&lt;y.l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">20</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n*<span class=\"number\">2</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (st[j][i<span class=\"number\">-1</span>]) st[j][i] = st[st[j][i<span class=\"number\">-1</span>]+<span class=\"number\">1</span>][i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">1</span>,tmp = x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">20</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (st[x][i]&gt;=x &amp;&amp; st[x][i]&lt;tmp+n<span class=\"number\">-1</span>) x = st[x][i]+<span class=\"number\">1</span>,cnt+=(<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (st[x][<span class=\"number\">0</span>]&gt;=tmp+n<span class=\"number\">-1</span>) ans = <span class=\"built_in\">min</span>(ans,cnt);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cin&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t\tans = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">\t\ts.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x&gt;y) y+=n;</span><br><span class=\"line\">\t\t\tl[i].l = x;</span><br><span class=\"line\">\t\t\tl[i].r = y;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(l+<span class=\"number\">1</span>,l+<span class=\"number\">1</span>+k,cmp);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n*<span class=\"number\">2</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (l[now].l == i &amp;&amp; now&lt;=k)&#123;</span><br><span class=\"line\">\t\t\t\ts.<span class=\"built_in\">insert</span>(l[now].r);</span><br><span class=\"line\">\t\t\t\tnow++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tst[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!s.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">auto</span> it = s.<span class=\"built_in\">end</span>();</span><br><span class=\"line\">\t\t\t\tit--;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (*it&gt;=i) st[i][<span class=\"number\">0</span>] = *it;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"built_in\">chk</span>(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans == <span class=\"number\">0x3f3f3f3f</span>) cout&lt;&lt;<span class=\"string\">&quot;impossible&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">2</span>*n;i++) <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=<span class=\"number\">20</span>;j++) st[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","ST表"]},{"title":"Useless Thoughts(遐想)","url":"/2021/08/02/Useless-Thoughts-%E9%81%90%E6%83%B3/","content":"<p><strong>War, war never changes.</strong></p>\n<p><strong>But peace, peace changes everything.</strong></p>\n<p>犹记得曾经带领举国10个远古军团在《文明Ⅵ》中鲁莽地向自己的友邦瑞士开战，在军队突破阿拉伯的援兵，围在没有任何防御的日内瓦城的所有边界方格上，取得第一次压倒性胜利时的喜悦与狂热，对占领的渴望充斥着我的大脑。  </p>\n<span id=\"more\"></span>\n<p>也记得被阿拉伯疯狂传教、在边境造城挑衅后愤然发起突袭战争，率领接近20个单位的远征大军朝着开罗进发时的意气风发；但谁能想到几回合后我就被困在防御工事内进退不得，只得在阿拉伯的现代化大军到来前从海上逃跑，而又是什么导致了这场战争呢？是对复仇的渴望。</p>\n<p>最近了解了伊拉克战争和阿富汗战争，对此更是深有同感。9.11事件成为了阿富汗战争的导火索，控制石油资源的诱惑则导致了伊拉克战争，反观历史上的重大战争，又有哪个不是基于利益和复仇的呢？</p>\n<p>但在战争的进程中，有一方的力量却被忽视了——士兵。在游戏中，他们被化为单调的数值；在国家之间的战争中，他们被作为实力较量的筹码；在军官心中，他们被作为任人摆布的棋子。哪位国家元首曾将他们与经济损失、基础建设修复、物资补给一起计算战争的代价？P社玩家之所以成为”大恶人”，还不是因为他们无视面板上增加的死亡人数，狂热的发动战争，丝毫没想过那些数字对于他们的家人，挚友意味着什么！战争永远不会是美好的，不会是地图上几条线共同导向的结果，更不会是按动鼠标上的左右键就能完全体会的，其中酿成了多少人间悲剧，造就了多少绝望的结局，我们又如何得知！</p>\n<p>但仔细思考一下，各种冲突才是导致战争的最大缘由：边境冲突，宗教冲突，政党冲突（省略）它们也许是人类永远无法避免的命运。但就像线段树一样，作为叶子节点的我们，如果更加平和、宽容待人，能从生活中一个完美的光影，一个样貌奇特的绿树，一个陌生人的有趣谈话中发现美好，不过于厌世，也不盲目服从，那样也许经过多次pushup操作，上层的祖先们就会更加和睦，做出宝贵的和平决定吧。</p>\n<p>（吹爆COD现代战争三部曲）</p>\n","tags":["Life"]},{"title":"WHK目录","url":"/2022/02/11/WHK%E7%9B%AE%E5%BD%95/","content":"<h1 id=\"目录：\"><a href=\"#目录：\" class=\"headerlink\" title=\"目录：\"></a>目录：</h1><span id=\"more\"></span>\n<h2 id=\"化学\"><a href=\"#化学\" class=\"headerlink\" title=\"化学\"></a>化学</h2><h3 id=\"必修1\"><a href=\"#必修1\" class=\"headerlink\" title=\"必修1\"></a>必修1</h3><h4 id=\"第一单元\"><a href=\"#第一单元\" class=\"headerlink\" title=\"第一单元\"></a>第一单元</h4><h5 id=\"Part-1：物质的分类\"><a href=\"#Part-1：物质的分类\" class=\"headerlink\" title=\"Part 1：物质的分类\"></a>Part 1：<a href=\"https://bowenone580.github.io/2022/02/11/物质的分类/\">物质的分类</a></h5>","tags":["Knowledge","WHK","Menu"]},{"title":"YY的GCD 题解","url":"/2022/05/26/YY%E7%9A%84GCD-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"YY的GCD-题解\"><a href=\"#YY的GCD-题解\" class=\"headerlink\" title=\"YY的GCD 题解\"></a>YY的GCD 题解</h1><p>$gcd(x,y) = k(k \\in prime)$</p>\n<p>$gcd(x/k,y/k) = 1$</p>\n<p>正如某位大佬所说，此时应该直接上反演结论：</p>\n<p>$\\sum_{i=1}^n\\sum_{j=1}^mgcd(\\frac{i}{k},\\frac{j}{k}) = 1 \\iff \\sum_{i=1}^{\\frac{n}{k}}\\sum_{j=1}^{\\frac{m}{k}}\\sum_{d|gcd(i,j)}\\mu(d)$。</p>\n<p>发现，这个式子实际上就是求对于固定的$d$，所有为$d$的倍数的对数之和，于是可以把$d$挪出来：</p>\n<p>$\\sum_{d=1}^{min(n/k,m/k)}\\mu(d)\\lfloor n/dk\\rfloor \\lfloor m/dk\\rfloor$。</p>\n<span id=\"more\"></span>\n<p>这样，我们就得到了对于单个质数$k$的对数之和。但是，这样做的复杂度约为$O(n\\sqrt n)$，无法通过。</p>\n<p>利用题解区说的套路，设$t=dk$，则：</p>\n<p>$\\sum_{k \\in prime} \\sum_{d=1}^{min(n/k,m/k)}\\mu(t/k)\\lfloor n/t\\rfloor \\lfloor m/t \\rfloor \\iff \\sum_{t=1}^{min(n,m)} \\sum_{k \\in prime, k|t}\\mu(t/k)\\lfloor n/t\\rfloor \\lfloor m/t\\rfloor \\iff \\sum_{t=1}^{min(n,m)}\\lfloor n/t \\rfloor \\lfloor m/t \\rfloor \\sum_{k \\in prime, k|t}\\mu(t/k)$</p>\n<p>这个$\\sum_{k\\in prime, k|t}\\mu(t/k)$是可以预处理出来的，我们可以像埃氏筛一样把$k$的倍数都加一下。</p>\n<p>预处理的复杂度接近$O(n)$，每次询问，我们只用把前面的用数论分块算出来，乘上后面的和就行了，时间复杂度为$O(\\sqrt n)$。</p>\n<p>总时间复杂度为$O(n+T\\sqrt n)$。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e7</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,m,vis[N],pri[N],tot,mu[N];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> sum[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lim = <span class=\"number\">1e7</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j*pri[i]&lt;=lim;j++)&#123;</span><br><span class=\"line\">\t\t\tsum[j*pri[i]]+=mu[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) sum[i]+=sum[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r,Min = <span class=\"built_in\">min</span>(n,m);</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>;l&lt;=Min;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tr = <span class=\"built_in\">min</span>(n/(n/l),m/(m/l));</span><br><span class=\"line\">\t\t\tans+=(sum[r]-sum[l<span class=\"number\">-1</span>])*(n/l)*(m/l);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","数论","莫比乌斯反演"]},{"title":"ZAP-Queries 题解","url":"/2022/05/26/ZAP-Queries-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"ZAP-Queries-题解\"><a href=\"#ZAP-Queries-题解\" class=\"headerlink\" title=\"ZAP-Queries 题解\"></a>ZAP-Queries 题解</h1><p>求$gcd(i,j) = d$的数对的数量。</p>\n<p>这个式子需要化简，我们将其变为$gcd(i/d,j/d) = 1$。</p>\n<p>固定$j/d$，变成求和它互质的数的个数，可以直接用欧拉函数解决。</p>\n<p>但是，这样做的时间复杂度为每组数据$O(n)$，据说数据组数的级别也是$O(n)$的，所以总复杂度为$O(n^2)$，会超时，需要更优的算法。</p>\n<span id=\"more\"></span>\n<p>如果用莫比乌斯反演，那就必须先搞出两个函数来：</p>\n<p>第一个函数显然是我们的答案函数：$f(k) = \\sum_{i=1}^a\\sum_{j=1}^b[gcd(i,j) = k]$。</p>\n<p>第二个函数要和它有关系，我们不妨设$g(x) = \\sum_{x|k}f(k)$。</p>\n<p>直接上反演：$f(x) = \\sum_{x|k}\\mu(\\frac{k}{x})g(k)$。</p>\n<p>考虑$g(x)$求的到底是啥，发现是所有$gcd$是$x$的倍数的数的个数之和，这个东西显然只要两个数都是$x$的倍数就行了，于是可以转化为$g(x) = \\lfloor a/x\\rfloor \\lfloor b/x\\rfloor$。</p>\n<p>所以，最后的$f(d) = \\sum_{d|k}\\mu(\\frac{k}{d})\\lfloor a/k\\rfloor \\lfloor b/k\\rfloor$。</p>\n<p>但是，即使化成这样，也不好计算它的值，这个$\\mu$每次算一遍很浪费，而且它都是从$[1,x]$内的所有整数（$x$是一个不确定的上界），不难想到预处理出前缀和，方便计算。</p>\n<p>但是，后面还跟着两个东西，它们也不好分离开，而且$k$是不确定的，所以我们先做一个替换：$t = \\frac{k}{d}$，于是式子变为$f(d) = \\sum_{i=1}^x\\mu(i)\\lfloor \\frac{a}{td} \\rfloor \\lfloor \\frac{b}{td} \\rfloor$，把$d$提出来，变成$\\sum_{i=1}^x\\mu(i)\\frac{\\lfloor \\frac{a}{t} \\rfloor}{d}\\frac{\\lfloor \\frac{b}{t} \\rfloor}{d}$。</p>\n<p>发现后面的一块很像数论分块，于是想到用数论分块的思想优化复杂度，把后面的那一段相同的都找出来，捆绑计算，$\\mu$的值可以通过预处理前缀和实现$O(1)$计算，所以计算一次的时间复杂度为$O(\\sqrt{n})$。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,a,b,d,vis[N],pri[N],tot,mu[N],sum[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lim = <span class=\"number\">5e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) sum[i] = sum[i<span class=\"number\">-1</span>]+mu[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;d;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>;l&lt;=<span class=\"built_in\">min</span>(a/d,b/d);l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tr = <span class=\"built_in\">min</span>(a/(a/l),b/(b/l));</span><br><span class=\"line\">\t\t\tans+=<span class=\"number\">1ll</span>*(sum[r]-sum[l<span class=\"number\">-1</span>])*(a/(d*l))*(b/(d*l));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","tags":["Editorial","数论","莫比乌斯反演"]},{"title":"二分图入门","url":"/2022/11/22/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%85%A5%E9%97%A8/","content":"<h1 id=\"二分图入门\"><a href=\"#二分图入门\" class=\"headerlink\" title=\"二分图入门\"></a>二分图入门</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>二分图和网络流是图论中非常重要的部分，很多问题都可以通过建模转化到这上面解决。二分图和网络流的关系是密不可分的，可以将二分图看成特殊构造的网络，故其也可用网络流的算法求解。</p>\n<span id=\"more\"></span>\n<h2 id=\"二分图\"><a href=\"#二分图\" class=\"headerlink\" title=\"二分图\"></a>二分图</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>一张图，其中节点能被分成两部分，满足：</p>\n<ol>\n<li>在每部分<strong>内部</strong>，节点之间互相<strong>没有边相连</strong>。</li>\n<li>每个节点属于且仅属于一个部分。</li>\n</ol>\n<p>则称这张图为二分图。</p>\n<p>为了直观表示，一般将这两部分称为左部和右部，其中的点称为左部点和右部点。</p>\n<h3 id=\"判定\"><a href=\"#判定\" class=\"headerlink\" title=\"判定\"></a>判定</h3><p>一张图是二分图，当且仅当其中不存在奇环（即长度为奇数的环）。</p>\n<p>先证明必要性：</p>\n<p>假设这张图是二分图，并且图中存在奇环，考虑从起点开始走的过程。</p>\n<p>显然，由于二分图，每一部分内部必然没有边，于是每走一步，必然到达另一部分。</p>\n<p>我们可以进一步推出：走奇数步必然到达另一部分，走偶数步回到这一部分，与假设矛盾。</p>\n<p>之后证明充分性：</p>\n<p>假设图中全都是偶环，考虑构造二分图。</p>\n<p>使用深度优先搜索对图染色，如果找到未访问的点，就把它染上和当前点不同的颜色，如果找到访问过的点，跳过，最终一定可以构造出二分图。</p>\n<p>为什么呢？显然我们已经把图分成了两部分，那么只要证明每一部分内不会有边即可。</p>\n<p>假设有这样的边，则它连接的两个点应该是同色的，则可以断定这两个点一定处于一个环内（如果不是环，就直接染成不同色了啊），而且，这两个点被染成相同的颜色，则它们之间的路径长度一定为偶数（根据我们染色的规则），加上这个边，说明存在奇环，显然不可能是二分图。</p>\n<p>模板题：<a href=\"https://www.luogu.com.cn/problem/SP3377\">BUGLIFE - A Bug’s Life</a></p>\n<p>毒瘤 dp 题：<a href=\"https://www.luogu.com.cn/problem/UVA1627\">团队分组 Team them up!</a>（细节挺多的）</p>\n<h3 id=\"匹配\"><a href=\"#匹配\" class=\"headerlink\" title=\"匹配\"></a>匹配</h3><p>二分图最重要的就是求最大匹配，没学过的可能不是很懂：什么是最大匹配？</p>\n<p>形象一点说，把左边的点看成男的，右边的点看成女的，边看成结婚，最大匹配相当于求最多有多少对夫妇，根据生活常识，显然一个左边的点只能匹配一个右边的点，反之亦然。</p>\n<p>学术一点的定义，就是选择一些边，满足任意两边没有公共端点，显然和上面的是等价的。</p>\n<p>常用的是匈牙利算法。</p>\n<p>匈牙利算法依次尝试给每个左部点寻找匹配（找右部点也一样），假设现在遍历到点 $i$。</p>\n<p>枚举 $i$ 的所有出边，如果有没有匹配的点，那么就选它了，反正一个点最多增加一个匹配，选了不亏。</p>\n<p>麻烦的是，有些点比较倒霉，所有出边到的点都有了匹配，我们怎么办？</p>\n<p>假设右部点 $j$ 已经有了匹配，那么我们只要让 $j$ 匹配的左部点找到另一个匹配，右部点不就空出来了，于是可以增加一组匹配。</p>\n<p>容易发现，左部点寻找匹配的过程和 $i$ 寻找匹配的过程一模一样，所以可以递归处理。</p>\n<p>如果找不到匹配，那么 $i$ 强行匹配，就不如不匹配了，因为对答案的贡献都是 $0$。</p>\n<p>放模板：<a href=\"https://www.luogu.com.cn/problem/P3386\">P3386 【模板】二分图最大匹配</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e2</span>+<span class=\"number\">10</span>,M = <span class=\"number\">5e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,k,head[N],tot,tim,vis[N],mat[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[M];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (vis[v]!=tim)&#123;</span><br><span class=\"line\">\t\t\tvis[v] = tim;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!mat[v] || <span class=\"built_in\">dfs</span>(mat[v]))&#123;</span><br><span class=\"line\">\t\t\t\tmat[v] = u;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\ttim++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">dfs</span>(i)) ans++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里说一下 $vis$ 数组的作用，如果一个点被 $vis$ 过，说明有人想要这个点，那么肯定不用考虑自己和这个点匹配的情况了，这能够带来一些时间上优化（虽然效果并不明显）。</p>\n<p>需要注意的是，匈牙利算法的<strong>理论时间复杂度</strong>为 $O(nm)$，这里的 $m$ 是整张图的边数，而 $n$ 则<strong>十分重要</strong>，它是左部点<strong>或</strong>右部点的点数，这意味着，当某一边的点<strong>极少</strong>时，枚举这一边的点可以带来<strong>极大的优化</strong>。</p>\n<p>还要说明，匈牙利算法的<strong>理论时间复杂度</strong>很差，但是<strong>实际表现</strong>甚至能达到 $O(n)$ 级别，这主要取决于图的形态，所以在图很随机时，可以试一下匈牙利算法，可能会有奇效（不然只能用网络流算最大匹配了）。</p>\n<h3 id=\"一些概念\"><a href=\"#一些概念\" class=\"headerlink\" title=\"一些概念\"></a>一些概念</h3><p>完备匹配：左右部节点数相同，都为 $n$ 个，并且最大匹配包含 $n$ 条匹配边，则称这个二分图具有完备匹配。</p>\n<p>多重匹配：左右部的每一个节点可以连 $k_i$ 条边，问你最大匹配的边数。</p>\n<p>解法有以下几种：</p>\n<ol>\n<li>拆点，一个点连 $k_i$ 条边等价于 $k_i$ 个点进行二分图最大匹配，最后连边的时候在两个节点拆出来的所有节点中连。</li>\n<li>当只有左边或右边是多重匹配的时候，把那一边 dfs $k_i$ 次，其实本质上和第一种是类似的，只不过不用连边啥的。</li>\n<li>网络流求解。</li>\n</ol>\n<h3 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h3><p><a href=\"https://www.acwing.com/problem/content/description/374/\">372. 棋盘覆盖</a></p>\n<p>做法很简单，也很好理解，但是这是一种思路，也是第一道需要建立模型的题，所以还是建议自己先想一想。</p>\n<p>一般来说，建立二分图的模型，需要找到两个部分，满足各部分内部的点不能都选。</p>\n<p>这里，可以发现，如果按 $i+j$ 奇偶染色，正好能够符合，于是就做完了。</p>\n<p><img src=\"https://s2.loli.net/2022/11/18/tiVPU7f2XoYp1R9.png\" alt=\"image-20221118183333165\"></p>\n<p>练习：</p>\n<p><a href=\"https://www.acwing.com/problem/content/375/\">373. 車的放置</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P1640\">P1640 [SCOI2010] 连续攻击游戏</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/CF1139E\">Maximize Mex</a></p>\n<h3 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h3><p><a href=\"https://www.acwing.com/problem/content/376/\">374. 导弹防御塔</a></p>\n<p>看到这种可行性问题，就要想到二分。</p>\n<p>显然，如果当前时间可行，那么之后的所有时间都可行，于是，问题变成了时间 $mid$ 时，能否击退所有侵略者。</p>\n<p>发现，每个导弹只能打击一个侵略者，每个侵略者只能吃一个导弹（不然太浪费了啊），所以可以以导弹为左部点，侵略者为右部点，进行二分图匹配。</p>\n<p>具体的，就是枚举每一发导弹，看能打到哪些侵略者，能打到就连边。</p>\n<p>可能需要注意常数优化？</p>\n<h2 id=\"二分图进阶\"><a href=\"#二分图进阶\" class=\"headerlink\" title=\"二分图进阶\"></a>二分图进阶</h2><h3 id=\"最小点覆盖\"><a href=\"#最小点覆盖\" class=\"headerlink\" title=\"最小点覆盖\"></a>最小点覆盖</h3><p>求出一个最小的点集 $S$，使图中每条边都至少有一个点属于 $S$。</p>\n<p>König 定理：最小点覆盖包含的点数等于最大匹配包含的边数。</p>\n<p>转化模型一般看题目中是否有两个东西二选一，求选法之类的东西。</p>\n<h4 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h4><p>由于最大匹配中，任意两条边的两个端点都不一样，所以要使图中的每条边至少有一个点属于它，首先得让匹配边都满足这个条件，于是每条匹配边对最小点覆盖的贡献至少为 $1$，我们证明了答案的下界是最大匹配的边数。</p>\n<p>考虑构造出一个方案：</p>\n<p>假设原来我们从左部点出发，找右部点匹配，那么现在从左边的没有被匹配的点出发，再次进行增广过程，每次遍历所有出边，将这个出边到达的点做标记。显然，到达的点一定是右部点，并且有左部点和它匹配（否则可以继续增广），我们就访问和它匹配的左部点，继续标记，这个左部点再重复这一过程即可。</p>\n<p>最后，我们取左边未被标记的点，右边被标记的点，这个点集即为最小点覆盖。</p>\n<p>又因为，左边没有被标记的点，说明它是匹配点（不然要从它出发遍历，肯定标记了），必然有一个右部点和它匹配，而我们又没有取右边的点，所以这条匹配边中，只取了一个点；对于右边被标记的点，它必然有匹配边（否则我们可以让标记它的点和它匹配，构成新的增广路），而它必然访问和它匹配的左部点，也就是说，这条匹配边中，我们也只选择了一个点，所以答案就是最大匹配的边数。</p>\n<p>再来证明这样就覆盖了所有的非匹配边。</p>\n<ol>\n<li><p><del>非匹配边的左边是匹配点，右边也是匹配点。</del>你都说匹配点了，那肯定是匹配边啊！</p>\n</li>\n<li><p><del>非匹配边的左边是非匹配点，右边也是非匹配点。</del>你为啥不让它们俩匹配呢？</p>\n</li>\n<li><p>非匹配边的左边是非匹配点，右边是匹配点。</p>\n<p>既然左边是非匹配点，那么在标记的过程中必然会从它开始遍历，肯定会访问右边的匹配点，就标记了，于是这条边有一个端点在点集中，OK。</p>\n</li>\n<li><p>非匹配边的左边是匹配点，右边是非匹配点。</p>\n<p>考虑这个匹配点匹配的右边的匹配点的标记情况，如果被标记，则这个点也被标记，那么它一定会访问到非匹配点，这时左边的一个非匹配点就找到了匹配，产生增广路，不合法。</p>\n<p>所以这个点必然没有被标记，我们选的就是左边没有被标记的点，OK。</p>\n</li>\n</ol>\n<h3 id=\"最大独立集-最大团\"><a href=\"#最大独立集-最大团\" class=\"headerlink\" title=\"最大独立集 最大团\"></a>最大独立集 最大团</h3><p>最大独立集：一个点集，其中所有的点之间都没有边相连，构成的集合。</p>\n<p>最大团：一个点集，其中所有点之间都有边相连，构成的集合。</p>\n<p>容易发现，这两个概念完全相反，于是我们如果求出了最大独立集，就可以建反图，于是原来的最大独立集就成了最大团。</p>\n<p>$|最大独立集| = n-最大匹配$</p>\n<p>因为最大匹配的大小和最小点覆盖的大小一样，而这些点正好覆盖了所有的边，那么其他的点中没有两个点是有同一条边相连的，所以剩下的点恰好构成最大独立集。</p>\n<p>最大团可以建反图求解最大独立集。</p>\n<p><strong>值得注意的是，一般图中的最大团、最大独立集问题是 NPC 问题，你可以理解为只能写暴力，如果转化到了这类问题上，说明你一定漏掉了题目中的性质或信息</strong>。</p>\n<h3 id=\"最小路径点覆盖\"><a href=\"#最小路径点覆盖\" class=\"headerlink\" title=\"最小路径点覆盖\"></a>最小路径点覆盖</h3><p>最小路径点覆盖 = 最小的+用不相交的路径+把所有点覆盖 的路径数量。</p>\n<p>我们对原图中的每一个点 $i$，都建立一个新点 $i+n$，对于原图中的每一条边 $(x,y)$，都从 $x$ 向 $y+n$ 连边，则称这个新图为原图的拆点二分图。</p>\n<p>可以告诉你，$|最小路径点覆盖| = n-|拆点二分图最大匹配|$。</p>\n<h4 id=\"证明-1\"><a href=\"#证明-1\" class=\"headerlink\" title=\"证明\"></a>证明</h4><p>原图中，被路径经过的点，由于路径不交，只会被经过一次，所以入度和出度为 $1$，对于路径的结尾，它是没有出度的，对于路径的开头，它是没有入度的。</p>\n<p>考虑拆点二分图中的匹配，显然一个有出度的点，必然匹配它到达的点，而那些没有出度的，就不会匹配任何点，于是路径数等于非匹配点的数量。</p>\n<p>我们要使路径数最小，则非匹配点的数量最小，于是就是求最大匹配。</p>\n<h3 id=\"最小路径重复点覆盖\"><a href=\"#最小路径重复点覆盖\" class=\"headerlink\" title=\"最小路径重复点覆盖\"></a>最小路径重复点覆盖</h3><p>就是在上面的限制下可以相交。</p>\n<p>我们来看看两个路径相交的情况：</p>\n<p>假设一个路径是 $x\\rightarrow y\\rightarrow z$，另一个路径是 $p\\rightarrow y\\rightarrow q$，则我们可以连接 $p\\rightarrow q$，这样就不会相交了，并且路径也是两条。我们对于所有能连通的点对，都连一条边，最后就是求最小路径覆盖了，不重复也不会影响答案。</p>\n<p>你有可能说，如果这两个路径只有一个点不同，那怎么办？</p>\n<p>假设这两个路径表示为 $x\\rightarrow y$，$x\\rightarrow z$，那么，我们其实可以直接走 $x\\rightarrow y$ 和 $z$。</p>\n<p>于是，对原图求传递闭包，之后在新图中求最小路径覆盖即可。</p>\n<h3 id=\"例1-1\"><a href=\"#例1-1\" class=\"headerlink\" title=\"例1\"></a>例1</h3><p><a href=\"https://www.luogu.com.cn/problem/UVA1194\">Machine Schedule</a></p>\n<p>难点在于模型的构建。</p>\n<p>观察题目，容易发现，每个任务必须通过两个机器之一解决，也就是说，把任务看成边，则我们要求的就是最小点覆盖。</p>\n<p>$A,B$ 的 $n,m$ 种模式分别当左右部点，做一次二分图最大匹配即可。</p>\n<p>练习：<a href=\"https://www.acwing.com/problem/content/379/\">377. 泥泞的区域</a></p>\n<h3 id=\"例2-1\"><a href=\"#例2-1\" class=\"headerlink\" title=\"例2\"></a>例2</h3><p><a href=\"https://www.luogu.com.cn/problem/P6220\">P6220 [COCI2019-2020#6] Skandi</a></p>\n<p>不要盯着 $1$ 看，因为最终决定是否成功的还是所有的 $0$，而且每个 $0$ 要么从上面，要么从左边，符合二选一条件，我们把向右的 $1$ 放到左边，向下的 $1$ 放到右边，一个既能从上面到达，又能从左边到达的 $0$，就相当于一条边，而最终的答案就是求最小的点集，使得所有边都能被覆盖。</p>\n<p>直接求二分图最小点覆盖即可。</p>\n<p>这道题特殊的地方在于输出方案，按上面证明里面构造的方法输出即可。</p>\n<h3 id=\"例3\"><a href=\"#例3\" class=\"headerlink\" title=\"例3\"></a>例3</h3><p><a href=\"https://www.luogu.com.cn/problem/P3355\">P3355 骑士共存问题</a></p>\n<p>我们拿出一个骑士，找到它放了之后不能放的位置，显然这两个位置中只能放一个。</p>\n<p>所以，把这种东西看成一条边，我们最后得到的骑士点集中，没有任何两个点之间是有边的，这就是最大独立集。</p>\n<p>可以应用黑白染色技巧，分出左部点和右部点，这样才能保证每个部分内部没有边相连。</p>\n<h3 id=\"例4\"><a href=\"#例4\" class=\"headerlink\" title=\"例4\"></a>例4</h3><p><a href=\"https://www.luogu.com.cn/problem/UVA1184\">Air Raid</a></p>\n<p>找一些不交的路径，使每个点都被经过，就是求最小路径点覆盖。</p>\n<p>套模板即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">255</span>,M = <span class=\"number\">2e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,m,head[N],tot,vis[N],tim,mat[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[M];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (vis[v]!=tim)&#123;</span><br><span class=\"line\">\t\t\tvis[v] = tim;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!mat[v] || <span class=\"built_in\">dfs</span>(mat[v]))&#123;</span><br><span class=\"line\">\t\t\t\tmat[v] = u;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clr</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(mat,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(mat));</span><br><span class=\"line\">\ttot = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">clr</span>();</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(x,y+n);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\ttim++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">dfs</span>(i)) ans++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;n-ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"例5\"><a href=\"#例5\" class=\"headerlink\" title=\"例5\"></a>例5</h3><p><a href=\"https://www.acwing.com/problem/content/description/381/\">379. 捉迷藏</a></p>\n<p>先说结论：答案就是原图的最小路径重复点覆盖。</p>\n<p>显然，我们如果找到了 $k$ 条路径，那么每条路径中最多选一个点，于是上限就是这个。</p>\n<p>现在，我们着手构造方案。</p>\n<p>显然，每增加一条路径，必然会覆盖至少一个从未被覆盖过的点。</p>\n<p>我们取这些新点中在路径最末端的点。</p>\n<p>假设现在还是有两个点，它们能够互相到达，假设是 $x\\rightarrow y$，那么考虑新点为 $x$ 的这条路径，它其实是可以扩展到 $y$ 的（因为 $x$ 是最末端的点），所以不会出现这种情况。</p>\n<p>（注意，以上内容纯笔者口胡，如果您能 Hack，请礼貌的提出来，谢谢）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e2</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,head[N],tot,a[N][N],vis[N],tim,mat[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (vis[v]!=tim)&#123;</span><br><span class=\"line\">\t\t\tvis[v] = tim;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!mat[v] || <span class=\"built_in\">dfs</span>(mat[v]))&#123;</span><br><span class=\"line\">\t\t\t\tmat[v] = u;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\ta[x][y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">1</span>;k&lt;=n;k++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (a[j][i] &amp;&amp; a[i][k]) a[j][k] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[i][j]) <span class=\"built_in\">add</span>(i,j);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\ttim++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">dfs</span>(i)) ans++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;n-ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","图论","网络流","二分图"]},{"title":"冒泡排序 题解","url":"/2022/10/03/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"冒泡排序-题解\"><a href=\"#冒泡排序-题解\" class=\"headerlink\" title=\"冒泡排序 题解\"></a>冒泡排序 题解</h1><h2 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h2><p>给你一个序列，每次可以交换相邻的两个数，或者查询对整个序列进行 $k$ 次冒泡排序之后的逆序对数量（这个操作不改变原序列）。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>手动模拟一下，发现冒泡排序的过程本质上就是，找到一个数，它的前面没有比它更大的数，找到它后面第一次出现比它更大的数的位置，将中间的数全部向左平移一位，把它放到比它大的那个数前面去。</p>\n<p>假设这样满足前面所有数都比它小的数有 $k$ 个，则这一次冒泡排序结束后，逆序对个数减少 $n-k$ 个。</p>\n<span id=\"more\"></span>\n<p>转换一下角度，一个数前面如果有 $k$ 个数比它大，那么它的逆序对个数每一轮 $-1$，直到第 $k$ 轮减到 $0$。</p>\n<p>证明：显然，每次越过它的数只能是前面的数中最大的一个，每次去掉一个最大的，去掉 $k$ 次之后就没有了。</p>\n<p>我们设 $b[i]$ 表示第 $i$ 个数前面有几个数比它大，考虑先预处理出进行 $k$ 轮排序后，逆序对的数量总和。</p>\n<p>第 $0$ 轮显然有 $\\sum_{i=1}^nb[i]$。</p>\n<p>第 $i$ 轮，能够对逆序对产生贡献的只有 $b[i]\\geq i$的数，即逆序对总数应该减去 $\\sum_{i,b[i]\\geq i}1$。</p>\n<p>再考虑如何计算修改产生的贡献。</p>\n<p>交换两个数的位置，有两种情况：</p>\n<ol>\n<li><p>$a[i]&lt;a[i+1]$。</p>\n<p>交换之后，$b[i+1]$ 要增大 $1$，因为 $a[i]&gt;a[i+1]$，而 $b[i]$ 不变。</p>\n<p>考虑逆序对数量的变化。</p>\n<p>由于 $b[i+1]$ 增大了 $1$，所以最初的逆序对数量应该增加 $1$。</p>\n<p>而 $b[i+1]$ 增大了 $1$，说明它的影响可以延后一位，即第 $b[i+1]$ 轮的减少量应该增加 $1$。</p>\n</li>\n<li><p>$a[i]&gt;a[i+1]$</p>\n<p>交换之后，$b[i]$ 要减少 $1$。</p>\n<p>由于 $b[i]$ 减少了 $1$，所以最初的逆序对数量应该减少 $1$。</p>\n<p>而 $b[i]$ 减少了 $1$，说明它的影响提前了一位，即第 $b[i]+1$ 轮的减少量应该减小 $1$。</p>\n</li>\n</ol>\n<p>处理好这些问题后，这道题就做完了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>很好的一道题，没有点对冒泡排序的深入认识还真有点困难，一定能够让你对冒泡排序的理解更深一步。 </p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,a[N],b[N],c[N];</span><br><span class=\"line\">ll tr[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">judge</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;test.in&quot;</span>,<span class=\"string\">&quot;r&quot;</span>,stdin);</span><br><span class=\"line\">\t<span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;test.out&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,stdout);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> x,ll v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;x&lt;=n;x+=(x&amp;(-x))) tr[x]+=v;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\tll ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (;x;x-=(x&amp;(-x))) ret+=tr[x];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\tll cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tb[i] = i<span class=\"number\">-1</span>-<span class=\"built_in\">query</span>(a[i]);</span><br><span class=\"line\">\t\tcnt+=b[i];</span><br><span class=\"line\">\t\tc[b[i]]++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(a[i],<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(tr,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(tr));</span><br><span class=\"line\">\t<span class=\"built_in\">update</span>(<span class=\"number\">1</span>,cnt);</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tnow+=c[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(i+<span class=\"number\">1</span>,-(n-now));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> op,x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op&gt;&gt;x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(a[x],a[x+<span class=\"number\">1</span>]),<span class=\"built_in\">swap</span>(b[x],b[x+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[x]&gt;a[x+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">\t\t\t\tb[x+<span class=\"number\">1</span>]++;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">update</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>),<span class=\"built_in\">update</span>(b[x+<span class=\"number\">1</span>]+<span class=\"number\">1</span>,<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tb[x]--;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">update</span>(<span class=\"number\">1</span>,<span class=\"number\">-1</span>),<span class=\"built_in\">update</span>(b[x]+<span class=\"number\">2</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x&gt;=n) cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"built_in\">query</span>(x+<span class=\"number\">1</span>)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","树状数组"]},{"title":"公约数的和 题解","url":"/2022/05/26/%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E5%92%8C-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"公约数的和-题解\"><a href=\"#公约数的和-题解\" class=\"headerlink\" title=\"公约数的和 题解\"></a>公约数的和 题解</h1><h2 id=\"单组数据\"><a href=\"#单组数据\" class=\"headerlink\" title=\"单组数据\"></a>单组数据</h2><p>$\\sum_{i=1}^n\\sum_{j=i+1}^n\\gcd(i,j)$</p>\n<p>这个式子中$j$从$i+1$开始，不好转化，于是根据$gcd(i,j) = gcd(j,i)$，我们把它转化一下：</p>\n<p>$\\frac{\\sum_{i=1}^n\\sum_{j=1}^n\\gcd(i,j)-\\sum_{i=1}^n\\gcd(i,i)}{2}$</p>\n<p>枚举$\\gcd$的值：</p>\n<p>$\\sum_{d=1}^nd\\sum_{i=1}^n\\sum_{j=1}^n[\\gcd(i,j) = d]$</p>\n<span id=\"more\"></span>\n<p>设$i’ = \\frac{i}{d}$，$j’ = \\frac{j}{d}$，代入：</p>\n<p>$\\sum_{d=1}^nd\\sum_{i’=1}^{\\frac{n}{d}}\\sum_{j’=1}^{\\frac{n}{d}}[\\gcd(i’,j’) = 1]$</p>\n<p>将$\\gcd$变成$\\mu$：</p>\n<p>$\\sum_{d=1}^nd\\sum_{i’=1}^{\\frac{n}{d}}\\sum_{j’=1}^{\\frac{n}{d}}\\sum_{k|\\gcd(i’,j’)}\\mu(k)$</p>\n<p>枚举$k$：</p>\n<p>$\\sum_{d=1}^nd\\sum_{k=1}^{\\frac{n}{d}}\\mu(k)\\lfloor \\frac{n}{dk}\\rfloor^2$</p>\n<p>直接套数论分块可以做到$O(n\\sqrt n)$，但是不足以通过此题。</p>\n<p>但是，仔细观察一下，发现这个$\\frac{n}{1}+\\frac{n}{2}+\\cdots +\\frac{n}{n}$的结果是$\\log$级别的，所以实际的复杂度为$O(n\\log n)$，可以通过此题。</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>如果有多组数据，且$n$的限制不变，该怎么办？</p>\n<p>此时，我们显然不能再$O(n\\log n)$回答每组询问了，需要更高效的算法。</p>\n<p>之前的算法瓶颈主要在前面枚举$d$上，可是这里好像也没有优化空间了。</p>\n<p>这时，我们应该换一种思路：</p>\n<p>求这个是比较方便的：</p>\n<p>$\\sum_{i=1}^n\\gcd(i,n)$</p>\n<p>枚举$\\gcd$：</p>\n<p>$\\sum_{d|n}d\\sum_{i=1}^n[gcd(i,n) = d]$</p>\n<p>同时除$d$：</p>\n<p>$\\sum_{d|n}d\\sum_{i=1}^{\\frac{n}{d}}[gcd(i,\\frac{n}{d}) = 1]$</p>\n<p>后面的东西就是$\\varphi(\\frac{n}{d})$。</p>\n<p>于是，这个东西只需要$O(\\sqrt n)$的复杂度就可以了。</p>\n<p>我们要求的东西就是$\\sum_{i=1}^{n}(\\sum_{d|i}d\\cdot \\varphi(\\frac{i}{d}))-i$。</p>\n<p>这个东西可以$O(n\\log n)$预处理出来。</p>\n","tags":["Editorial","数论","莫比乌斯反演"]},{"title":"力 题解","url":"/2022/07/07/%E5%8A%9B-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"力-题解\"><a href=\"#力-题解\" class=\"headerlink\" title=\"力 题解\"></a>力 题解</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给出 $q_1,q_2\\cdots q_n$，求 $E_i = \\sum_{j=1}^{i-1}\\frac{q_j}{(i-j)^2}\\sum_{j=i+1}^n\\frac{q_j}{(i-j)^2}$。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>如果要使用 FFT，最后都要化成加法卷积的形式：</p>\n<p>$C[k] = \\sum_{i+j = k}A[i]*B[j]$</p>\n<p>这里的 $C[k],A[i],B[j]$ 都是多项式的系数。</p>\n<span id=\"more\"></span>\n<p>先把 $*$ 搞出来：</p>\n<p>设 $A(x) = q_nx^n+q_{n-1}x^{n-1}\\cdots+q_0$，$B(x) = \\frac{x^n}{n^2}+\\frac{x^{n-1}}{(n-1)^2}+\\cdots +0^2$。</p>\n<p>$E_i = \\sum_{j=1}^{i-1}A[j]<em>B[i-j]-\\sum_{j=i+1}^nA[j]</em>B[j-i]$</p>\n<p>两边都加上一个 $i$，之后把左边扩展到 $0$（$A[0] = B[0] = 0$）：</p>\n<p>$E_i = \\sum_{j=0}^iA[j]<em>B[i-j]-\\sum_{j=i}^nA[j]</em>B[j-i]$</p>\n<p>左边的已经是卷积形式了，不用管它，继续推右边。</p>\n<p>首先，这个东西必须从 $0$ 开始，于是采用换元法，令 $T = j-i$：</p>\n<p>$\\sum_{T=0}^{n-i}A[T+i]B[T]$</p>\n<p>发现化不了了，于是考虑另取一个多项式，硬凑出来：</p>\n<p>设 $A[i] = A’[n-i]$，则：</p>\n<p>$\\sum_{T=0}^{n-i}A’[(n-i)-T]B[T]$</p>\n<p>这样，我们就把原式化为了这个东西：</p>\n<p>$E_i = \\sum_{j=0}^iA[j]*B[i-j]-\\sum_{T=0}^{n-i}A’[(n-i)-T]B[T]$</p>\n<p>直接用 FFT 计算左右两边卷积在 $i$ 和 $n-i$ 处的系数即可。 </p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span> Pi = <span class=\"built_in\">acos</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">3e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,sw[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">cp</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">double</span> x,y;</span><br><span class=\"line\">\tcp <span class=\"keyword\">operator</span> + (cp <span class=\"type\">const</span> &amp;b) <span class=\"type\">const</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;x+b.x,y+b.y&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcp <span class=\"keyword\">operator</span> - (cp <span class=\"type\">const</span> &amp;b) <span class=\"type\">const</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;x-b.x,y-b.y&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcp <span class=\"keyword\">operator</span> * (cp <span class=\"type\">const</span> &amp;b) <span class=\"type\">const</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> &#123;x*b.x-y*b.y,x*b.y+y*b.x&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; a[N],b[N],c[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fft</span><span class=\"params\">(cp *f,<span class=\"type\">int</span> flag)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) <span class=\"keyword\">if</span> (i&lt;sw[i]) <span class=\"built_in\">swap</span>(f[i],f[sw[i]]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">2</span>;p&lt;=n;p&lt;&lt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> len = p&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tcp rt = &#123;<span class=\"built_in\">cos</span>(<span class=\"number\">2</span>*Pi/p),flag*<span class=\"built_in\">sin</span>(<span class=\"number\">2</span>*Pi/p)&#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i+=p)&#123;</span><br><span class=\"line\">\t\t\tcp now = &#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,tmp;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=i;j&lt;i+len;j++)&#123;</span><br><span class=\"line\">\t\t\t\ttmp = now*f[j+len];</span><br><span class=\"line\">\t\t\t\tf[j+len] = f[j]-tmp;</span><br><span class=\"line\">\t\t\t\tf[j] = f[j]+tmp;</span><br><span class=\"line\">\t\t\t\tnow = now*rt;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcout&lt;&lt;fixed&lt;&lt;<span class=\"built_in\">setprecision</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tb[i].x = <span class=\"number\">1.0</span>/(<span class=\"number\">1ll</span>*i*i);</span><br><span class=\"line\">\t\tc[i].x = a[n-i].x;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc[<span class=\"number\">0</span>].x = a[n].x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = n;</span><br><span class=\"line\">\tm = n*<span class=\"number\">2</span>,n = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (n&lt;=m) n&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) sw[i] = (sw[i&gt;&gt;<span class=\"number\">1</span>]&gt;&gt;<span class=\"number\">1</span>)|(i&amp;<span class=\"number\">1</span>?n&gt;&gt;<span class=\"number\">1</span>:<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">fft</span>(a,<span class=\"number\">1</span>),<span class=\"built_in\">fft</span>(b,<span class=\"number\">1</span>),<span class=\"built_in\">fft</span>(c,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) a[i] = a[i]*b[i],c[i] = c[i]*b[i];</span><br><span class=\"line\">\t<span class=\"built_in\">fft</span>(a,<span class=\"number\">-1</span>),<span class=\"built_in\">fft</span>(c,<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tmp;i++) cout&lt;&lt;a[i].x/n-c[tmp-i].x/n&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","数学","多项式","FFT"]},{"title":"化学周练6B 题解","url":"/2023/05/08/%E5%8C%96%E5%AD%A6%E5%91%A8%E7%BB%836B-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"化学周练6B-题解\"><a href=\"#化学周练6B-题解\" class=\"headerlink\" title=\"化学周练6B 题解\"></a>化学周练6B 题解</h1><h2 id=\"T1\"><a href=\"#T1\" class=\"headerlink\" title=\"T1\"></a>T1</h2><p>A：葡萄糖中还有羟基，所以不能判断是谁被氧化了。</p>\n<p>B：$NO_2$ 并没有全部转化，只是转化了一部分，所以现在 $NO_2$ 的量比原来多，颜色会比原来深。</p>\n<p>C：和 $Mg$ 在 $CO_2$ 中燃烧差不多，就是还原性的问题。</p>\n<p>D：如果水解是吸热过程，那加热后应该会吸收 $H^+$，使 pH 增大。</p>\n<span id=\"more\"></span>\n<h2 id=\"T2\"><a href=\"#T2\" class=\"headerlink\" title=\"T2\"></a>T2</h2><p>A：含有碳碳双键，可以和溴加成，有醛基，可以被溴氧化成羧基，反应正确。</p>\n<p>$\\color{red}B$：不知道是哪里的反应。</p>\n<p>C：水垢就是固体物质，应该当作沉淀处理，离子方程式里面不是电解质就一定写成电离形式，而是要看实际情况，比如侯氏制碱法。</p>\n<p>D：酚羟基和羧基的酸性很弱，不能生成酸性更强的硫酸。</p>\n<h2 id=\"T3\"><a href=\"#T3\" class=\"headerlink\" title=\"T3\"></a>T3</h2><p>这道题看了好久。</p>\n<p>一般酯类物质分解成两个产物就是水解反应生成羧酸和醇，看到下面的两个氧化就应该想到是醇变成羧酸的过程。</p>\n<p>但是，上面为什么还要加 $H_2SO_4$ 呢？</p>\n<p>在课本 P78 写到，酯类的水解反应有两种形式，一种是在<strong>稀硫酸</strong>和加热的条件下发生的可逆反应，一种是和 $NaOH$ 发生的反应，其中羧酸的 $-OH$ 中的 $H$ 被 $Na$ 取代了，所以 B 应该是 $C_4H_9COONa$！</p>\n<p>现在加硫酸，就是强酸制弱酸的过程了，生成的 D 才是羧酸。</p>\n<p>D 和 F 是同分异构体，那就只能都是 $5$ 个碳。</p>\n<p>唯一要注意的是不能分成 $4+1$ 考虑，必须当成整体。</p>\n<p>之后再除去同种物质，就是 $16-4=12$ 种。</p>\n<h2 id=\"T4\"><a href=\"#T4\" class=\"headerlink\" title=\"T4\"></a>T4</h2><p>A：乙醇易挥发，不能检验。</p>\n<p>B：</p>\n<p>需要先知道酸性强弱，$CH_3COOH&gt;H_2CO_3&gt;C_6H_6OH&gt;H_2O&gt;CH_3CH_2OH$。</p>\n<p>醋酸加到碳酸钠里面，会生成碳酸，这一步没问题。</p>\n<p>但是，醋酸和碳酸都可以挥发，不知道是谁比苯酚强。</p>\n<p>所以，应该再加一个 $NaHCO_3$ 溶液试管吸收挥发的醋酸，生成更多的碳酸，一举两得。</p>\n<p>$\\color{red}其实这个实验是书上的原实验，要多看书！$</p>\n<p>C：</p>\n<p>这个实验貌似做过，但是忘了，还是要多看实验视频！</p>\n<p>试管里就是正常的反应条件，饱和碳酸钠溶液作用有二：</p>\n<ol>\n<li>吸收乙酸，强酸制弱酸。</li>\n<li>吸收乙醇，乙醇在水溶液中溶解。</li>\n</ol>\n<p>$\\color{red}就是不知道要不要加碎瓷片？$</p>\n<p>D：</p>\n<p>虽然说氨气在水中溶解度很大，但是这样溶太快了，压强变化大，会倒吸，所以要在前面加防倒吸装置。</p>\n<h2 id=\"T5\"><a href=\"#T5\" class=\"headerlink\" title=\"T5\"></a>T5</h2><p>D：</p>\n<p>苯和 $KMnO_4$ 好像不好直接反应，甲基竟然可以被直接氧化为 $COOH$？活久见。</p>\n<h2 id=\"T6\"><a href=\"#T6\" class=\"headerlink\" title=\"T6\"></a>T6</h2><p>D：$8$ 个酚羟基和一个酯基，一共 $9$ 个 $NaOH$。</p>\n<h2 id=\"T7\"><a href=\"#T7\" class=\"headerlink\" title=\"T7\"></a>T7</h2><p>A：</p>\n<p>亲水基，如 $-NH_2$ 很少，而疏水基很多，所以难溶。</p>\n<p>$\\color{red}要补充相关知识$</p>\n<h2 id=\"T8\"><a href=\"#T8\" class=\"headerlink\" title=\"T8\"></a>T8</h2><p>D：</p>\n<p>乙基丙烯酸正己酯，注意这里的乙基是取代基，而丙烯才是主链，所以乙基应该连到丙烯的第二个碳上。</p>\n<p>$\\color{red}这里的酸是啥意思？$</p>\n<h2 id=\"T9\"><a href=\"#T9\" class=\"headerlink\" title=\"T9\"></a>T9</h2><p>A 中的酚羟基和酯基都可以反应，显然最右边的碳连的是酯基，所以它会生成甲酸钠，左边则又会生成一个酚羟基，继续反应，消耗 $3mol$。</p>\n<p>B 中只有酚羟基和羧基可以反应，消耗 $2mol$。</p>\n<h2 id=\"T10\"><a href=\"#T10\" class=\"headerlink\" title=\"T10\"></a>T10</h2><p>B：好像只要结构不对称就有 $8$ 组。</p>\n<p>$\\color{red}回头再看一下怎么判断H的环境$</p>\n<h2 id=\"T11\"><a href=\"#T11\" class=\"headerlink\" title=\"T11\"></a>T11</h2><p>首先，盐酸可以把苯胺转化为易溶于水的苯胺酸盐，进入到水相 I 中，再和 $NaOH$ 反应，貌似是 $\\color{red}强碱制弱碱$，生成苯胺。</p>\n<p>苯甲酸微溶于水，到有机相 I 中，之后和 $Na_2CO_3$ 溶液反应，生成苯甲酸钠，到水相 II 中，再和盐酸反应，生成苯甲酸。</p>\n<p>苯胺是液体，苯甲酸是固体，所以 1 和 3 分离产物的方式不同，B 错误。</p>\n<p>甲苯则一直在有机相中，不和别的东西反应，在有机相 II 中被剔除，C 正确。</p>\n<h2 id=\"T12\"><a href=\"#T12\" class=\"headerlink\" title=\"T12\"></a>T12</h2><p>A：有 $12$ 种，$\\color{red}至于图片之后再附$。</p>\n<h2 id=\"T13\"><a href=\"#T13\" class=\"headerlink\" title=\"T13\"></a>T13</h2><p>D 错的还是很明显的，没啥键能加聚。</p>\n<p>$\\color{red}C不是很明白$。</p>\n<h2 id=\"T14\"><a href=\"#T14\" class=\"headerlink\" title=\"T14\"></a>T14</h2><p>$\\color{red}机理题，不是很明白$。</p>\n<h2 id=\"T15\"><a href=\"#T15\" class=\"headerlink\" title=\"T15\"></a>T15</h2><p>A：决速步一般是化学能变化最大的步骤，可以看到 $I,IV$ 最大，所以是决速步。</p>\n<p>B：$\\color{red}不是很明白答案的成键方式$，但是既然有这个快速平衡，而且 $C-O$ 键其实也容易断，所以可以暂且认为有 $-^{18}OH$。</p>\n<p>C：不会有，因为 $CH_3O^-$ 的 $O$ 在反应中都没啥变化，$^{18}O$ 变化的位置只是 $-O$ 和 $-OH$，所以不可能出现。</p>\n<p>D：很正确。</p>\n<h2 id=\"T16\"><a href=\"#T16\" class=\"headerlink\" title=\"T16\"></a>T16</h2><p>A：都有 $N,O$ 了，肯定不是烃啊。</p>\n<p>B：有氨基，可以和盐酸反应，有羧基，可以和 $NaOH$ 反应。</p>\n<p>C：其他的都不是醛基，不能加成，只有 $4mol$。</p>\n<p>D：$Cl$ 可以作为卤代烃的一部分水解，生成醇羟基，但是如果氧化成醛基，那这个碳上就有 $6$ 条键了，所以不行。</p>\n<h2 id=\"T17\"><a href=\"#T17\" class=\"headerlink\" title=\"T17\"></a>T17</h2><p>自己的推断方法：</p>\n<p>$4$ 后面的反应还是很明了的，$4\\rightarrow 5$ 是加成，$5\\rightarrow 6$ 是加成，$6\\rightarrow 7$ 是水解。</p>\n<p>A：如果 N 和 Y 是同种物质，你干嘛费这么大劲再合成一堆东西呢？</p>\n<p>B：首先，环己二烯的说法不是很准确，因为有同分异构体，而且加成也可以有别的产物，比如只加成一个键（估计是反应条件决定？）</p>\n<p>C：$\\color{red}不是很懂，也没怎么看懂答案$。</p>\n<p>D：第一步就是取代，有双键生成就是消去，双键最后消失就是加成。</p>\n<h2 id=\"T18\"><a href=\"#T18\" class=\"headerlink\" title=\"T18\"></a>T18</h2><p>A：显然是催化剂。</p>\n<p>B：有酰胺基，可以反应。</p>\n<p>C：$\\color{red}不知道$。</p>\n<p>D：$\\color{red}不知道$。</p>\n<h2 id=\"T19\"><a href=\"#T19\" class=\"headerlink\" title=\"T19\"></a>T19</h2><p>A：左边得到 $H$，要得电子，所以 a 是负极。</p>\n<p>B：得到 $-OH$ 的是催化电极。</p>\n<p>C：右边失去两个 $H$，左边得到两个 $H$，所以一换一，但是右边本身也要消耗，所以一共消耗 $2mol$。</p>\n<p>D：得电子。</p>\n<h2 id=\"T20\"><a href=\"#T20\" class=\"headerlink\" title=\"T20\"></a>T20</h2><p>看选项得知上面有 $+$ 的是酸，根据强酸制弱酸，选 A。</p>\n","tags":["Test","周练","化学"]},{"title":"化学学案第一章复习","url":"/2023/09/17/%E5%8C%96%E5%AD%A6%E5%AD%A6%E6%A1%88%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%A4%8D%E4%B9%A0/","content":"<h1 id=\"物质及其变化\"><a href=\"#物质及其变化\" class=\"headerlink\" title=\"物质及其变化\"></a>物质及其变化</h1><h2 id=\"物质的分类\"><a href=\"#物质的分类\" class=\"headerlink\" title=\"物质的分类\"></a>物质的分类</h2><ul>\n<li>注意氧化物这一块，分为<strong>酸性氧化物</strong>，<strong>碱性氧化物</strong>，<strong>两性氧化物</strong>，其中两性氧化物<strong>不属于</strong>其余的两类！</li>\n<li><strong>过氧化物</strong>不是氧化物。</li>\n</ul>\n<span id=\"more\"></span>\n<ul>\n<li>盐的分类有<strong>正盐</strong>，<strong>酸式盐</strong>，<strong>碱式盐</strong>，<strong>复盐</strong>。<ul>\n<li>正盐是仅由金属阳离子（$NH_4^+$）和酸根阴离子组成的盐，如 $NaCl$。</li>\n<li>酸式盐是能电离出 $H^+$ 的盐，如 $NaHCO_3$。</li>\n<li>碱式盐是能电离出 $OH^-$ 的盐，如 $Cu_2(OH)_2CO_3$</li>\n<li>复盐是由两种金属阳离子（$NH_4^+$）和一种酸根阴离子构成的盐，如 $KAl(SO_4)_2\\cdot 12H_2O$。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"胶体\"><a href=\"#胶体\" class=\"headerlink\" title=\"胶体\"></a>胶体</h2><ul>\n<li><p>溶液，胶体，浊液的直径分别为 $<1nm$，$1nm$~$100nm$，$>100nm$。</p>\n</li>\n<li><p>如果提到了纳米颗粒，一般看作胶体。（这里的区分比较模糊，不建议以此为判断标准）</p>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2023/09/17/Vl4PyTbXwRKis3c.png\" alt=\"图片1\"></p>\n<ul>\n<li>氢氧化铁的制备<ul>\n<li>注意加热和胶体，不要写成沉淀，因为不是浊液。</li>\n<li>对于制备的实验，需要注意是<strong>滴加</strong>氯化铁于<strong>沸水</strong>中，至<strong>红褐色</strong>后停止加热。</li>\n<li>不能用自来水，必须用蒸馏水，因为自来水中有电解质，会使胶体聚沉。</li>\n</ul>\n</li>\n<li>胶体是多个粒子的集合，故 $1mol\\ FeCl_3$ 制备出来的 $Fe(OH)_3$ 胶体小于 $1mol$。</li>\n</ul>\n<h2 id=\"离子\"><a href=\"#离子\" class=\"headerlink\" title=\"离子\"></a>离子</h2><ul>\n<li>$AlO_2^-$ 和 $HCO_3^-$、$CO_3^{2-}$、$S^{2-}$、$HS^-$；$Fe^{3+}$ 和 $CO_3^{2-}$、$HCO_3^-$、$AlO_2^-$；$NH_4^+$和 $AlO_2$ 都可以发生双水解反应，不能大量共存。</li>\n<li>$NH_4^+$ 和 $CH_3COO^-$、$CO_3^{2-}$；$Mg^{2+}$ 和 $HCO_3^-$ 等虽然看似能双水解，但是总水解程度依然很小，在溶液中能大量共存。</li>\n<li>有价值的题：加入铝粉产生氢气的溶液中不可能大量存在 $NH_4^+$ 和 $NO_3^-$。产生 $H_2$，说明要么酸性，要么碱性，如果碱性，那 $NH_4^+$ 就不能存在，如果酸性，那 $H^+$ 和 $NO_3^-$ 同时存在，看成硝酸，可以和 $Al$ 反应产生 $NO$ 或 $NO_2$，所以不止产生了氢气。</li>\n<li>对于电离，可以是水中，也可以是熔融状态，要注意的是，对于 $NaHSO_4$ 这种物质，在水中可以电离出 $Na^+$，$H^+$，$SO_4^{2-}$，但是在熔融状态下只能电离出 $Na^+$ 和 $HSO_4^-$。</li>\n</ul>\n<h2 id=\"物质的量\"><a href=\"#物质的量\" class=\"headerlink\" title=\"物质的量\"></a>物质的量</h2><ul>\n<li>物质的量浓度 $c = \\frac{n}{V}$。</li>\n<li>质量分数 $\\omega = \\frac{m(溶质)}{m(溶液)}$。</li>\n<li>$c = \\frac{1000\\rho\\omega}{M}$。</li>\n<li><p>同一溶质，质量分数分别为 $a\\%$，$b\\%$ 的溶液混合。$\\color{red}此处需要更深入的思考$</p>\n<ul>\n<li>等体积混合<ul>\n<li>溶液密度大于 $1g\\cdot cm^{-3}$ 时，溶液浓度越大，密度越大，$\\omega&gt;\\frac{1}{2}(a\\%+b\\%)$。</li>\n<li>溶液密度小于 $1g\\cdot cm^{-3}$ 时，溶液浓度越大，密度越小，$\\omega&lt;\\frac{1}{2}(a\\%+b\\%)$。</li>\n</ul>\n</li>\n<li>等质量混合<ul>\n<li>无论密度如何，$\\omega=\\frac{1}{2}(a\\%+b\\%)$。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>配制一定物质的量浓度的溶液</p>\n<ol>\n<li><p>先计算所需固体的量。</p>\n</li>\n<li><p>用天平称量一定质量的固体，称量时，<strong>固体要放入烧杯中</strong>，避免粘在纸上。</p>\n</li>\n<li>向烧杯中加入适量水，溶解。</li>\n<li>待烧杯中的液体<strong>冷却至室温</strong>后，用<strong>玻璃棒</strong>引流，注入容量瓶中。</li>\n<li>用少量蒸馏水洗涤烧杯和玻璃棒 2~3 次，全部注入容量瓶中。</li>\n<li>向容量瓶中加入蒸馏水，加到刻度线下方 $1$~$2cm$ 时，改用<strong>胶头滴管</strong>滴加，至凹液面最低处和刻度线相切。</li>\n<li>盖好瓶盖，反复<strong>上下、颠倒</strong>摇匀。（两个操作一定都要出现才算对）</li>\n</ol>\n</li>\n<li><p>常见容量瓶容量：$25,50,100,250,500,1000ml$。</p>\n</li>\n</ul>\n","tags":["化学","文化课"]},{"title":"化学学案第二章复习","url":"/2023/09/17/%E5%8C%96%E5%AD%A6%E5%AD%A6%E6%A1%88%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%A4%8D%E4%B9%A0/","content":"<h1 id=\"金属和非金属\"><a href=\"#金属和非金属\" class=\"headerlink\" title=\"金属和非金属\"></a>金属和非金属</h1><h2 id=\"钠及其化合物\"><a href=\"#钠及其化合物\" class=\"headerlink\" title=\"钠及其化合物\"></a>钠及其化合物</h2><ul>\n<li>在空气中变化过程：<ul>\n<li>$Na\\rightarrow$ 被氧气氧化生成$Na_2O$，表面变暗$\\rightarrow$ 吸收空气中水蒸气生成$NaOH$，出现白色固体</li>\n<li>$\\rightarrow NaOH$潮解，出现液滴$\\rightarrow$ 吸收$CO_2$，生成白色块状物质$Na_2CO_3\\cdot 12H_2O\\rightarrow$ 风华，生成白色粉末状物质 $Na_2CO_3$。</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n<ul>\n<li>钠应保存在<strong>煤油</strong>中，以隔绝 $O_2$ 和 $H_2O$，实验完毕后，$Na$ <strong>要放回原试剂瓶</strong>，因为不用管纯度问题，这是习惯。</li>\n<li>大苏打：$Na_2S_2O_3$。苏打：$Na_2CO_3$。小苏打：$NaHCO_3$。</li>\n</ul>\n<h2 id=\"碱金属\"><a href=\"#碱金属\" class=\"headerlink\" title=\"碱金属\"></a>碱金属</h2><ul>\n<li>密度一般随核电荷数增大而增大，但是 $\\rho(K)&lt;\\rho(Na)$。</li>\n<li>一般都保存在煤油中，但是由于 $Li$ 的密度比煤油还小，所以保存在石蜡中。</li>\n<li>$Li$ 和 $O_2$ 反应只生成 $Li_2O$。</li>\n<li>焰色试验<ul>\n<li>注意是<strong>试验</strong>而不是<strong>实验</strong>。</li>\n<li>是物理变化，属于元素的性质。</li>\n<li>先用铂丝在酒精灯下灼烧，直到焰色变为无色，再用铂丝蘸取被测物，在酒精灯下灼烧，观察火焰焰色，之后用盐酸洗涤铂丝，在酒精灯下灼烧至无色。</li>\n<li>$Na$ 黄色，$K$ 紫色（<strong>透过蓝色钴玻璃观察</strong>），$Cu$ 绿色，$Ba$ 黄绿色，$Ca$ 砖红色。</li>\n<li>用盐酸而不用硫酸清洗铂丝的原因：氯化物一般易挥发，但硫酸盐一般难以挥发，会造成干扰。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"铁及其化合物\"><a href=\"#铁及其化合物\" class=\"headerlink\" title=\"铁及其化合物\"></a>铁及其化合物</h2><ul>\n<li><p>赤铁矿：$Fe_2O_3$。磁铁矿：$Fe_3O_4$。褐铁矿：$mFe_2O_3\\cdot nH_2O$。菱铁矿：$FeCO_3$。黄铁矿：$FeS_2$。</p>\n</li>\n<li><p>铁红：$Fe_2O_3$。磁性氧化铁：$Fe_3O_4$。</p>\n</li>\n<li><p>$FeS$ 溶于盐酸，而 $CuS$ 只有在较浓的硝酸或硫酸中才能溶，是因为 $FeS$ 的溶度积较大，溶解所需的 $c(H^+)$ 较小。</p>\n</li>\n<li><p>$Fe(OH)_2$ 的制备：</p>\n<p><img src=\"https://s2.loli.net/2023/09/17/RXdC5l3Esc2tnIf.jpg\" alt=\"IMG_3958\"></p>\n<p><img src=\"https://s2.loli.net/2023/09/17/wtTNRpicY8VCyJ4.jpg\" alt=\"IMG_3957\"></p>\n</li>\n<li><p>$Fe^{2+}$ 检验：滴加 $K_3[Fe(CN)_6]$（铁氰化钾，俗称赤血盐）红色溶液，产生蓝色沉淀 $Fe_3[Fe(CN)_6]_2$（滕氏蓝）。</p>\n</li>\n<li><p>$Fe^{3+}$ 检验：滴加 $KSCN$（硫氰化钾）溶液，变红色，利用的是产生配合物的性质。也可滴加 $K_4Fe(CN)_6·3H_2O$（亚铁氰化钾，俗称黄血盐），产生蓝色沉淀 $Fe_4[Fe(CN)_6]_3$（普鲁士蓝）。</p>\n</li>\n<li><p>有价值的题：可以通过化合反应制备 $FeCl_2$，$2FeCl_3+Fe = 3FeCl_2$，不要只想单质化合。</p>\n</li>\n</ul>\n<h2 id=\"铝及其化合物\"><a href=\"#铝及其化合物\" class=\"headerlink\" title=\"铝及其化合物\"></a>铝及其化合物</h2><ul>\n<li>明矾：$KAl(SO_4)_2\\cdot 12H_2O$。胆矾（蓝矾）：$CuSO_4\\cdot 5H_2O$。</li>\n<li>铜丝在空气中加热后和乙醇反应产生刺激性气体：$C_2H_5OH+CuO=CH_3CHO+Cu+H_2O$（条件为加热）</li>\n</ul>\n","tags":["化学","文化课"]},{"title":"区间 DP 入门","url":"/2022/11/21/%E5%8C%BA%E9%97%B4-DP-%E5%85%A5%E9%97%A8/","content":"<h1 id=\"区间-DP-入门\"><a href=\"#区间-DP-入门\" class=\"headerlink\" title=\"区间 DP 入门\"></a>区间 DP 入门</h1><h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><h2 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h2><p><a href=\"https://www.luogu.com.cn/problem/CF149D\">Coloring Brackets</a></p>\n<span id=\"more\"></span>\n<p>就是在区间 dp 的基础上加一点分类讨论。</p>\n<p>设 $f[i][j][ci][cj]$ 表示 $i$ 到 $j$ 的区间，左边填 $ci$，右边填 $cj$ 的方案数。</p>\n<p>这里我们设不填为 $0$，红为 $1$，蓝为 $2$，显然一个区间有 $9$ 种可能的状态。</p>\n<p>我们从整体入手，因为这样可以运用这个 dp 特有的性质。</p>\n<p>首先，我们最开始的状态一定是 $f[1][n][?][?]$。可以发现，不论最左边和最右边的括号是否匹配，它都满足最左边是左括号，最右边是右括号。</p>\n<p>如果匹配，那么皆大欢喜，我们可以枚举左右两边填的情况，再递归解决去掉左右两边之后的子问题。</p>\n<p>考虑它们要满足的限制：</p>\n<ol>\n<li>左右两边的括号是匹配的，所以有且仅有一个有颜色。</li>\n<li>左边和它旁边的颜色不一样，右边和它旁边的颜色不一样。</li>\n</ol>\n<p>于是，可以枚举它们旁边的颜色，把所有合法的加起来。</p>\n<p>如果不匹配，则现在最左边的一定有一个和它匹配的右括号，而这个右括号右边的一定和最右边的匹配（因为我们考虑的是初始的整个串），也就是说，我们可以分成两个匹配的串，分别求解。</p>\n<p>找到所有合法的状态，这时候就要乘起来了，因为两边是互不干扰的。</p>\n<p>我们发现，按照这样的方式 dp，可以覆盖到所有状态，且每个状态必然满足左边是左括号，右边是右括号，于是可以推出所有状态的转移都是合法的。</p>\n<p>根据上面的性质，边界的求解就很显然了，两个括号一定是匹配的，按照题目要求做就可以了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">7e2</span>+<span class=\"number\">10</span>,mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,sta[N],tp,mat[N],f[N][N][<span class=\"number\">3</span>][<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">dp</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> cl,<span class=\"type\">int</span> cr)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (f[l][r][cl][cr]&gt;=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> f[l][r][cl][cr];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l+<span class=\"number\">1</span> == r) <span class=\"keyword\">return</span> f[l][r][cl][cr] = (cl&gt;<span class=\"number\">0</span>)!=(cr&gt;<span class=\"number\">0</span>);</span><br><span class=\"line\">\tf[l][r][cl][cr] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mat[l] == r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!((cl&gt;<span class=\"number\">0</span>)!=(cr&gt;<span class=\"number\">0</span>))) <span class=\"keyword\">return</span> f[l][r][cl][cr] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=<span class=\"number\">2</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">2</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((i &amp;&amp; i == cl) || (j &amp;&amp; j == cr)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\tf[l][r][cl][cr] = (f[l][r][cl][cr]+<span class=\"built_in\">dp</span>(l+<span class=\"number\">1</span>,r<span class=\"number\">-1</span>,i,j))%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=<span class=\"number\">2</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">2</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!((cl&gt;<span class=\"number\">0</span>)!=(i&gt;<span class=\"number\">0</span>) &amp;&amp; !(i == j &amp;&amp; i))) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\tf[l][r][cl][cr] = (f[l][r][cl][cr]+<span class=\"built_in\">dp</span>(l,mat[l],cl,i)*<span class=\"built_in\">dp</span>(mat[l]+<span class=\"number\">1</span>,r,j,cr)%mod)%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> f[l][r][cl][cr];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\tn = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;(&#x27;</span>) sta[++tp] = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> mat[sta[tp]] = i,tp--;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=<span class=\"number\">2</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">2</span>;j++) ans = (ans+<span class=\"built_in\">dp</span>(<span class=\"number\">1</span>,n,i,j))%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","DP","区间DP"]},{"title":"博客临时目录","url":"/2023/04/16/%E5%8D%9A%E5%AE%A2%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95/","content":"<h1 id=\"博客临时目录\"><a href=\"#博客临时目录\" class=\"headerlink\" title=\"博客临时目录\"></a>博客临时目录</h1><h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><p>省选寄了，只能回来补文化课了＞﹏＜。</p>\n<p>无论如何，自己选择的路，一定要完整的走一遍。</p>\n<p><del>当一个二次元肥宅是真香啊</del></p>\n<span id=\"more\"></span>\n<h2 id=\"语文\"><a href=\"#语文\" class=\"headerlink\" title=\"语文\"></a>语文</h2><h3 id=\"作文\"><a href=\"#作文\" class=\"headerlink\" title=\"作文\"></a>作文</h3><p><a href=\"https://bowenone580.github.io/2023/05/14/春雨/\">春雨</a></p>\n<h2 id=\"数学\"><a href=\"#数学\" class=\"headerlink\" title=\"数学\"></a>数学</h2><p><a href=\"https://bowenone580.github.io/2023/07/09/导数复习/\">导数复习</a></p>\n<h2 id=\"英语\"><a href=\"#英语\" class=\"headerlink\" title=\"英语\"></a>英语</h2><h2 id=\"物理\"><a href=\"#物理\" class=\"headerlink\" title=\"物理\"></a>物理</h2><p><a href=\"https://bowenone580.github.io/2024/02/25/天体运动/\">天体运动</a></p>\n<h2 id=\"化学\"><a href=\"#化学\" class=\"headerlink\" title=\"化学\"></a>化学</h2><p><a href=\"https://bowenone580.github.io/2023/05/08/化学周练6B-题解/\">化学周练6B 题解</a></p>\n<p><a href=\"https://bowenone580.github.io/2023/09/17/实验题必备知识/\">实验题必备知识</a></p>\n<p><a href=\"https://bowenone580.github.io/2023/09/17/化学学案第一章复习/\">化学学案第一章复习</a></p>\n<p><a href=\"https://bowenone580.github.io/2023/09/17/化学学案第二章复习/\">化学学案第二章复习</a></p>\n<p><a href=\"https://bowenone580.github.io/2023/09/02/干燥剂/\">干燥剂</a></p>\n<h2 id=\"生物\"><a href=\"#生物\" class=\"headerlink\" title=\"生物\"></a>生物</h2>","tags":["Menu","文化课"]},{"title":"博客总目录","url":"/2022/07/01/%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%9B%AE%E5%BD%95/","content":"<h2 id=\"一些标记\"><a href=\"#一些标记\" class=\"headerlink\" title=\"一些标记\"></a>一些标记</h2><p>$\\color{blue}{\\Phi}$ 表示内容完备。</p>\n<p>$\\color{red}\\epsilon$ 表示没有写完。</p>\n<p>$\\color{grey}\\mu$ 表示已经过时，仅具备一定的阅读价值。</p>\n<p>$\\color{grey}\\varkappa$ 表示待填坑。</p>\n<p>图挂了可以联系我，虽然不一定会修。（毕竟图床用一个倒一个啊）</p>\n<p><del>尽量在退役之前写完吧。</del></p>\n<p>UPD：博主现已退役。</p>\n<span id=\"more\"></span>\n<h2 id=\"数学部分\"><a href=\"#数学部分\" class=\"headerlink\" title=\"数学部分\"></a>数学部分</h2><p>$\\color{grey}\\mu$ <a href=\"https://bowenone580.github.io/2022/04/01/质数/\">质数</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/04/02/约数/\">约数</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/04/05/同余/\">同余</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/11/04/数学期望入门/\">数学期望入门</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/05/26/对莫比乌斯函数的研究/\">对莫比乌斯函数的研究</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/06/20/对杜教筛的研究/\">对杜教筛的研究</a></p>\n<p>$\\color{grey}\\mu$ <a href=\"https://bowenone580.github.io/2021/08/04/卡特兰数/\">卡特兰数</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/10/28/矩阵乘法初步/\">矩阵乘法初步</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/11/04/线性代数入门/\">线性代数入门</a></p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/02/03/背包问题浅析/\">背包问题浅析</a></p>\n<p>$\\color{red}\\epsilon$ <a href=\"https://bowenone580.github.io/2022/11/21/区间-DP-入门/\">区间 DP 入门</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/11/21/数位-DP-入门/\">数位 DP 入门</a></p>\n<p>$\\color{blue}{\\Phi}$ <a href=\"https://bowenone580.github.io/2023/02/18/状压DP入门/#more\">状压DP入门</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/11/05/子集枚举-DP/\">子集枚举 DP</a></p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/07/13/对线段树的研究/\">对线段树的研究</a></p>\n<p>$\\color{red}\\epsilon$ <a href=\"https://bowenone580.github.io/2022/02/09/莫队算法初步/\">莫队算法初步</a></p>\n<p>$\\color{blue}{\\Phi}$ <a href=\"https://bowenone580.github.io/2023/02/07/并查集总结/\">并查集总结</a></p>\n<h2 id=\"图论\"><a href=\"#图论\" class=\"headerlink\" title=\"图论\"></a>图论</h2><p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/05/26/对拓扑排序的研究/\">对拓扑排序的研究</a></p>\n<p>$\\color{red}\\epsilon$ <a href=\"https://bowenone580.github.io/2022/10/27/浅谈-Tarjan-算法/\">浅谈 Tarjan 算法</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/10/03/树上启发式合并/\">树上启发式合并</a></p>\n<p>$\\color{grey}\\varkappa$ 长链剖分</p>\n<p>$\\color{blue}{\\Phi}$ <a href=\"https://bowenone580.github.io/2022/11/22/二分图入门/\">二分图入门</a></p>\n<p>$\\color{red}\\epsilon$ <a href=\"https://bowenone580.github.io/2022/03/07/网络流初步/\">网络流初步</a></p>\n<p>$\\color{blue}{\\Phi}$ <a href=\"https://bowenone580.github.io/2023/02/07/点分治初步/\">点分治初步</a></p>\n<p>$\\color{blue}{\\Phi}$ <a href=\"https://bowenone580.github.io/2023/02/01/线段树优化建图/\">线段树优化建图</a></p>\n<p>$\\color{blue}{\\Phi}$ <a href=\"https://bowenone580.github.io/2023/02/18/2-SAT-问题总结/\">2-SAT 问题总结</a></p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/07/19/浅谈Hash/\">浅谈Hash</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/07/22/浅谈Trie及其应用/\">浅谈Trie及其应用</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/08/07/浅谈AC自动机/\">浅谈AC自动机</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/10/26/字符串/\">字符串（Manacher，KMP，exKMP，后缀数组）</a></p>\n<h2 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h2><p>$\\color{red}\\epsilon$ <a href=\"https://bowenone580.github.io/2022/05/26/对双向搜索的研究/\">对双向搜索的研究</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/10/27/浅谈-01BFS/\">浅谈 01BFS</a></p>\n<p>$\\color{blue}\\Phi$ <a href=\"https://bowenone580.github.io/2022/11/04/CDQ-分治/\">CDQ 分治</a></p>\n<p>$\\color{red}\\epsilon$ <a href=\"https://bowenone580.github.io/2022/11/21/博弈论初步/\">博弈论初步</a></p>\n","tags":["Menu"]},{"title":"卡特兰数","url":"/2021/08/04/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/","content":"<h2 id=\"更新记录\"><a href=\"#更新记录\" class=\"headerlink\" title=\"更新记录\"></a>更新记录</h2><p>2021.9.22 将部分内容替换成了$\\LaTeX$符号。</p>\n<span id=\"more\"></span>  \n<h2 id=\"前置知识\"><a href=\"#前置知识\" class=\"headerlink\" title=\"前置知识\"></a>前置知识</h2><h3 id=\"排列数\"><a href=\"#排列数\" class=\"headerlink\" title=\"排列数\"></a>排列数</h3><p>$A_n^m$ $ = $ $\\frac{n!}{(n-m)!}$ （从$n$个数中选$m$个来排列）</p>\n<p>理解为第一位可以有$n$种选择，第二位有$n-1$种，最后一位（即第$m$位）有$n-m+1$种选择，故为$n$ $\\times$ $(n-1)$ $\\times$ $(n-2)$ $\\times$ … $\\times$ $(n-m+1) = $ $\\frac{n!}{(n-m)!}$。</p>\n<p>全排列为$n!$</p>\n<h3 id=\"组合数\"><a href=\"#组合数\" class=\"headerlink\" title=\"组合数\"></a>组合数</h3><p>$C_n^m$ $=$ $\\frac{n!}{(n-m)!*m!}$  </p>\n<p>理解为将$A_n^m$的所有组合方式表示出来，也就是$m$的全排列，为$m!$，常将$n$与$m$写在一个括号里: $\\binom{m}{n}$  。</p>\n<p>特别说明：$A_n^n = n!$, $C_n^n = 1$。</p>\n<p><del>（写了这么多主要是因为看不懂将C写成括号后的表达方式）</del></p>\n<h2 id=\"卡特兰数的证明\"><a href=\"#卡特兰数的证明\" class=\"headerlink\" title=\"卡特兰数的证明\"></a>卡特兰数的证明</h2><p>首先想一个<strong>简单一点</strong>的问题：  </p>\n<p>你有一个栈，$n$个数，它们每一个都要进行一次入栈和出栈操作，请问共有多少种方式  </p>\n<p>可以将每次入栈操作看作 $+1$，出栈看作 $-1$，容易想到，合法的方案必须满足所有时刻的<strong>前缀和$&gt;=0$</strong>  </p>\n<p>更形象地，将其转移到坐标系上，每次入栈将横坐标 $+1$，每次出栈将纵坐标 $+1$，则所有的合法情况满足<strong>横坐标值$&gt;=$纵坐标值</strong>，所有的不合法情况满足<strong>纵坐标-横坐标$&gt;=1$</strong>，则所有不合法情况和函数$y=x+1$必有大于等于1个交点，考虑将其转化为如下形式：</p>\n<p><img src=\"https://z3.ax1x.com/2021/09/05/hWt7gx.png\" alt=\"\"></p>\n<p>图中实线为不合法操作路径，将其与$y=x+1$相交后的线段关于$y=x+1$对称，得到的最终点是$(n-1,n+1)$，由于所有不合法路径必然经过$y=x+1$，所以不合法的路径的情况转化为了从$0$到$(n-1,n+1)$的路径总数之和，即$\\binom{n-1}{2n}$或$\\binom{n+1}{2n}$。  </p>\n<p>合法路径总数即为全部路径$-$不合法路径，即$\\binom{n}{2n}$-$\\binom{n-1}{2n}$或$\\binom{n}{2n}$-$\\binom{n+1}{2n}$ 。</p>\n<p><img src=\"https://z3.ax1x.com/2021/09/05/hWtHv6.md.png\" alt=\"代码示例\"></p>\n","tags":["Knowledge","组合数学"]},{"title":"博弈论初步","url":"/2022/11/21/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%88%9D%E6%AD%A5/","content":"<h1 id=\"博弈论初步\"><a href=\"#博弈论初步\" class=\"headerlink\" title=\"博弈论初步\"></a>博弈论初步</h1><h2 id=\"枚举型\"><a href=\"#枚举型\" class=\"headerlink\" title=\"枚举型\"></a>枚举型</h2><p><a href=\"https://atcoder.jp/contests/abc354/tasks/abc354_e\">E - Remove Pairs</a></p>\n<p>博弈，首先要明白，何为最优。</p>\n<p>最优，不是一种策略，而是在一种局面下，寻找是否有一次操作后，对手必败的局面，自己只要做出这个操作即可。如果没有，显然自己在这种局面下必败。</p>\n<span id=\"more\"></span>\n<p>于是，寻找最优，就意味着枚举当前局面和下一可能局面。这道题就是如此。</p>\n<p>$0$ 表示移除卡牌，$1$ 表示牌还在场，每次枚举二进制数，表示当前局面，再枚举合法的消去对，找到下一局面。</p>\n<p>转移则需要技巧，我们令 $f[i]$ 表示在 $i$ 局面下，Aoki 能否取胜，则如果下一局面他不能取胜，那他在当前局面便必胜，因为下一次成了对手不能取胜。</p>\n<h2 id=\"Nim-游戏\"><a href=\"#Nim-游戏\" class=\"headerlink\" title=\"Nim 游戏\"></a>Nim 游戏</h2><p><a href=\"https://www.luogu.com.cn/problem/P2197\">P2197 【模板】nim 游戏</a></p>\n<p>最为简单的Nim游戏，貌似并不需要SG函数之类的知识。</p>\n<p>假设第 $i$ 堆有 $x_i$ 个石子，那么先手必败，当且仅当：</p>\n<p>$x_1 \\oplus x_2 \\oplus \\cdots x_n = 0$</p>\n<p>证明很简单：</p>\n<p>（下面的状态，或局面，均指先手面临的）</p>\n<p>首先，在最终状态，即所有石子都被取完时，异或和为 $0$，这时候如果先手拿到，就寄了。</p>\n<p>为了让先手不寄，我们不能到达这个状态。</p>\n<p>假设现在异或和为 $k$，且 $k\\neq 0$，则可以找到 $k$ 的二进制表示下为 $1$ 的最高位，那么我们必然能找到一个 $x_i$，使得它那一位也为 $1$（不然全都是 $0$，也异或不出来这个 $1$）。</p>\n<p>先把 $x_i$ 全部取光，现在这个 $x_i$ 的这一位就是 $0$ 了，也就是说现在的异或和中的这一位为 $0$ 了。</p>\n<p>假设现在异或和为 $k’$，我们的目标是：在刚刚取走的石子中放回一些，使得异或和为 $0$。</p>\n<p>答案很显然：放回 $k’$ 个即可，这时 $x_i = k’$，和原来的 $k’$ 一异或，就是 $0$ 了。</p>\n<p>还没完，我们现在只证明了如果异或和不为 $0$，自己就不会寄，总有能拿的，还要说明为什么异或和为 $0$ 就一定寄了。</p>\n<p>假设当前异或和为 $0$，且不是全 $0$ 的状态，那么我们不论怎么拿，也只相当于改变了一个 $x_i$，而这一变，异或和必然就不为 $0$ 了，对手于是拿到了异或和不为 $0$ 的局面，按照上面的一通操作下来，我们拿到的新局面异或和又是 $0$ 了。注意到每次必然要拿一些石子，且对手一定可以拿石子（异或和不为 $0$ 的性质），于是对手一定是最后一个可以拿石子的人，也就是说，我们必然最终无法拿到石子，会转移到异或和为 $0$ 的局面。</p>\n<p>模板题2：<a href=\"https://www.luogu.com.cn/problem/P1247\">P1247 取火柴游戏</a></p>\n<h3 id=\"变形1\"><a href=\"#变形1\" class=\"headerlink\" title=\"变形1\"></a>变形1</h3><p><a href=\"https://atcoder.jp/contests/abc368/tasks/abc368_f\">F - Dividing Game</a></p>\n<p>每次可以将 $x$ 变为它的一个非 $x$ 约数，想到分解质因数。</p>\n<p>之后，变成一个非 $x$ 约数，就相当于取走某些质因数，等价于取石子游戏。</p>\n<p>要注意从问题的特征思考博弈。</p>\n<h2 id=\"SG-函数\"><a href=\"#SG-函数\" class=\"headerlink\" title=\"SG 函数\"></a>SG 函数</h2><p>留坑。</p>\n<h2 id=\"Wythoff-博弈\"><a href=\"#Wythoff-博弈\" class=\"headerlink\" title=\"Wythoff 博弈\"></a>Wythoff 博弈</h2><p><a href=\"https://www.luogu.com.cn/problem/P2252\">P2252 [SHOI2002]取石子游戏|【模板】威佐夫博弈</a></p>\n<p>有两堆石子，数量分别为 $x_1,x_2$，每次可以取其中一堆任意个，或在两堆中取相同个数的石子，问你先手是否有必胜策略。</p>\n<p>先考虑必败局面：$(0,0)$。这时候必然无法可取，所以谁拿到这个局面，谁就寄了。</p>\n<p>之后，根据前面的定理，能转移到必败局面的都是必胜局面，显然，$(0,k)$，$(k,k)$ 都是必胜局面。</p>\n<p>现在，我们要寻找下一个必败局面，这个局面两个数不能相差为 $0$，也不能为 $0$，发现 $(1,2)$ 好像可以。</p>\n<p>接着，由于 $(1,2)$ 是必败局面，则 $(1+k,2)$，$(1,2+k)$，$(1+k,2+k)$ 都是必败局面。</p>\n<p>也就是说，两个数不能包含 $1$ 或 $2$，也不能相差为 $1$。</p>\n<p>你找找规律，不难发现，下一个必败局面是 $(3,5)$。</p>\n<p>首先，不能是 $0,1,2$，于是只能是 $3$，其次，相差不能是 $0,1$，于是只能是 $2$，$(3,5)$ 就是这样来的。</p>\n<p>我们可以猜测，这样的必败局面具有一个规律：</p>\n<ol>\n<li>其中出现的数都是前面的必败局面中未出现过的。</li>\n<li>当前是第 $k$ 个必败局面时，两数之差为 $k$。</li>\n</ol>\n<p>证明一下这样的局面必然必败。</p>\n<p>有两种情况。</p>\n<ol>\n<li>取完之后，两者差值比之前小，对手只要把这两个数都减去一定值，就可以达到之前的一个必败局面。</li>\n<li>取完之后，两者差值更大了，对手只需取其中较大的一个，将差值减到之前的值，你又面临和之前一样的情况了，由于石头有限，所以你总有一天会转移到第一种情况，也寄了。</li>\n</ol>\n<p>但是，这里的 $x_1,x_2$ 都很大，无法暴力求解，怎么办？</p>\n<p>$\\color{red} 留坑：Beatty 定理的证明。$</p>\n<p>发现这个序列满足 Beatty 数列。</p>\n<p>于是有 $a_n+n = \\alpha n+n=\\beta n$，即 $\\beta = \\alpha +1$。</p>\n<p>带入 Beatty 定理：</p>\n<p>$\\frac{1}{\\alpha}+\\frac{1}{\\alpha+1} = 1$</p>\n<p>解得：$\\alpha = \\frac{\\sqrt 5+1}{2}$，这和黄金分割比相等。</p>\n<p>于是，我们只要判断两个数是否满足这个关系即可。</p>\n","tags":["Knowledge","博弈论"]},{"title":"史上第二简洁的题面 题解","url":"/2022/05/26/%E5%8F%B2%E4%B8%8A%E7%AC%AC%E4%BA%8C%E7%AE%80%E6%B4%81%E7%9A%84%E9%A2%98%E9%9D%A2-%E9%A2%98%E8%A7%A3/","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"742dcb3c9d7d560bf5ff0411ad6722efc2acada99d68ae96c757ce18807625e5\">1400ed4044b03ec1d838481659093c6fd54a042401aa8dea52020a28d27e867b6ffd2e98c0eb7985eeaba020f43eb286e2453f5bb1791c1f9e5c86ad93ce6c6e2772c7df6d524c650341dd4950cc4607a533a8ddaec8af8bc7655066892eb686d11738793d2a88d71547627275386614cf953af2ef6b819bae0b610f8e15a6fbbfbab70fadac3836bd68691baf285a96589374cb3ca92eb70e4a10d070aa5cc57e355a5f2dce37d8e370e5766f1cd72f1ef10f9b03ef9944da8587ea3532b867523d989212255014ab3939290ab292f2a16d48385f147dda8d39e23521623b68a7949a5653e2f0c2c2879684fa0079aef22e5b7709cc75c1670100018b017f3a4ecde98aa9604a9f45b5f1978c622bf1f0ad8f8288f246f70f0a59ecc0c5b8a6033b2a74d75a548bd800cad3f0dceb108f8afc0da411aa4a8f8d73dfdbda7780cbc6aed50544993a3b3d8b75f224a0ce64c174d8ebc3b557fa6a42215d358c9480e0cbc2f08c1e67651a3974abbd1ced4b943daa8fdf9e46d9af98a521916d8adb1018fcc3776862155a40a2a23b959cadb1843a858f6b1ec51f2f6218bc6a2fbcf3eb495defcafe9c9b410cd3984ccb347c4db36496dde3e73ae4aaaf029fba1717e386241438d0fa4e6096538e1e39c2c7d718dd5b149a9ea6471e845bc84292c0e2f5d929509c77a9ad9993df87937d726f01781b1956391925a34eb3f05082e26fd538b31ce7db4db3056e9c9a6261047d29793238dbeb8db251ff7745259677f2b8df5ac4d25e1f88794ac0c6d6bbc3065bc83311c8b2e683d71d43428f22562f60bcbc2afe0676615eaa6da103ce8f5cc33ca672cc33d2ebbb19aa250db27587fa4aaa0f338b482e38854904d03c221c622050b1d0ada643600dad6bd081a31b2a79cce27ff055eae5df594d34354f673b63cb04013ef59142c02e7f4be22c64e77306a819e5c1012ee452843bb664086b692fd8553db7bfe5806e42685cf238dac56c8c2cbb24da96b38be6c64bcad83ef228794cae8b41b9319542a7cfce6c72d410b9dc152f98a21e33995ef8073f3a0ddf674889890ccf9121007b08df4b090b5c96ec15eb64c50206d1b7256e18a10de8960ef594e03adfcfe8666ba8885bbef42040e84f1807d2af068b88605abcbf436040689e3dc644eb2af9f4fb8f60bab7434036f5fec035d5cfc0e1a65debf123cad22aa9ff6be3fe8a4e5839c87d3391de17be165b1d3c72eb264c8c668a4c390bfcb3ed324efa145ea4d0e196c1603f711cf0b7a8f72f8df009a38ba288be04d82caaa44674a2aa97c29a12c9ea9ea21394845c5c5debf57c34dd3543c4d363b02e64f304e658d68306a69b1676db8e254f0e4e843bce24417be1d2f3b230571096fa32a990f2ed0d3cbf37c98ea5e2ef2a9cf65de163e222ee5287bd4b291ffc6d5499a804b06ab64af4eb5734c6eecd5456b76c45fea95916acfd7d6f38ee6d3907826281fbb8de20e7f697e148c422abe4f67b9560c43d73f91970c66423aa35c5659b21bfeb68f7e0acfc4f1f9297a73a6594a93fe7c62d6c914fd052545b1bd33678edc1385e28c57ed85d39cdf8e91c8a62e2c12e763c5982c9c876f847b47ecfa9557960f63fe3c509bac3cbdecbd6eefc894ad358a2d12e7b83beacb876285738c715275e1b181036bfcddd3c7b356d8015ec4fdd69ea61599e9ced1de9e063610eb5598064557659d980bca73125095329273b7178f12ac1e05ae128e1cca01d3cb858d1b1</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">输入我在2022-05-25 18:40:50提交记录的id</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","tags":["Editorial","数论","莫比乌斯反演"]},{"title":"同余","url":"/2022/04/05/%E5%90%8C%E4%BD%99/","content":"<h1 id=\"同余\"><a href=\"#同余\" class=\"headerlink\" title=\"同余\"></a>同余</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>如果两个整数$a,b$除以$m$的余数相等，则称$a,b$模$m$同余，记作$a\\equiv b(\\mod m)$。</p>\n<p>一个在$[0,m-1]$里面的数$a$，它所属的集合$\\{a+km\\}$里面的所有数和$m$同余，则称这个集合为一个模$m$的同余类。</p>\n<p>$1$~$m$中和$m$互质的数代表的同余类共有$\\varphi(m)$个，它们构成$m$的简化剩余系。</p>\n<span id=\"more\"></span>\n<p>结论1：如果$a,b$都属于$m$的简化剩余系，则$a\\cdot b \\mod m$也属于$m$的简化剩余系。</p>\n<p>证明：显然，$a,b$都和$m$互质，则$a\\cdot b \\mod m$一定和$m$互质，必然属于$m$的简化剩余系。</p>\n<h2 id=\"运算\"><a href=\"#运算\" class=\"headerlink\" title=\"运算\"></a>运算</h2><p>模$n$意义下的运算</p>\n<ul>\n<li><p>加法</p>\n<ul>\n<li>$a+b = (a\\mod n+b\\mod n)\\mod n$</li>\n<li>$a\\equiv -b(\\mod n) \\iff a+b \\equiv 0(\\mod n)$（等式两边同时加上一个整数，模意义下等式仍然成立）</li>\n</ul>\n</li>\n<li><p>减法</p>\n<ul>\n<li>$a-b = (a\\mod n-b\\mod n) \\mod n$</li>\n<li>$a\\equiv b(\\mod n) \\iff a-b\\equiv 0(\\mod n)$（等式两边同时减去一个整数，模意义下等式仍然成立）</li>\n</ul>\n</li>\n<li><p>乘法</p>\n<ul>\n<li>$a\\cdot b = (a \\mod n\\cdot b\\mod n)\\mod n$</li>\n<li>$a\\equiv b(\\mod n) \\iff a\\cdot k\\equiv b\\cdot k(\\mod n)$（等式两边同时乘上一个整数，模意义下等式仍然成立）</li>\n</ul>\n</li>\n<li><p>除法</p>\n<ul>\n<li><p>这个后面再说</p>\n</li>\n<li><p>$a\\cdot k\\equiv b\\cdot k(\\mod n) \\iff a\\equiv b(\\mod \\frac{n}{gcd(n,k)})$</p>\n<ul>\n<li><p>证明：$a\\cdot k\\equiv b\\cdot k(\\mod n) \\iff (a-b)\\cdot k\\equiv 0(\\mod n)$。</p>\n<p>感性理解一下，$k$尽全力只能帮助$a-b$拿下$gcd(n,k)$，剩下的$\\frac{n}{gcd(n,k)}$是$a-b$必须要有的，所以$a-b\\equiv 0(\\mod \\frac{n}{gcd(n,k)})$。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>乘方</p>\n<ul>\n<li>$a\\equiv b \\iff a^k\\equiv b^k(\\mod n)$</li>\n<li>证明：设$a = k_1n+r,b = k_2n+r$，则$a^k = k_1\\cdot X+r^k,b^k = k_2\\cdot Y+r^k$，所以原式等价于$r^k\\equiv r^k$，显然成立。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"定理\"><a href=\"#定理\" class=\"headerlink\" title=\"定理\"></a>定理</h2><p><strong>费马小定理：若$p$是质数，则对于任意正整数$a$，有$a^p\\equiv a(\\mod p)$。</strong></p>\n<p><strong>欧拉定理：若正整数$a,n$互质，则$a^{\\varphi(n)}\\equiv 1(\\mod n)$。</strong></p>\n<p>证明：对于$n$的所有互质的数，我们将其从小到达排列为$a_1,a_2,\\cdots,a_{\\varphi(n)}$。</p>\n<p>之后，我们把所有这些数都乘上$a$，得到$aa_1,aa_2,\\cdots,aa_{\\varphi(n)}$，又因为$a,n$互质，所以得到的数都和$n$互质。</p>\n<p>我们再证明这些数组成的集合正好是$n$的简化剩余系：</p>\n<p>如果对于两个不同的$a_i,a_j$来说，$aa_i\\equiv aa_j(\\mod n)$，那么根据上面的运算性质，要么$a\\mid n$，要么$a_i\\equiv a_j(\\mod n)$，然而根据$a,n$互质，第一个不成立，根据我们假设的$a_i\\neq a_j$，第二个也不成立，所以这个集合正好构成$n$的简化剩余系。</p>\n<p>由此，$aa_1\\cdot aa_2\\cdots aa_{\\varphi(n)}\\equiv a_1\\cdot a_2 \\cdots a_{\\varphi(n)}(\\mod n)$，所以$a^{\\varphi(n)}\\equiv 1(\\mod n)$。</p>\n<p>当$n$为质数时，$a^{\\varphi(n)}\\equiv1(\\mod n) = a^{n-1}\\equiv 1(\\mod n) = a^n\\equiv a(\\mod n)$。</p>\n<p>由此，费马小定理成立。</p>\n<h2 id=\"欧拉定理的推论\"><a href=\"#欧拉定理的推论\" class=\"headerlink\" title=\"欧拉定理的推论\"></a>欧拉定理的推论</h2><ol>\n<li><p><strong>若$a,n$互质，则对于任意正整数$b$，有$a^b\\equiv a^{b\\mod \\varphi(n)}(\\mod n)$</strong>。</p>\n<p>证明：</p>\n<p>设$b=k\\cdot \\varphi(n)+r$，则$a^b =  a^{k\\cdot \\varphi(n)+r} = a^{\\varphi(n)^k}\\cdot a^r\\equiv 1^k\\cdot a^r\\equiv a^r$，所以原式仍旧成立。</p>\n</li>\n<li><p><strong>若$a,n$不互质，且对于正整数$b&lt;\\varphi(n)$，有$a^b\\equiv a^b(\\mod n)$</strong>。</p>\n<p>证明：</p>\n<p>显然成立。</p>\n</li>\n<li><p><strong>若$a,n$不互质，且对于正整数$b\\geq \\varphi(n)$，有$a^b\\equiv a^{b\\mod \\varphi(n)+\\varphi(n)}(\\mod n)$</strong>。</p>\n<p>证明：</p>\n<ol>\n<li><p>$a$为质数，且$a\\mid n$。</p>\n<p>设$n=n’a^r$，则$a,n’$一定互质，根据欧拉定理，可得$a^{\\varphi(n’)}\\equiv 1(\\mod n’)$。</p>\n<p>又因为$a^r,n’$互质，所以$\\varphi(n) =\\varphi(n’)\\cdot (a-1)\\cdot a^{r-1}$，即$\\varphi(n’)\\mid \\varphi(n)$。</p>\n<p>所以根据$a^{\\varphi(n’)}\\equiv 1(\\mod n’)$，可以得到$a^{\\varphi(n)}\\equiv 1(\\mod n’)$。</p>\n<p>变换形式，可得$a^{\\varphi(n)} = n’k+1$，即$a^{\\varphi(n)+r} = nk+a^r$。</p>\n<p>所以，$a^{\\varphi(n)+r}\\equiv a^r(\\mod n)$，即$a^{k\\cdot\\varphi(n)+r}\\equiv a^r(\\mod n)$。</p>\n<p>设$b = r+k\\cdot\\varphi(n)+t$，则$a^b = a^{r+k\\cdot\\varphi(n)+t} = a^{r+t}$。</p>\n<p>又因为$t = b-r-k\\cdot\\varphi(n) = (b-r)\\mod \\varphi(n)$，所以$a^b = a^{r+(b-r)\\mod \\varphi(n)}(\\mod n)$。</p>\n</li>\n<li><p>$a$为质数的幂。</p>\n<p>剩下的看不懂了，有兴趣的直接看<a href=\"https://blog.csdn.net/synapse7/article/details/19610361\">三个重要的同余式——威尔逊定理、费马小定理、欧拉定理 + 求幂大法的证明_synapse7的博客</a>。</p>\n</li>\n</ol>\n</li>\n</ol>\n<p>总之，这个式子可以降低幂次，使我们能用快速幂之类的东西简化计算。</p>\n<h2 id=\"扩展欧几里得\"><a href=\"#扩展欧几里得\" class=\"headerlink\" title=\"扩展欧几里得\"></a>扩展欧几里得</h2><p>对于任意整数$a,b$，存在一对整数$x,y$，满足$ax+by = gcd(a,b)$。</p>\n<p>在欧几里得算法的最后一步中，$b=0$，我们可以得到一组解：$a\\cdot1+0\\cdot0 = gcd(a,0)$。</p>\n<p>我们往回导一下，在$b&gt;0$时，$gcd(a,b) = gcd(b,a\\mod b)$，假设存在一对整数$x,y$满足$bx+(a\\mod b)y=gcd(b,a \\mod b)$，则$bx+(a-b\\cdot\\lfloor a/b\\rfloor)y=ay+ b(x-\\lfloor a/b\\rfloor y)$，我们只要令$x’=y,y’=x-\\lfloor a/b\\rfloor y$，就可以求出另一组解，由于当$b=0$时是有解的，所以我们归纳一下，可以得到任意时刻都有解。于是对于任意整数$a,b$，都存在一组整数$x,y$，满足$ax+by = gcd(a,b)$。</p>\n<p>当然，这里求出的仅是一组特解，并不能代表所有的解。</p>\n<p>更一般的，对于$ax+by = c$，方程有解当且仅当$gcd(a,b)\\mid c$，且通解可表示为$x=\\frac{c}{gcd(a,b)}x_0+\\frac{kb}{gcd(a,b)},y = \\frac{c}{gcd(a,b)}y_0-\\frac{ka}{gcd(a,b)}$。其中$x_0,y_0$为$ax+by = gcd(a,b)$的一组特解。</p>\n<p>证明：咕了。</p>\n<h2 id=\"乘法逆元\"><a href=\"#乘法逆元\" class=\"headerlink\" title=\"乘法逆元\"></a>乘法逆元</h2><p>我们回到之前对于运算的处理，我们对加减乘和乘方运算都有较好的处理方式，但是除法中很可能会有小数，这时候再模就不知道是什么东西了，为了将结果限制在整数范围内，我们需要一种特殊的处理方式：乘法逆元。</p>\n<p>若整数$b,m$互质，且$b\\mid a$，则存在一个整数$x$，使得$a/b\\equiv ax(\\mod m)$，称$x$为$b$的模$m$乘法逆元，记为$b^{-1}(\\mod m)$。</p>\n<p>因为$a/b\\equiv a\\cdot b^{-1}\\equiv a/b\\cdot b\\cdot b^{-1}(\\mod m)$，所以根据上面的运算规律，我们可以得到$b\\cdot b^{-1}\\equiv 1(\\mod m)$。</p>\n<p>那么，我们就是要找到$b^{-1}$取啥比较合适。</p>\n<h3 id=\"模质数\"><a href=\"#模质数\" class=\"headerlink\" title=\"模质数\"></a>模质数</h3><p>如果$m$是质数，根据费马小定理，$b^m\\equiv b(\\mod m) \\iff b^{m-1}\\equiv 1(\\mod m) \\iff b\\cdot b^{m-2}\\equiv 1(\\mod m)$，所以$b^{-1} = b^{m-2}$是$b$的乘法逆元。</p>\n<h3 id=\"线性求1-n中所有数的逆元\"><a href=\"#线性求1-n中所有数的逆元\" class=\"headerlink\" title=\"线性求1~n中所有数的逆元\"></a>线性求1~n中所有数的逆元</h3><p>还要说明一点，如果要求$1$~$n$中所有数模质数$p$的逆元，是可以线性求出的。</p>\n<p>具体来说，我们设$p=k\\cdot i+r$，其中$0\\leq r&lt;i$。</p>\n<p>于是，$k\\cdot i+r\\equiv 0(\\mod p)$。</p>\n<p>两边同乘$i^{-1}$和$r^{-1}$，得到$k\\cdot r^{-1}+i^{-1}\\equiv 0(\\mod p)$。</p>\n<p>移项，得$i^{-1}\\equiv -k\\cdot r^{-1}(\\mod p)$，也就是说，$i^{-1}\\equiv -\\lfloor p/i\\rfloor\\cdot(p\\mod i)^{-1}(\\mod p)$，我们用的都是之前已经求出的逆元，可以线性求出所有的逆元。</p>\n<h3 id=\"线性求任意n个数的逆元\"><a href=\"#线性求任意n个数的逆元\" class=\"headerlink\" title=\"线性求任意n个数的逆元\"></a>线性求任意n个数的逆元</h3><p>我们首先求出$n$个数的前缀积，记为$s_i$，之后求出$s_n$的逆元$sv_n$。</p>\n<p>$s_n=\\Pi_{i=1}^na_i$，于是$sv_n=\\Pi_{i=1}^na_i^{-1}$。</p>\n<p>我们从后往前，每次乘上$a_i$，于是得到$s’_i=\\Pi_{j=1}^ia_j^{-1}$，那么$a_i^{-1} = s’_i\\cdot s_{i-1}$。</p>\n<p>这样，我们就用$n+\\log m$的时间求出了任意$n$个数的逆元。</p>\n<h3 id=\"b-m互质\"><a href=\"#b-m互质\" class=\"headerlink\" title=\"b,m互质\"></a>b,m互质</h3><p>如果只保证$b,m$互质，我们需要求解同余方程$bx\\equiv 1(\\mod m)$。</p>\n<p>接下来，我们将讨论如何解决这个问题。</p>\n<h2 id=\"线性同余方程\"><a href=\"#线性同余方程\" class=\"headerlink\" title=\"线性同余方程\"></a>线性同余方程</h2><p>形如$ax\\equiv b(\\mod m)$的方程叫做线性同余方程，因为其未知数$x$的指数为1。</p>\n<p>我们将其变形，得$ax-b\\equiv 0(\\mod m)$，即$ax-b=-ym$。</p>\n<p>移项，得$ax+ym=b$，这个东西可以用扩展欧几里得解决。</p>\n<p>我们先求出$ax+ym = gcd(a,m)$的一组解$x,y$，之后乘$b/gcd(a,m)$，就可以求出这个方程的一个特解$x_0$。</p>\n<p>通解是所有模$m/gcd(a,m)$和$x_0$同余的数，形象一点的说，通解是$x_0\\frac{b}{gcd(a,m)}+\\frac{tm}{gcd(a,m)}$，这里的$t$取遍整个整数集合。</p>\n<h2 id=\"中国剩余定理\"><a href=\"#中国剩余定理\" class=\"headerlink\" title=\"中国剩余定理\"></a>中国剩余定理</h2><p>设$m_1,m_2,\\cdots,m_n$是$n$个两两互质的整数，$m=\\Pi_{i=1}^nm_i$，$M_i = m/m_i$，$t_i$是线性同余方程$M_it_i\\equiv 1(\\mod m_i)$的一个解，则对于任意$n$个整数$a_1,a_2\\cdots a_n$，方程组</p>\n<p>$\\left\\{\\begin{aligned}x\\equiv a_1(\\mod m_1)\\\\x\\equiv a_2(\\mod m_2)\\\\\\cdots\\\\x\\equiv a_n(\\mod m_n)\\end{aligned}\\right.$</p>\n<p>有整数解，解为$x=\\sum_{i=1}^na_iM_it_i$。</p>\n<p>证明：</p>\n<p>对于$M_i\\neq m/m_i$，有$m_i\\mid M_i$，所以$a_iM_it_i\\equiv 0(\\mod m_i)$。</p>\n<p>对于$M_i=m/m_i$，有$M_it_i\\equiv 1(\\mod m_i)$，所以$a_iM_it_i\\equiv a_i(\\mod m_i)$。</p>\n<p>所以这是原方程组的一个特解。</p>\n<p>通解就是$x+km$。</p>\n<p>证明：又咕了。</p>\n<h2 id=\"扩展中国剩余定理\"><a href=\"#扩展中国剩余定理\" class=\"headerlink\" title=\"扩展中国剩余定理\"></a>扩展中国剩余定理</h2><p>虽然刚才的解确实非常妙，但是只有在$m_1,m_2\\cdots,m_n$中所有数两两互质才能使用，这在题目中是非常罕见的限制条件，更多的是随便取一些数，让你解这个方程组，这时候我们应该怎么做呢？</p>\n<p>我们考虑用数学归纳法解决。</p>\n<p>显然，只有$x\\equiv a_1(\\mod m_1)$时，我们可以通过线性同余方程求出一个解，或判断其无解。</p>\n<p>假设现在已经求出了前$k-1$个方程的解$x$，设$m = lcm(m_1,m_2\\cdots m_{k-1})$，则$x+im$是前$k-1$个方程的一个通解，现在要求出一个整数$t$，满足$x+tm\\equiv a_k(\\mod m_k)$，即$tm\\equiv a_k-x(\\mod m_k)$，这可以通过找出这个线性同余方程的一个解得到，或判断其无解。</p>\n<h2 id=\"高次同余方程\"><a href=\"#高次同余方程\" class=\"headerlink\" title=\"高次同余方程\"></a>高次同余方程</h2><h3 id=\"BSGS算法\"><a href=\"#BSGS算法\" class=\"headerlink\" title=\"BSGS算法\"></a>BSGS算法</h3><p>在$a,p$互质时，对于形如$a^x\\equiv b(\\mod p)$之类的问题，我们可以使用BSGS求解。</p>\n<p>这个$x$可以看成$it-j$，其中$t = \\lceil \\sqrt{p}\\rceil$，这里的$i\\in [1,t],j\\in[1,t]$，这样可以取到$[0,p-1]$中的任何一个值。</p>\n<p>为什么不需要取更大的值呢？因为$a,p$互质，所以我们可以使用欧拉定理，$a^{x+\\varphi(p)}\\equiv a^x\\cdot a^{\\varphi(p)}\\equiv a^x\\cdot 1\\equiv a^x(\\mod p)$。</p>\n<p>所以，$x$只要在$[0,p-1]$的范围内就行了。</p>\n<p>对这个式子进行变形，$a^{it-j}\\equiv b \\iff a^{it}\\equiv b\\cdot a^j(\\mod p)$。</p>\n<p>我们从小到大枚举$j$，算出$b\\cdot a^j$的所有取值，当取值相等时，我们用较大的$j$更新，这样可以保证我们得到的是最小非负整数解。</p>\n<p>之后，再从小到大枚举$i$，直接求出$a^{it}$的值，查找是否有对应的$j$，使同余后结果相同，有就直接输出答案。</p>\n<p>这个答案为什么最小？我们考虑极端一点的情况，$it-1&lt;(i+1)t-t$，所以就没啥问题了。</p>\n<p>查找相等的取值好像可以用hash做到$O(1)$，但是我只会用$O(\\log n)$的map。也许以后会再更一下。</p>\n<p>这个方程也有可能无解，就是在枚举完所有的可能之后都没有找出解来。</p>\n<p>这个算法的复杂度优化主要在用map将所有$b\\cdot a^j$的值都存起来，这样我们对于每个$i$，就只用花费$O(\\log n)$的时间进行查找了，于是总复杂度就是$O(\\sqrt{p}\\cdot \\log p)$。这种分割$x$的思想是非常具有启发性的。</p>\n<h3 id=\"扩展BSGS\"><a href=\"#扩展BSGS\" class=\"headerlink\" title=\"扩展BSGS\"></a>扩展BSGS</h3><p>如果只有$a^x\\equiv b(\\mod p)$，不保证$b,p$互质，该如何做呢？</p>\n<p>我们取$d = gcd(a,p)$，将整个方程同时除以$d$，得到$\\frac{a}{d}\\cdot a^{x-1}\\equiv \\frac{b}{d}(\\mod \\frac{p}{d})$。</p>\n<p>为什么可以这样除呢？我们假设原来的方程为$a^x+kp=b$，则整体除$d$，得$\\frac{a}{d}\\cdot a^{x-1}+k\\cdot\\frac{p}{d}=\\frac{b}{d}$，这就相当于把模数也一起除$d$。</p>\n<p>现在，$\\frac{a}{d}$和$\\frac{p}{d}$显然是互质的，于是我们可以用乘法逆元把$\\frac{a}{d}$除过去，得到$a^{x-1}\\equiv \\frac{b}{d}\\cdot (\\frac{a}{d})^{-1}(\\mod \\frac{p}{d})$。</p>\n<p>我们一直这样除下去，设$D = \\Pi_{i=1}^kd_i$，直到左边的$a^{x-k}$和$\\frac{p}{D}$互质，这样我们就可以应用上面的BSGS来解决这个问题了。</p>\n<p>BSGS的时间复杂度为$O(\\sqrt{p}\\cdot\\log p)$，每次求gcd的时间复杂度为$O(\\log p)$，总的复杂度大概就是$O(\\sqrt{p}\\cdot \\log p)$。</p>\n<h2 id=\"阶\"><a href=\"#阶\" class=\"headerlink\" title=\"阶\"></a>阶</h2><p>对于两个互质的数$a,m$而言，$a^x\\equiv 1(\\mod m)$，这个$n$取最小时称作$a$模$m$的阶，记作$\\delta_m(a)$。</p>\n<p>由欧拉定理可得，$a^{\\varphi(m)}\\equiv 1(\\mod m)$，所以在$a,m$互质时，$n$一定存在。</p>\n","tags":["Knowledge","数学"]},{"title":"天体运动","url":"/2024/02/25/%E5%A4%A9%E4%BD%93%E8%BF%90%E5%8A%A8/","content":"<h1 id=\"天体运动\"><a href=\"#天体运动\" class=\"headerlink\" title=\"天体运动\"></a>天体运动</h1><h2 id=\"基本物理量\"><a href=\"#基本物理量\" class=\"headerlink\" title=\"基本物理量\"></a>基本物理量</h2><p>万有引力：$F = \\frac{GMm}{R^2}$。</p>\n<p>结合圆周运动公式，可以推出：</p>\n<p>$\\frac{GM}{R^2} = a = \\frac{v^2}{R} = \\omega^2R = \\frac{4\\pi^2}{T^2}R$​</p>\n<p>我们有一个重要的发现：一个在轨道上运动的物体，它的运动状态只和 $R,M$​ 有关，和这个物体本身无关。</p>\n<span id=\"more\"></span>\n<p>建议不要把 $v,w,T$​​ 的表达式背下来，这样容易错。考场多写一步可以提高正确率。</p>\n<p><strong>一定要注意，这里的 $R$ 都是行星到天体中心的距离，不要和天体半径混淆。</strong></p>\n<p><strong>做题时，如果遇到 $R = kr$ 之类的式子，一定要先用 $R,r$ 表示，最后再把关系带入，这样不容易错。</strong></p>\n<h2 id=\"开普勒三定律\"><a href=\"#开普勒三定律\" class=\"headerlink\" title=\"开普勒三定律\"></a>开普勒三定律</h2><p>第一定律：行星绕太阳运动的轨道是<strong>椭圆</strong>，太阳在椭圆的一个<strong>焦点</strong>上。（做题时一般还是圆）</p>\n<p>第二定律：任何行星在<strong>相同时间内</strong>和太阳的连线扫过的<strong>面积</strong>相等。（面积相等的轨道，周期 $T$ 相同）</p>\n<p><strong>第三定律：所有行星轨道半长轴 $a$ 的三次方和周期 $T$ 的平方的比为定值。</strong></p>\n<p>做题时，最可能用到的是开普勒第三定律，它的数学形式为：$\\frac{a^3}{T^2} = C$（$C$​ 只和中心天体有关）</p>\n<h2 id=\"重要公式\"><a href=\"#重要公式\" class=\"headerlink\" title=\"重要公式\"></a>重要公式</h2><h3 id=\"三个速度\"><a href=\"#三个速度\" class=\"headerlink\" title=\"三个速度\"></a>三个速度</h3><p>第一宇宙速度：卫星的最小发射速度，最大环绕速度，$v_1 = 7.9km/s$。</p>\n<p>第二宇宙速度：卫星挣脱地球引力，离开地球的最小速度，$v_2 = \\sqrt{2}v_1 = 11.2km/s$。</p>\n<p>第三宇宙速度：卫星挣脱太阳引力，离开太阳系的最小速度，$v_3 = 16.7km/s$​。</p>\n<p>三个速度都是卫星发射升空时的速度。</p>\n<p>这里有一个神奇的关系：$v_2 = \\sqrt{2}v_1$，我们会在”能量关系“部分推导。</p>\n<p><strong>一定要把三个速度的具体值记下来，考试时默认你会背的。</strong></p>\n<h3 id=\"黄金代换与天体密度\"><a href=\"#黄金代换与天体密度\" class=\"headerlink\" title=\"黄金代换与天体密度\"></a>黄金代换与天体密度</h3><p>黄金代换：$gR^2 = GM$。在不考虑地球自转时，将基本公式 $\\frac{GM}{R^2} = a$ 中的 $a$ 用 $g$ 代替，$R$ 代入地球半径即可得出此式。</p>\n<h4 id=\"天体密度的计算\"><a href=\"#天体密度的计算\" class=\"headerlink\" title=\"天体密度的计算\"></a>天体密度的计算</h4><p>$\\rho = \\frac{M}{V} = \\frac{M}{\\frac{4}{3}\\pi R^3}$</p>\n<p>主要任务就是求 $M,R$。</p>\n<ol>\n<li><p>利用地上</p>\n<p>如果<strong>知道了地面上的重力加速度 $g$，在知道 $R$ 和 $M$ 中的一个时</strong>，使用黄金代换，即可求得另一个。</p>\n</li>\n<li><p>利用天上</p>\n<p>首先，一个卫星的参数有 $v,\\omega,T,r$，<strong>任意知道其中两个</strong>，就可以推出所有的量，假设我们已知其中两个量，求出了 $T,r$。</p>\n<p>之后，利用 $\\frac{GM}{r^2} = \\frac{4\\pi^2}{T^2}r$，求得 $M = \\frac{4\\pi^2r^3}{GT^2}$。</p>\n<p>如果<strong>知道天体的半径</strong> $R$，即可求得 $\\rho = \\frac{3\\pi^2r^3}{GT^2R^3}$。</p>\n<p>对于近地卫星来说，我们甚至不用知道 $R$，因为 $r = R$，直接求得 $\\rho = \\frac{3\\pi^2}{GT^2}$​。</p>\n</li>\n</ol>\n<h4 id=\"重力加速度的计算\"><a href=\"#重力加速度的计算\" class=\"headerlink\" title=\"重力加速度的计算\"></a>重力加速度的计算</h4><p>$g$ 在整个天体章节中，只在黄金代换中出现，求重力加速度也是求 $M,R$，利用黄金代换，解出 $g$。</p>\n<p>一般来说，$M$ 和 $R$ 都会与卫星有关，拿卫星已知的运动量（$v,\\omega,T$​）推一下即可。</p>\n<h2 id=\"能量关系\"><a href=\"#能量关系\" class=\"headerlink\" title=\"能量关系\"></a>能量关系</h2><p>对于一个质量为 $m$ 的行星，其运行在半径为 $R$ 的轨道上，我们定义其引力势能为 $E_p = -\\frac{GMm}{R}$，零势能点为无穷远点。</p>\n<p>这里的负号很好理解，行星从无穷远点向地球靠近，万有引力做正功，势能减少，就变成负的了。</p>\n<p>要求动能，可以利用 $\\frac{GM}{R^2} = \\frac{v^2}{R}$，求得 $v^2 = \\frac{GM}{R}$，则 $E_k = \\frac{1}{2}mv^2 = \\frac{GMm}{2R}$。</p>\n<p>那么，有一个美妙的关系：$E_p = -2E_k$。</p>\n<p>对于机械能：$E = -E_k = \\frac{1}{2}E_p$。</p>\n<p>而且，$R$ 越大，$E_k$ 越小，$E_p$ 越大，$E$​ 越大。</p>\n<p>现在，我们再来看第一和第二宇宙速度。</p>\n<p>第一宇宙速度，是发射的最小速度，即此速度所需的向心力和万有引力相等 $\\frac{GM}{R^2} = \\frac{v^2}{R}$，得 $v_1 = \\sqrt{\\frac{GM}{R}}$。</p>\n<p>第二宇宙速度，是卫星离开地球的发射速度，即卫星到达最远处的零势能点，动能全部转化为势能，$\\frac{1}{2}mv^2 = \\frac{GMm}{R}$，得 $v_2 = \\sqrt{\\frac{2GM}{R}} = \\sqrt{2}v_1$。</p>\n<h2 id=\"球上和球内\"><a href=\"#球上和球内\" class=\"headerlink\" title=\"球上和球内\"></a>球上和球内</h2><p>近地卫星：轨道半径和地球半径相同的卫星，但地球不提供支持力。</p>\n<p>赤道上物体：在地球表面的”卫星“。</p>\n<p>比较二者，发现 $R$ 相同，那么 $F$ 相同，所以 $v,\\omega,T$ 都相同吗？</p>\n<p>并不是。<strong>在赤道上的物体，受地球自转的影响，万有引力的一部分要用来提供向心力，支持力就小于万有引力</strong>，满足：</p>\n<p>$\\frac{GMm}{R^2}-mg = m\\frac{4\\pi^2}{T^2}R_{自转}$​</p>\n<p><strong>我们常说的重力，其实是万有引力的分力</strong>，也就是这里的 $mg$。</p>\n<p>不过，在地球两极，自转半径 $R_{自转} = 0$，是不存在向心力的，重力等于万有引力。</p>\n<p>由于左边多减了个 $mg$，所以赤道上的物体，$v$ 比近地卫星小。</p>\n<p>同步卫星：$T$ 和赤道上物体的 $T$ 相等。</p>\n<p>要注意的是，同步卫星可以一直停留在一点上方，也可以每 $24h$ 经过同一点。（是否绕赤道转动）</p>\n<p>地下的物体：$mg_地 = \\frac{GMm}{R^3}r$。</p>\n<p><img src=\"https://s2.loli.net/2024/02/25/OHM4yh5I9EVgBsQ.png\" alt=\"image.png\"></p>\n<p>假设物体距离地心为 $r$。</p>\n<p>球壳对球内任意一点作用力都为 $0$，于是可以把 $r$ 以外的部分看成一个巨大的球壳。</p>\n<p>现在，问题转化为求一个半径为 $r$ 的”小地球“的万有引力。</p>\n<p>$\\rho = \\frac{M}{\\frac{4}{3}\\pi R^3}$</p>\n<p>$m = \\rho \\frac{4}{3}\\pi r^3 = \\frac{Mr^3}{R^3}$</p>\n<p>$g地 = \\frac{Gm}{r^2} = \\frac{GMr}{R^3}$</p>\n<h2 id=\"卫星变轨\"><a href=\"#卫星变轨\" class=\"headerlink\" title=\"卫星变轨\"></a>卫星变轨</h2><p>卫星变轨，最重要的就是对过程的分析。</p>\n<p><img src=\"https://s2.loli.net/2024/02/25/xL18JuBkOCYbmor.png\" alt=\"QQ截图20240225183824.png\"></p>\n<p>首先，要脱离现在的轨道，要么加速，要么减速，这里以加速为例，分析其效果。</p>\n<p>$v$ 增大，维持圆周运动所需的向心力 $F_需$ 增大，但万有引力不变，就无法抓住物体，做离心运动。</p>\n<p><img src=\"https://s2.loli.net/2024/02/25/k31Eo2QuvfgiTIR.png\" alt=\"image.png\"></p>\n<p>比如这里，在 $P$ 点从 $1$ 轨道变到 $2$ 轨道就是上述过程，于是在 $P$ 点时的速度 $v_2&gt;v_1$。</p>\n<p>一般来说，加速后，物体会到一个更大的轨道上，我们只需要看轨道的大小，就可以知道是加速还是减速。</p>\n<p>比如在 $Q$ 点从 $2$ 到 $3$ 的变轨，$3$ 的轨道比 $2$ 大，于是应该加速，$v_3&gt;v_2$。</p>\n<p>容易推知，减速就是其反过程。</p>\n<p>但是，这里有一个浅显的问题：如果 $v_2&gt;v_1$，$v_3&gt;v_2$，那么 $v_3&gt;v_1$。但是，圆周轨道应该 $R$ 大 $v$ 小才对啊！</p>\n<p>其实，这里的两个 $v_2$ 并不相等。</p>\n<p>$P$ 处是近地点，势能最小，动能最大，$Q$ 处是远地点，势能大了，动能就小了，于是 $v_P&gt;v_Q$。</p>\n<p>最后，对于 $P,Q$ 两点，受到的万有引力相等，所以加速度 $a$ 相等。但是，由于椭圆轨道不遵循 $F = m\\frac{v^2}{R}$，所以速度 $v$​ 不相等。</p>\n<p>对于轨道的周期 $T$，我们可以用开普勒第三定律分析。</p>\n<p>$a_1&lt;a_2&lt;a_3$，所以 $T_1&lt;T_2&lt;T_3$​。</p>\n<h2 id=\"双星问题\"><a href=\"#双星问题\" class=\"headerlink\" title=\"双星问题\"></a>双星问题</h2><p>两个星球只受彼此间万有引力作用，可以看成都绕某一固定点运动，$\\omega,T$ 相同。</p>\n<p>$\\frac{r_1}{r_2} = \\frac{m_2}{m_1}$</p>\n<p>$T = 2\\pi\\sqrt{\\frac{L^3}{G(m_1+m_2)}},\\omega = \\sqrt{\\frac{G(m_1+m_2)}{L^3}}$</p>\n<p> $\\omega,T$ 的计算，可以类比成绕一个质量为 $m_1+m_2$ 的恒星，做半径为 $L$​ 的运动。</p>\n<h2 id=\"星球瓦解\"><a href=\"#星球瓦解\" class=\"headerlink\" title=\"星球瓦解\"></a>星球瓦解</h2><p>当星球自转越来越快时，星球对赤道上的物体的引力不足以提供向心力时，物体将会 “飘起来”，进一步导致星球瓦解，其临界条件是 $\\frac{GMm}{R^2} = m\\frac{4\\pi^2}{T^2}R$。</p>\n<h2 id=\"物理学史\"><a href=\"#物理学史\" class=\"headerlink\" title=\"物理学史\"></a>物理学史</h2><p>$G$ 是由卡文迪什测出的。</p>\n<p>时间由早到晚：哥白尼（日心说），伽利略，开普勒。</p>\n","tags":["Knowledge","WHK","物理"]},{"title":"字符串","url":"/2022/10/26/%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这个板块很久都没有搞清楚，以至于压根不想做任何含有字符串的题，现在想来，还是要系统的学一遍为好。</p>\n<p><del>然而后缀数组两年后还在无限咕咕咕</del></p>\n<h2 id=\"单模式串匹配\"><a href=\"#单模式串匹配\" class=\"headerlink\" title=\"单模式串匹配\"></a>单模式串匹配</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>问题：找 $s_2$ 在 $s_1$ 中出现的所有位置。</p>\n<p>一般使用 KMP 算法解决。KMP 的思想是对于 $s$ 的每一个前缀，计算最长的即是前缀，又是后缀的串，通过这个在失配时转到下一个可能匹配的地方。</p>\n<p>至于这个计算的过程本身，可以看成 $s_1$ 与 $s_2$ 相等时，所进行的 KMP。</p>\n<span id=\"more\"></span>\n<p>需要注意的有两点：</p>\n<ol>\n<li>模式串自己匹配的时候，KMP 数组的定义是最长的从开头开始的能和它匹配的串的长度，但是这里显然不能自己匹配自己，所以这个串要求非自身，这也是模式串匹配的下标都从 $2$ 开始，且 $f[1] = 0$ 的原因。</li>\n<li>时间复杂度的证明：每次下标移动一位，$j$ 最多增加 $1$，也就意味着 $j$ 能减少的次数最多增加 $1$。这样下来，即使每一位 $j$ 都能增加且后面会减少，时间复杂度也只有 $O(N+M)$​。</li>\n</ol>\n<h3 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h3><p><a href=\"https://www.luogu.com.cn/problem/P3375\">P3375 【模板】KMP</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,nxt[N];</span><br><span class=\"line\"><span class=\"type\">char</span> s1[N],s2[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;(s1+<span class=\"number\">1</span>)&gt;&gt;(s2+<span class=\"number\">1</span>);</span><br><span class=\"line\">\tn = <span class=\"built_in\">strlen</span>(s1+<span class=\"number\">1</span>),m = <span class=\"built_in\">strlen</span>(s2+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tnxt[<span class=\"number\">1</span>] = <span class=\"number\">0</span>; <span class=\"comment\">//此处为强调前文所说第一点 </span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (j &amp;&amp; s2[i]!=s2[j+<span class=\"number\">1</span>]) j = nxt[j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s2[i] == s2[j+<span class=\"number\">1</span>]) j++;</span><br><span class=\"line\">\t\tnxt[i] = j; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tj = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (j &amp;&amp; s1[i]!=s2[j+<span class=\"number\">1</span>]) j = nxt[j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s1[i] == s2[j+<span class=\"number\">1</span>]) j++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j == m)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;i-m+<span class=\"number\">1</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t\tj = nxt[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cout&lt;&lt;nxt[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h3><h4 id=\"最短循环节\"><a href=\"#最短循环节\" class=\"headerlink\" title=\"最短循环节\"></a>最短循环节</h4><p><a href=\"https://www.luogu.com.cn/problem/P4391\">P4391 BOI2009 Radio Transmission</a></p>\n<p>结论：循环节的长度为 $n-nxt[n]$。</p>\n<p>证明看题解就行了，讲的比较清楚，这个结论其实挺常用的。</p>\n<h4 id=\"num-数组\"><a href=\"#num-数组\" class=\"headerlink\" title=\"num 数组\"></a>num 数组</h4><p><a href=\"https://www.luogu.com.cn/problem/P2375\">P2375 NOI2014 动物园</a></p>\n<p>重点在于及时剔除不可能的答案。</p>\n<p>对于一个前缀，它的所有满足前后缀相等的子串的长度分别为 $nxt[i],nxt[nxt[i]],\\cdots$。这个感性理解一下就行了。</p>\n<p>考虑我们求出了 $nxt$ 数组，现在要求 $num$ 数组。如果暴力求解，就是每次跳 $nxt$，枚举答案。</p>\n<p>但是，我们完全不需要让指针 $j$ 大于 $i/2$，因为如果当前能匹配的长度比串的一半大，那么后一位还能用到这次的 $nxt$ 的情况只能是后一位能够匹配，这时 $j+1&gt;(i+1)/2$，显然不合法，所以不需要判断。</p>\n<h4 id=\"所有前缀出现次数\"><a href=\"#所有前缀出现次数\" class=\"headerlink\" title=\"所有前缀出现次数\"></a>所有前缀出现次数</h4><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=3336\">Count the string</a></p>\n<p>题意：求一个串的每一个前缀出现次数之和。</p>\n<p>这道题涉及到 nxt 数组的理解。众所周知，一个前缀的所有前后缀相等的子串构成的集合一定是 $nxt[i],nxt[nxt[i]]\\cdots$。而且这些东西之间是有内在关系的，你可以把它们看成一棵树，即每个 $i$ 都唯一的对应着一个 $nxt[i]$，而在其中某一个节点增加出现次数，相当于它到根节点的路径上的出现次数都增加了。</p>\n<p>既然是树，我们可以先统计每个节点出现的次数，并且仅将自己的贡献向父亲贡献，这样可以做到不重不漏的统计贡献，正确性看上去就挺对的，只不过这个写法需要记清楚，很容易考到。</p>\n<h2 id=\"Manacher-算法\"><a href=\"#Manacher-算法\" class=\"headerlink\" title=\"Manacher 算法\"></a>Manacher 算法</h2><h3 id=\"基本概念-1\"><a href=\"#基本概念-1\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>思想是简单的。</p>\n<p>先对输入的串进行一些改造：在开头添加 ~，以避免越界匹配；在每两个字符中间添加一个 #，让所有回文串的长度变为奇数。</p>\n<p>考虑维护以 $i$ 为中心的最长回文串长度，记为 $p[i]$，记下当前右端点最右的回文串的中心 $mid $ 和右端点 $r$。</p>\n<p>在计算点 $i$ 的最长回文串长度时，根据 $i$ 和 $r$ 的关系可以分为两种情况。</p>\n<ol>\n<li><p>$i\\leq r$。</p>\n<p>这时，我们找到 $i$ 关于 $mid$ 的对称点 $l = mid\\cdot 2-i$，显然我们已经知道 $p[l]$ 的值。又因为以 $mid$ 为中心的串是回文的，所以以 $l$ 为中心的回文串对称过去，直到 $r$ 之前就都是回文的。后面是否回文直接暴力扩展。</p>\n</li>\n<li><p>$i&gt;r$。</p>\n<p>直接暴力扩展，此时，每扩展一次，$r$ 就会增加 $1$，则 $r$ 增加的总次数不超过 $n$ 次。</p>\n</li>\n</ol>\n<p>于是，我们就能在 $O(n)$ 的时间内求出最长回文串的长度了。</p>\n<p>测板子链接：<a href=\"https://www.luogu.com.cn/problem/P3805\">P3805 manacher 算法</a></p>\n<h3 id=\"变式1\"><a href=\"#变式1\" class=\"headerlink\" title=\"变式1\"></a>变式1</h3><p><a href=\"https://www.luogu.com.cn/problem/P3501\">P3501 POI2010 ANT-Antisymmetry</a></p>\n<p>将原串取反，再反过来，等价于前一段和后一段互补，即前一段取反后是回文串，且串长要为偶数。</p>\n<p>转化为求回文串个数。显然只用知道每个位置的最长回文串即可。</p>\n<p>可见，字符串题的重点不在于算法，而在于推性质。</p>\n<h3 id=\"变式2\"><a href=\"#变式2\" class=\"headerlink\" title=\"变式2\"></a>变式2</h3><p><a href=\"https://www.luogu.com.cn/problem/P4555\">P4555 国家集训队 最长双回文串</a></p>\n<p>前方高妙！</p>\n<p>不难想到一种解法：</p>\n<p>先把 $p$ 数组求出来，设 $f[i] = \\lfloor \\frac{p[i]}{2} \\rfloor$，于是如果 $i,j$ 满足是同一个双回文串的中点，那么有 $i+f[i]\\geq j-f[j]-1$。这个东西的两边分别只和 $i,j$ 有关，于是可以计算出所有 $j$ 的值，对于一个固定的点 $i$，就变成了线段树上最值问题。但是这样做稍显复杂。</p>\n<p>不妨转换一下思路，把枚举中点变成枚举断点，显然，如果我们知道每个断点向左右延伸的最大长度，就能求出双回文串的最大长度。</p>\n<p>记点 $i$ 向左右延伸的最大长度为 $L[i],R[i]$。</p>\n<p>首先，根据我们求出的 $p$ 数组，可以得到一些点的 $L$ 和 $R$。这个很好更新。</p>\n<p>然后，这些 $L,R$ 就可以唯一确定所有点的 $L,R$！为什么？因为我们求出了每个点最长的回文串，就相当于求出了所有回文串，只不过需要递推一下。</p>\n<p>$L[i] = L[i-2]-2$</p>\n<p>$R[i] = R[i+2]-2$</p>\n<p>于是，就能在 $O(n)$ 的时间内解决此题了。</p>\n<h3 id=\"变式3\"><a href=\"#变式3\" class=\"headerlink\" title=\"变式3\"></a>变式3</h3><p><a href=\"https://www.luogu.com.cn/problem/P6216\">P6216 回文匹配</a></p>\n<p>KMP 和 Manacher 算法的巧妙结合。</p>\n<p>先看一眼题，发现要求长度为奇数的回文区间，于是我们只用在最前面加一个占位符即可，之后直接跑 manacher。</p>\n<p>又要求 $s2$ 在一个区间内的出现次数。不难发现，我们只要统计 $s2$ 在 $s1$ 中出现的位置，做一个前缀和即可 $O(1)$ 求出。而统计 $s2$ 在 $s1$ 中出现的位置就是 KMP 的经典应用。</p>\n<p>但是，这里需要求出所有回文串中出现的次数，不是一个 $p$ 数组就能解决的。</p>\n<p>观察，可以发现，当回文串的中心在同一位置时，我们慢慢从最长的回文串缩小，则每次长度 $-2$，而求前缀和的左端点右移一位，右端点左移一位，如果把这些东西合到一起，不就是前缀和的前缀和吗！</p>\n<p>于是，对之前求出的前缀和再做一次，即可快速求出最长回文串内的所有子串对答案的贡献。</p>\n<h2 id=\"扩展-KMP\"><a href=\"#扩展-KMP\" class=\"headerlink\" title=\"扩展 KMP\"></a>扩展 KMP</h2><p>这个算法就不是那么好理解了。</p>\n<p>先弄清楚这个算法是干什么的：可以在 $O(n)$ 的时间内求出串 $s1$ 的每一个后缀和 $s2$ 的 LCP（最长公共前缀）长度。</p>\n<p>假设我们现在已经求出了一个 $z$ 数组，代表 $s2$ 的每一个后缀和 $s2$ 的 LCP 长度，答案数组记为 $ext[i]$，代表 $s1$ 以 $i$ 开始的后缀和 $s2$ 的 LCP 长度。</p>\n<p>维护两个值 $l,r$，代表能匹配的 LCP 右端点最大时的右端点和左端点。</p>\n<p>和 Manacher 算法类似，我们分为两种情况：</p>\n<ol>\n<li><p>$i\\leq r$。</p>\n<p>这时，我们知道 $l$~$l+m-1$ 和 $s2$ 中从 $1$ 开始的部分是相等的。所以 $i$~$m-1$ 和 $s2$ 必然也有一段相等的区间。</p>\n<p>而且，我们已经求出了 $z$ 数组，所以可以直接得出 $1$~$z[i-l+1]$ 一定是 $i$ 的 LCP。</p>\n</li>\n<li><p>$i&gt;r$。</p>\n<p>暴力扩展即可，每次扩展的长度只增不减，所以时间复杂度为 $O(n)$。</p>\n</li>\n</ol>\n<p>为什么叫它扩展 KMP 呢？因为求 $z$ 数组的过程和 $ext$ 的过程完全一样！我们只用拿 $s2$ 去匹配一遍就行了。</p>\n<p>推荐博客：<a href=\"https://www.luogu.com.cn/blog/nitubenben/solution-p5410\">题解 P5410 扩展 KMP（Z 函数） - 泥土笨笨 的博客</a></p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>为啥变成练习了呢？因为这两道题都有更简单的解法，用 exKMP 做就当练一下熟练度了。</p>\n<p><a href=\"https://www.luogu.com.cn/problem/CF432D\">Prefixes and Suffixes</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/UVA11475\">Extend to Palindrome</a></p>\n<h2 id=\"后缀数组\"><a href=\"#后缀数组\" class=\"headerlink\" title=\"后缀数组\"></a>后缀数组</h2><p>简称 SA，是学习 SAM 的前置知识。</p>\n<p>需要花费一定时间想通概念，之后就好理解了。</p>\n<p>后缀数组，指 $SA$ 数组，一般存储第 $i$ 小的后缀的位置</p>\n","tags":["Knowledge","字符串"]},{"title":"子集枚举 DP","url":"/2022/11/05/%E5%AD%90%E9%9B%86%E6%9E%9A%E4%B8%BE-DP/","content":"<h1 id=\"子集枚举-DP\"><a href=\"#子集枚举-DP\" class=\"headerlink\" title=\"子集枚举 DP\"></a>子集枚举 DP</h1><h2 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h2><p>给你一个长度为 $2^n$ 的序列，下标从 $0$ 开始，求出一个数组 $f$，满足 $f[j] = \\sum_{i \\&amp; j=i}a[i]$。</p>\n<p>形象一点说，就是枚举二进制数的子集。</p>\n<span id=\"more\"></span>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><h3 id=\"朴素算法\"><a href=\"#朴素算法\" class=\"headerlink\" title=\"朴素算法\"></a>朴素算法</h3><p>显然，我们可以枚举 $i$ 和 $j$，判断是否满足限制，时间复杂度为 $O(4^n)$。</p>\n<h3 id=\"子集枚举\"><a href=\"#子集枚举\" class=\"headerlink\" title=\"子集枚举\"></a>子集枚举</h3><p>有一个专门的算法可以在 $O(3^n)$ 的复杂度内枚举子集。</p>\n<p>算法的思想是这样的：从 $j$ 开始枚举，每次 $-1$ 之后再与 $j$，直到为 $0$。</p>\n<p>证明：</p>\n<ol>\n<li><p>最后一位为 $1$，显然 $-1$ 之后还是 $j$ 的子集，不影响，且它们之间没有任何数，所以不会漏掉。</p>\n</li>\n<li><p>最后一位为 $0$，我们找到最后一位为 $1$ 的位，显然 $-1$ 之后这一位变成 $0$，它之后的所有位都变成 $1$，之后我们再和 $j$ 与一下，这些变成 $1$ 的位中一些位变成了 $0$。</p>\n<p>考虑它和原来的数之间的数有没有可能成为合法的，如果有，则必然有一位为 $1$，而在现在的数上为 $0$，但是现在数上为 $0$ 的位，在 $j$ 上必然为 $0$，所以不合法。</p>\n</li>\n</ol>\n<p>至此，算法的正确性得以证明。</p>\n<p>考虑时间复杂度。</p>\n<p>显然，我们枚举所有数都是合法的，所以问题变为 $0$~$2^n-1$ 中有多少个合法的数。</p>\n<p>$\\sum_{k=1}^{n}\\binom{n}{k}2^k = \\sum_{k=0}^{n}\\binom{n}{k}1^{n-k}\\cdot 2^k = (1+2)^n = 3^n$。</p>\n<h2 id=\"SOSDP\"><a href=\"#SOSDP\" class=\"headerlink\" title=\"SOSDP\"></a>SOSDP</h2><p>这是一个专门的算法，名为子集枚举 DP，可以解决很多枚举子集的问题。</p>\n<p>设 $f[i][j]$ 表示和 $i$ 的第 $j$ 位之前的位相同，后面的位没有要求的数的数量。</p>\n<p>转移很显然，枚举当前的数 $i$，之后从小到大枚举 $j$，如果 $i$ 的第 $j$ 位为 $1$，就从只有 $j-1$ 位相同的地方转移过来，否则从第 $j$ 位为 $0$ 的地方转移。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((i&gt;&gt;j)&amp;<span class=\"number\">1</span>) f[i][j] = f[i][j<span class=\"number\">-1</span>]+f[i^(<span class=\"number\">1</span>&lt;&lt;j)][j<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> f[i][j] = f[i][j<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为什么是对的呢？</p>\n<p>首先，第 $3$~$4$ 行的思想是比较好理解的，显然是正确的。</p>\n<p>我们主要看 $f[i][j-1]$ 和 $f[i\\oplus(1&lt;&lt;j)][j-1]$ 是否是正确的。</p>\n<p>如果 $f[i][j]$ 求出来的是正确的，那么显然 $f[i][j-1]$ 也是正确的。</p>\n<p>$i\\oplus (1&lt;&lt;j)$ 是小于 $i$ 的，所以 $f[i\\oplus(1&lt;&lt;j)][j-1]$ 已经被求出，那么它也是正确的。</p>\n<p>于是归纳一下，$f[i][j]$ 就是正确的了。</p>\n<p>SOSDP 还有另一种理解方式：高维前缀和。</p>\n<p>大家都知道一维前缀和怎么做吧，就是每一个数加上它前面求出的前缀和。</p>\n<p>二维前缀和的一般做法是容斥，但是也可以不用容斥做，我们枚举当前做前缀和的维度，仅对这个维度做一维前缀和，最后得到的也是二维前缀和。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++) a[i][j]+=a[i][j<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) a[i][j]+=a[i<span class=\"number\">-1</span>][j];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>依次类推，我们可以得到 $n$ 维前缀和的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;n);j++) <span class=\"keyword\">if</span> ((j&gt;&gt;i)&amp;<span class=\"number\">1</span>) f[j]+=f[j^(<span class=\"number\">1</span>&lt;&lt;i)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们把每一个数看作高维空间内的一个点，坐标为那一位的二进制数，于是求子集问题可以转化为求高维前缀和。</p>\n<p>时间复杂度为 $O(n\\log n)$，但是时间复杂度依维度的多少和状态的多少而定，有时候不是一个固定值。</p>\n<p>这样的好处是可以节省空间，而且代码很短，非常建议大家这样写。</p>\n<h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><p> <a href=\"https://www.luogu.com.cn/problem/P5495\">P5495 Dirichlet 前缀和</a> </p>\n<p>给你一个序列 $a$，求序列 $b$，满足 $b_i = \\sum_{j|i}a_j$。</p>\n<p>首先，考虑一个数能从哪里转移过来。</p>\n<p>假设 $i = \\prod p_i^{c_i}$，则能转移过来的数必然满足所有的 $c’_i&lt;=c_i$。</p>\n<p>我们将这个数看成高维空间内的一个点，每个维度以 $c_i$ 作为坐标，则能转移过来的点就是高维空间内的前缀和。</p>\n<p>但是，如果真的把每个维度都开一维数组，空间就爆炸了，不过好在每一个数代表的坐标都是独一无二的，所以我们直接以每一个数作为下标，就相当于完成了离散化的过程。</p>\n<p>我们枚举当前求的维度 $i$，把每个数向它的 $prime[i]$ 倍转移，根据上面的高维前缀和算法，可以得知我们求的是对的。</p>\n<p>值得注意的是，这道题的时间复杂度为 $O(n\\log \\log n)$，和埃氏筛的时间复杂度类似。</p>\n<h2 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h2><p><a href=\"https://www.luogu.com.cn/problem/CF165E\">Compatible Numbers</a></p>\n<p>对于每一个 $a_i$ 都要求出和它与起来为 $0$ 的数。</p>\n<p>也就是说，$a_i$ 和 $a_j$ 没有都为 $1$ 的位。</p>\n<p>这个限制不好处理，因为是存在性问题，我们把它变成一个子集问题。</p>\n<p>取 $a_i$ 的补集，就相当于 $a_j$ 是它的子集，这可以用高维前缀和做，只不过维护的和变成了数。</p>\n<h2 id=\"例3\"><a href=\"#例3\" class=\"headerlink\" title=\"例3\"></a>例3</h2><p><a href=\"https://www.luogu.com.cn/problem/AT_arc100_c\">[ARC100E] Or Plus Max</a></p>\n<p>两次转化。</p>\n<p>$i\\or j\\leq k$ 可以转化为 $i\\or j = k$，之后做前缀 max。</p>\n<p>发现这玩意也不好求，再次转化，发现只要 $i,j$ 都是 $k$ 的子集即可，显然所有 $i\\or j = k$ 的都被包含了，剩下的都是 $&lt;k$ 的，也不错。</p>\n<p>于是维护最大值和次大值，做一遍高维前缀和就做完了。</p>\n<h2 id=\"例4\"><a href=\"#例4\" class=\"headerlink\" title=\"例4\"></a>例4</h2><p><a href=\"https://www.luogu.com.cn/problem/CF1208F\">Bits And Pieces</a></p>\n<p>题目很妙。</p>\n<p>我们发现，与运算的限制性比或更强，也就是说，可以考虑这个 $a_i$，因为它是或运算的参与者，而且它是直接的，不像后面两个数还要算一遍。</p>\n<p>对于 $a_i$，它为 $1$ 的所有位都贡献过了，于是我们不需要 $a_j\\and a_k$ 中出现这些位。</p>\n<p>考虑这些 $a_i$ 中没有的位，它们的获得是存在优先级的，显然越高的位，我们越希望获得，于是可以从高到低枚举每一位，看是否能获得。</p>\n<p>现在，问题转化为求一个数，它是 $a_j\\and a_k$ 的子集，并且 $j&gt;i$，也就是求这个数的超集。</p>\n<p>我们把这个问题形象化，放到高维空间内，就相当于求每个数的高维后缀中下标最大的两个数。</p>\n<p>和高维前缀和类似，我们可以将维护的信息改为最大和次大的下标，并且顺序变为从 $n$ 到 $1$。</p>\n<p>这道题最重要的是发现贪心性质，转化为超集问题。</p>\n<h2 id=\"例5\"><a href=\"#例5\" class=\"headerlink\" title=\"例5\"></a>例5</h2><p><a href=\"https://www.luogu.com.cn/problem/CF383E\">Vowels</a></p>\n<p>发现，对于一个单词，只要其中有一个元音字母即可。</p>\n<p>于是，可以先贡献到每个元音字母单独组成的集合中。</p>\n<p>但是，这样会有重复，怎么办？</p>\n<p>由于单词长度只有 $3$，可以直接容斥，把两个字母都包含的 $-1$，三个字母都包含的 $+1$ 即可。</p>\n<p>还有一种更简单的方法：</p>\n<p>考虑每个单词的补集，显然它在补集的所有子集中都是不合法的。</p>\n<p>于是，我们可以对每一种集合，求出它不合法的串的个数，于是就能求出答案了。</p>\n<h2 id=\"例6\"><a href=\"#例6\" class=\"headerlink\" title=\"例6\"></a>例6</h2><p><a href=\"https://www.luogu.com.cn/problem/CF449D\">Jzzhu and Numbers</a></p>\n<p>可以说是最妙的题了。</p>\n<p>由于题目没有限制这个集合的大小，所以不能从大小入手，每次加一个数啥的。</p>\n<p>既然不能从本身入手，我们从答案入手。</p>\n<p>显然，最终的答案是结果中有 $0$ 个 $1$ 的。</p>\n<p>但是，这个限制太强了，根本做不了，<del>于是想到容斥</del>?</p>\n<p>考虑设 $g[i]$ 表示结果里面有 $\\geq i$ 个 $1$ 的集合总数是多少，这样描述可能不是很准确，但是大概是这个意思。</p>\n<p>于是，可以得到容斥式子：$ans = g[0]-g[1]+g[2]\\cdots$。至于为什么不能直接 $g[0]-g[1]$，之后再说。</p>\n<p>既然只需要大于等于 $i$ 个，那么我们可以算出一个数 $x$，它的超集的大小，即所有满足 $a[i]\\and x = x$ 的数的数量。</p>\n<p>现在，枚举每一个 $x$，如果它有 $k$ 个 $1$，那么就可以向 $g[k]$ 贡献，因为它里面的所有数都可选可不选，所以贡献为 $2^k-1$，毕竟题目要求集合大小不为 $0$。</p>\n<p>那么，你可能会想当然的根据定义说答案就是 $g[0]-g[1]$，但是这是错误的。</p>\n<p>$g[0]$ 显然没有啥问题，就是 $2^n-1$。</p>\n<p>$g[1]$ 里面，比方说$3\\ 3$，它们即可以贡献到 $1$，又可以贡献到 $2$，而 $1$ 和 $2$ 在二进制中都只有一个 $1$，全部贡献到了 $g[1]$ 中，这就是为什么我们不好给这个 $g$ 下定义的原因，因为它本身就包含重复！</p>\n<p>但是，容斥原理恰巧帮助我们解决了这个问题，因为重复的集合只可能是某些位上都是 $1$ 的，所以我们在更后的 $g$ 中将它减掉即可，这和 Venn 图很类似。</p>\n","tags":["Knowledge","DP","SOSDP"]},{"title":"实验题必备知识","url":"/2023/09/17/%E5%AE%9E%E9%AA%8C%E9%A2%98%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86/","content":"<h1 id=\"实验题必备知识\"><a href=\"#实验题必备知识\" class=\"headerlink\" title=\"实验题必备知识\"></a>实验题必备知识</h1><ul>\n<li><p>各种馏：</p>\n<ul>\n<li><strong>蒸馏</strong>是利用物质沸点差异，通过加热使<strong>一种物质</strong>被分离出来的过程，分离的物质一般较纯。</li>\n<li><strong>分馏</strong>的原理与蒸馏相同，但是由于有些物质沸点很接近，所以分出来的是<strong>多种物质</strong>，即混合物，一般不是很纯。</li>\n<li><strong>精馏</strong>是对分馏出来的液体进行更精确的温度控制和各种处理，使不同物质彼此分开，得到较纯的单种物质。</li>\n<li>分馏与精馏都有多次汽化和冷凝过程。</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n<ul>\n<li><p>萃取</p>\n<ul>\n<li>萃取振荡时，要不是打开分液漏斗口放气，防止压强过大。</li>\n<li>萃取振荡时，分液漏斗下口应朝上，因为分液漏斗上面的容积较大，倒过来后能使液体在上面充分接触。</li>\n</ul>\n</li>\n<li><p><img src=\"https://s2.loli.net/2023/08/08/n5ZurJyazP9eNgl.png\" alt=\"实验1\"></p>\n<p>坩埚一般是固体，蒸发皿是液体，泥三角是放坩埚的支架。</p>\n<p>启普发生器用于固体颗粒和液体反应。</p>\n</li>\n<li><p><img src=\"https://s2.loli.net/2023/09/17/ZYEsA79rd8xfez3.png\" alt=\"640\"></p>\n</li>\n<li><p>灼烧温度在 $500$~$1000$ 度之间，属于高温范围，一般用于除去结晶水，分解或除去挥发性物质。</p>\n<p>煅烧温度在 $1200$ 度以上，属于高温范围，一般用于热分解物质。</p>\n<p>焙烧温度在 $900$~$1100$ 度之间，属于高温范围，常见的例子是分解石灰石。</p>\n</li>\n</ul>\n","tags":["化学","文化课"]},{"title":"对双向搜索的研究","url":"/2022/05/26/%E5%AF%B9%E5%8F%8C%E5%90%91%E6%90%9C%E7%B4%A2%E7%9A%84%E7%A0%94%E7%A9%B6/","content":"<h1 id=\"对双向搜索的研究\"><a href=\"#对双向搜索的研究\" class=\"headerlink\" title=\"对双向搜索的研究\"></a>对双向搜索的研究</h1><p>其实这个东西叫Meet in the middle。</p>\n<p>简而言之，就是从两边开始搜，最后搜到最终的结果就停止。</p>\n<p>具体流程如下：从起点和终点分别搜索，比对搜索的结果，取相交的部分即为连接起点和终点的答案。</p>\n<span id=\"more\"></span>\n<p>例题：<a href=\"https://www.luogu.com.cn/problem/P8187\">P8187 USACO22FEB Robot Instructions S</a> 。</p>\n<p>搜索可以到达的点的过程就是暴力，时间复杂度为$ O( 2^{n/2+1} ) $，主要的复杂度瓶颈在于合并搜索的结果。</p>\n<p>这里我用了一个比较复杂的排序，对排完序的数组寻找有没有符合条件的，时间复杂度卡的比较紧。对于那些想用map/unordered_map做的人，我在这里提醒一下：过不了！</p>\n<p>还有人用双指针写的，也可以通过。</p>\n<p>这类问题最难的地方就在于合并结果。</p>\n<h2 id=\"双向搜索可以用在哪里？\"><a href=\"#双向搜索可以用在哪里？\" class=\"headerlink\" title=\"双向搜索可以用在哪里？\"></a>双向搜索可以用在哪里？</h2><p>所有把暴力的指数减半，能够通过的题目都可以试试，只要合并结果不构成瓶颈就可以用。</p>\n<p>而且，双向搜索必须用在有起点，有终点，中间状态好表示，可合并的题目上。</p>\n<h2 id=\"常用的合并思想有哪些？\"><a href=\"#常用的合并思想有哪些？\" class=\"headerlink\" title=\"常用的合并思想有哪些？\"></a>常用的合并思想有哪些？</h2>","tags":["Knowledge","搜索","双向搜索"]},{"title":"对拓扑排序的研究","url":"/2022/05/26/%E5%AF%B9%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E7%A0%94%E7%A9%B6/","content":"<h1 id=\"对拓扑排序的研究\"><a href=\"#对拓扑排序的研究\" class=\"headerlink\" title=\"对拓扑排序的研究\"></a>对拓扑排序的研究</h1><h2 id=\"拓扑排序是什么？\"><a href=\"#拓扑排序是什么？\" class=\"headerlink\" title=\"拓扑排序是什么？\"></a>拓扑排序是什么？</h2><p>简而言之，每次选择一个入度为 $ 0 $ 的点，遍历其所有出边，更新出边到达的点的入度，这样一直进行下去，直到所有点的入度都变成 $ 0 $ 。</p>\n<span id=\"more\"></span>\n<h2 id=\"任何图都能拓扑排序吗？\"><a href=\"#任何图都能拓扑排序吗？\" class=\"headerlink\" title=\"任何图都能拓扑排序吗？\"></a>任何图都能拓扑排序吗？</h2><p>并不是。拓扑排序只能用在DAG（有向无环图）中，如果有环，那么必然有一些点的入度永远无法变成 $ 0 $ ，所以无法进行拓扑排序。</p>\n<h2 id=\"拓扑排序的时间复杂度是多少？\"><a href=\"#拓扑排序的时间复杂度是多少？\" class=\"headerlink\" title=\"拓扑排序的时间复杂度是多少？\"></a>拓扑排序的时间复杂度是多少？</h2><p>先要取出所有入度为 $ 0 $ 的点，花费 $ O(n) $ 的时间，之后要遍历所有边，花费 $ O(m) $ 的时间，所以总时间复杂度为 $ O(n+m) $ 。</p>\n<h2 id=\"拓扑排序能用来干什么？\"><a href=\"#拓扑排序能用来干什么？\" class=\"headerlink\" title=\"拓扑排序能用来干什么？\"></a>拓扑排序能用来干什么？</h2><h3 id=\"1-判断图中是否有环\"><a href=\"#1-判断图中是否有环\" class=\"headerlink\" title=\"1. 判断图中是否有环\"></a>1. 判断图中是否有环</h3><p>上面提到对存在环的图进行拓扑排序无法遍历到所有点，所以可以通过是否能够遍历到所有点来判断图中是否有环。</p>\n<h3 id=\"2-找出图中的最长路\"><a href=\"#2-找出图中的最长路\" class=\"headerlink\" title=\"2. 找出图中的最长路\"></a>2. 找出图中的最长路</h3><p>例题： <a href=\"https://www.luogu.com.cn/problem/P1807\">P1807 最长路</a> 。</p>\n<p>每次从入度为 $ 0 $ 的点更新出边所到的点的最长路，最后取其中的最大值即可。</p>\n<h3 id=\"3-约束条件\"><a href=\"#3-约束条件\" class=\"headerlink\" title=\"3. 约束条件\"></a>3. 约束条件</h3><p>例题： <a href=\"https://www.luogu.com.cn/problem/P1983\">P1983 车站分级</a> 。</p>\n<p>要约束不同车站间的层级大小关系，这个大小关系显然是个 DAG ，我们将所有入度为 $ 0 $ 的点的层级设为 $ 1 $ ，每次连边代表所到的点的层级至少比这个点大 $ 1 $ ，由于我们使用了拓扑序，可以保证当前点的层级是满足所有条件的最小的一个，最后取所有点的层级中最大的一个即可。</p>\n<p>练习： <a href=\"https://www.luogu.com.cn/problem/P1347\">P1347 排序</a> 。</p>\n<p>综合判环和约束的题： <a href=\"https://www.luogu.com.cn/problem/P3243\">P3243 菜肴制作</a> 。</p>\n","tags":["Knowledge","图论","拓扑排序"]},{"title":"奶牛电话网 题解","url":"/2022/10/23/%E5%A5%B6%E7%89%9B%E7%94%B5%E8%AF%9D%E7%BD%91-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"奶牛电话网-题解\"><a href=\"#奶牛电话网-题解\" class=\"headerlink\" title=\"奶牛电话网 题解\"></a>奶牛电话网 题解</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>选择一个点，可以影响到所有的儿子节点和它的父亲。</p>\n<p>考虑一个点选或不选的情况：</p>\n<ol>\n<li>儿子中有点没有被选择，自己选了就行。</li>\n<li>儿子中所有点都可以覆盖，则自己选择只会影响到父亲的抉择。</li>\n</ol>\n<span id=\"more\"></span>\n<p>设 $f[i][0/1/2]$ 表示点 $i$ 是不合法，还是合法但未被选择，还是被选择。</p>\n<p>如果当前点不合法，显然儿子都要合法，且未被选择，即从 $f[v][1]$ 转移。</p>\n<p>如果当前点合法且未被选择，那么儿子中一定要有合法且被选择的，即至少要有一个 $f[v][2]$。</p>\n<p>如何维护？</p>\n<p>首先，儿子要么是 $f[v][1]$ 或 $f[v][2]$，这样才能保证子树是合法的。</p>\n<p>先贪心的选，选择 $\\min(f[v][1],f[v][2])$。</p>\n<p>之后，钦定一个儿子，让它变成 $f[v][2]$，更新答案。</p>\n<p>如果当前点合法且被选择，那么儿子随便选即可。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,head[N],tot;</span><br><span class=\"line\"><span class=\"type\">int</span> f[N][<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v,tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tf[u][<span class=\"number\">2</span>] = <span class=\"number\">1</span>,f[u][<span class=\"number\">1</span>] = <span class=\"number\">0x3f3f3f</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t\tf[u][<span class=\"number\">0</span>]+=f[v][<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tf[u][<span class=\"number\">0</span>] = <span class=\"built_in\">min</span>(f[u][<span class=\"number\">0</span>],<span class=\"number\">0x3f3f3f3f</span>);</span><br><span class=\"line\">\t\tf[u][<span class=\"number\">2</span>]+=<span class=\"built_in\">min</span>(f[v][<span class=\"number\">0</span>],<span class=\"built_in\">min</span>(f[v][<span class=\"number\">1</span>],f[v][<span class=\"number\">2</span>]));</span><br><span class=\"line\">\t\ttmp+=<span class=\"built_in\">min</span>(f[v][<span class=\"number\">1</span>],f[v][<span class=\"number\">2</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tf[u][<span class=\"number\">1</span>] = <span class=\"built_in\">min</span>(f[u][<span class=\"number\">1</span>],tmp-<span class=\"built_in\">min</span>(f[v][<span class=\"number\">1</span>],f[v][<span class=\"number\">2</span>])+f[v][<span class=\"number\">2</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y),<span class=\"built_in\">add</span>(y,x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"built_in\">min</span>(f[<span class=\"number\">1</span>][<span class=\"number\">1</span>],f[<span class=\"number\">1</span>][<span class=\"number\">2</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","动态规划","树形dp"]},{"title":"对杜教筛的研究","url":"/2022/06/20/%E5%AF%B9%E6%9D%9C%E6%95%99%E7%AD%9B%E7%9A%84%E7%A0%94%E7%A9%B6/","content":"<h1 id=\"对杜教筛的研究\"><a href=\"#对杜教筛的研究\" class=\"headerlink\" title=\"对杜教筛的研究\"></a>对杜教筛的研究</h1><h2 id=\"更新记录\"><a href=\"#更新记录\" class=\"headerlink\" title=\"更新记录\"></a>更新记录</h2><p>2022.6.20 修缮了部分文本，加深认识。</p>\n<h2 id=\"狄利克雷卷积\"><a href=\"#狄利克雷卷积\" class=\"headerlink\" title=\"狄利克雷卷积\"></a>狄利克雷卷积</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>$(f*g)(n) = \\sum_{d|n}f(d)g(\\frac{n}{d})$</p>\n<p>这里的 $f$ 和 $g$ 并没有特殊限制，只要求是数论函数就够了，其中 $*$ 代表卷积，以和乘法区别开。</p>\n<span id=\"more\"></span>\n<p>（它和莫比乌斯反演的形式很相似，<del>因为莫比乌斯反演本质就是狄利克雷卷积</del>）</p>\n<h3 id=\"积性函数\"><a href=\"#积性函数\" class=\"headerlink\" title=\"积性函数\"></a>积性函数</h3><p>对于函数 $f(x)$，如果满足对于任意<strong>互质的数</strong> $a$、$b$，都有 $f(ab) = f(a)\\cdot f(b)$，那么就称 $f(x)$ 为积性函数。</p>\n<p>对于函数 $f(x)$，如果对于<strong>任意两个数</strong> $a$、$b$，都有 $f(ab) = f(a) \\cdot f(b)$，那么就称 $f(x)$ 为完全积性函数。</p>\n<p><strong>1和任何数都互质</strong>。</p>\n<h3 id=\"常见的积性函数\"><a href=\"#常见的积性函数\" class=\"headerlink\" title=\"常见的积性函数\"></a>常见的积性函数</h3><p>$\\mu$、$\\varphi$、$d$、$\\sigma$</p>\n<p>这里的 $\\mu$ 是莫比乌斯函数，$\\varphi$ 是欧拉函数，它们定义应该都耳熟能详了。</p>\n<p>这里的 $d(x) = \\sum_{i|x}1$，即数 $x$ 的约数个数。</p>\n<p>这里的 $\\sigma(x) = \\sum_{i|x}i$，即数 $x$ 的约数和。</p>\n<p>当 $x = 1$ 时，这四个函数的值都是 $1$。</p>\n<p><strong>注：以下内容和之后的东西相关，虽然看上去很显然，但是它们也是杜教筛时间复杂度的基础之一。</strong></p>\n<p>我们思考一下它们的前缀和的预处理速度：</p>\n<p>$\\mu$ 和 $\\varphi$ 都可以被线性筛 $O(n)$ 筛出，求前缀和后总时间复杂度为 $O(n)$。</p>\n<p>$d$ 可以用整除分块 $O(\\sqrt n)$ 筛出其前缀和。（只能筛前缀和）</p>\n<p>$\\sigma$ 可以用整除分块 $O(\\sqrt n)$ 筛出前缀和。（只能筛前缀和）</p>\n<p>可以做以下题目加深了解：</p>\n<p> <a href=\"https://www.luogu.com.cn/problem/P2424\">P2424 约数和</a> </p>\n<p> <a href=\"https://www.luogu.com.cn/problem/P3935\">P3935 Calculating</a> </p>\n<h3 id=\"常见的完全积性函数\"><a href=\"#常见的完全积性函数\" class=\"headerlink\" title=\"常见的完全积性函数\"></a>常见的完全积性函数</h3><p>$\\epsilon$、$I$、$id$</p>\n<p>这里的 $\\epsilon(x) = [x = 1]$，$I(x) = 1$，$id(x) = x$。</p>\n<p><strong>像上面一样，思考一下筛出前缀和的速度。</strong></p>\n<p>$\\epsilon(x)$ 的前缀和是 $1$。</p>\n<p>$I(x)$ 的前缀和是 $x$。</p>\n<p>$id(x)$ 的前缀和是 $1+2+\\cdots +x = \\frac{x\\cdot (1+x)}{2}$。</p>\n<p>它们的前缀和都可以 $O(1)$ 求解。</p>\n<h3 id=\"常见的式子\"><a href=\"#常见的式子\" class=\"headerlink\" title=\"常见的式子\"></a>常见的式子</h3><h4 id=\"式子1\"><a href=\"#式子1\" class=\"headerlink\" title=\"式子1\"></a>式子1</h4><p>$\\mu*I = \\epsilon$</p>\n<p>这个东西在我写的莫比乌斯反演的博客里以另一种形式出现，当时已经证过一遍，如果会证的可以跳到式子2。</p>\n<h5 id=\"证明：\"><a href=\"#证明：\" class=\"headerlink\" title=\"证明：\"></a>证明：</h5><p>上面的式子可化为 $[x = 1] = \\sum_{d|x}\\mu(d)I(\\frac{x}{d})$。</p>\n<p>根据 $I$ 函数的定义，去掉它：</p>\n<p>$[x = 1] = \\sum_{d|x}\\mu(d)$</p>\n<p>当 $x = 1$ 时，右边只有 $d = 1$，根据 $\\mu$ 函数的定义，右边为 $1$。</p>\n<p>当 $x\\neq 1$ 时，考虑 $x$ 的质因数分解：</p>\n<p>$x = p_1^{c_1}\\cdot p_2^{c_2}\\cdots p_k^{c_k}$</p>\n<p>设 $x’ = p_1\\cdot p_2\\cdots p_k$。</p>\n<p>所有包含指数大于等于 $2$ 的质因数的 $\\mu$ 都是 $0$，所以可以把这些数舍去：</p>\n<p>$\\sum_{d|x}\\mu(d)\\iff \\sum_{d|x’}\\mu(d)$</p>\n<p>枚举 $d$ 包含的质因子个数，假设有 $q$ 个，就相当与从 $k$ 个质因子里面选出 $q$ 个的方案数，即为 $C_{k}^q$，于是可化为：</p>\n<p>$\\sum_{q=0}^{k}C_k^q(-1)^q$</p>\n<p>再看看二项式定理：</p>\n<p>$(a+b)^k = \\sum_{i=0}^kC_k^ia^ib^{k-i}$</p>\n<p>我们根据它把上面的式子补全：</p>\n<p>$\\sum_{q=0}^kC_k^q(-1)^q1^{k-q} = ((-1)+1)^k = 0$</p>\n<p>得证。</p>\n<p>这个式子还有一个更广为人知的形式：</p>\n<p>$[\\gcd(i,j) = 1] = \\sum_{d|\\gcd(i,j)}\\mu(d)$</p>\n<h4 id=\"式子2\"><a href=\"#式子2\" class=\"headerlink\" title=\"式子2\"></a>式子2</h4><p>$\\varphi*I = id$</p>\n<h5 id=\"证明：-1\"><a href=\"#证明：-1\" class=\"headerlink\" title=\"证明：\"></a>证明：</h5><p>先把式子化开：</p>\n<p>$\\sum_{d|x}\\varphi(d)I(\\frac{x}{d}) = x$</p>\n<p>$\\sum_{d|x}\\varphi(d) = x$</p>\n<p>将 $x$ 分解质因数：</p>\n<p>$x = p_1^{c_1}\\cdot p_2^{c_2}\\cdots p_k^{c_k}$</p>\n<p>由于 $\\varphi$ 是积性函数，所以可以将式子化为下面的形式：</p>\n<p>$\\sum_{i=0}^{c_1}\\varphi(p_1^{i})\\sum_{j=0}^{c_2}\\varphi(p_2^j)\\cdots \\sum_{q=0}^{c_k}\\varphi(p_k^q) = x$</p>\n<p>于是，设 $x’ = p^{c}$，要证的东西变成了下面的这个：</p>\n<p>$\\sum_{i=0}^{c}\\varphi(p^i) = x’$</p>\n<p>发现，它们都只有一个质因数 $p$，所以直接套欧拉函数定义式求值：</p>\n<p>$1+p\\cdot \\frac{p-1}{p}+p^2\\cdot \\frac{p-1}{p}+\\cdots +p^{c}\\cdot \\frac{p-1}{p}$</p>\n<p>化简：</p>\n<p>$1+(p-1)\\cdot (1+p+p^2+p^{c-1})$</p>\n<p>等比数列求和：</p>\n<p>$1+(p-1)\\cdot \\frac{p^{c}-1}{p-1} = p^c$</p>\n<p>得证。</p>\n<p>这个式子比较常用的是上面打开之后的形式，经常在中间的转化中出现。</p>\n<h4 id=\"式子3\"><a href=\"#式子3\" class=\"headerlink\" title=\"式子3\"></a>式子3</h4><p>$\\mu*id = \\varphi$</p>\n<h5 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h5><p>纯数学公式证法之后再推，这里先说用卷积的证法：</p>\n<p>$\\mu<em>id</em>I = \\varphi*I$</p>\n<p>运用上面的公式1和公式2：</p>\n<p>$\\epsilon*id = id$</p>\n<p>好像只要 $id(1)$ 有逆元，就可以同时除以 $id$。</p>\n<p>所以式子化为：</p>\n<p>$\\epsilon = [x = 1]$</p>\n<p>得证。</p>\n<p>这个式子主要是让 $\\mu$ 化为 $\\varphi$，常在用 $\\mu$ 推不出来的时候使用。</p>\n<h2 id=\"莫比乌斯反演\"><a href=\"#莫比乌斯反演\" class=\"headerlink\" title=\"莫比乌斯反演\"></a>莫比乌斯反演</h2><p>设 $f(x) = \\sum_{d|x}g(d)$</p>\n<p>则 $g(x) = \\sum_{d|x}\\mu(\\frac{x}{d})f(d)$</p>\n<h3 id=\"证明：-2\"><a href=\"#证明：-2\" class=\"headerlink\" title=\"证明：\"></a>证明：</h3><p>下面的式子可以看为 $\\mu*f = g$。</p>\n<p>于是，根据 $\\mu<em>I = \\epsilon$，可以得到 $\\epsilon</em>f = g*I$。</p>\n<p>而上面的式子等价于 $g*I = f$。</p>\n<p>所以 $\\epsilon*f = f$。</p>\n<p>得证。</p>\n<h2 id=\"杜教筛\"><a href=\"#杜教筛\" class=\"headerlink\" title=\"杜教筛\"></a>杜教筛</h2><p>假设现在要筛一个<strong>积性函数</strong> $f$ 的前缀和。</p>\n<p>（其实杜教筛不是只能筛积性函数，你只要能在线性以内的时间把一个函数的前缀和预处理出来，一般都是可以筛的，至于积性函数是因为一般的积性函数都可以拿线性筛筛出来）</p>\n<p>即求 $S(n) = \\sum_{i=1}^nf(i)$。</p>\n<p>先找一个函数 $g$，把它们卷起来：</p>\n<p>$\\sum_{i=1}^{n}(f*g)(n) = \\sum_{i=1}^n\\sum_{d|i}f(\\frac{i}{d})g(d)$</p>\n<p>枚举 $d$：</p>\n<p>$\\sum_{d=1}^ng(d)\\sum_{i=1}^{\\frac{n}{d}}f(i)$</p>\n<p>后面的东西就是 $S$：</p>\n<p>$\\sum_{d=1}^ng(d)S(\\frac{n}{d})$</p>\n<p>于是，得到了：</p>\n<p>$\\sum_{i=1}^n(f*g)(n) = \\sum_{d=1}^ng(d)S(\\frac{n}{d})$</p>\n<p>再想想我们要求的是什么：</p>\n<p>$g(1)S(n) = \\sum_{i=1}^{n}g(d)S(\\frac{n}{d})-\\sum_{i=2}^{n}g(d)S(\\frac{n}{d}) = \\sum_{i=1}^n(f*g)(i)-\\sum_{i=2}^{n}g(d)S(\\frac{n}{d})$</p>\n<p>这里的 $g(1)$ 一般都是 $1$，所以只要能快速预处理出前面的 $f*g$ 的前缀和和 $g$ 的前缀和，后面的就可以通过整除分块递归求解。</p>\n<p>时间复杂度为 $O(\\sqrt n\\cdot \\sqrt{\\sqrt n}) = O(n^{\\frac{1}{2}+\\frac{1}{4}}) = O(n^{\\frac{3}{4}})$。</p>\n<p>由于这个$\\frac{n}{i}$的取值只有$\\sqrt n$种，所以如果用map把用过的 $\\frac{n}{i}$ 对应的前缀和的值都存起来，map中元素的个数不超过 $2\\cdot \\sqrt n$ 个。</p>\n<p>加上了记忆化搜索，提前筛好前$n^{\\frac{2}{3}}$个数之后，算法的时间复杂度就变成了$O(n^{\\frac{2}{3}})$。</p>\n<p>模板： <a href=\"https://www.luogu.com.cn/problem/P4213\">P4213 杜教筛</a> </p>\n<p>Code：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>,lim = <span class=\"number\">1.5e6</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,vis[N],pri[N],tot,mu[N];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> phi[N];</span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>,<span class=\"type\">long</span> <span class=\"type\">long</span>&gt; mp1,mp2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tphi[<span class=\"number\">1</span>] = mu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\tphi[i] = i<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i%pri[j]) phi[i*pri[j]] = phi[i]*(pri[j]<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> phi[i*pri[j]] = phi[i]*pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\tmu[i]+=mu[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\tphi[i]+=phi[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">getmu</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&lt;=lim) <span class=\"keyword\">return</span> mu[x];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mp1[x]) <span class=\"keyword\">return</span> mp1[x];</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> ret = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">long</span> <span class=\"type\">long</span> l=<span class=\"number\">2</span>,r;l&lt;=x;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tr = x/(x/l);</span><br><span class=\"line\">\t\tret-=<span class=\"built_in\">getmu</span>(x/l)*(r-l+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mp1[x] = ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">getphi</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&lt;=lim) <span class=\"keyword\">return</span> phi[x];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mp2[x]) <span class=\"keyword\">return</span> mp2[x];</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> ret = (x+<span class=\"number\">1</span>)*(x)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">long</span> <span class=\"type\">long</span> l=<span class=\"number\">2</span>,r;l&lt;=x;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tr = x/(x/l);</span><br><span class=\"line\">\t\tret-=<span class=\"built_in\">getphi</span>(x/l)*(r-l+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mp2[x] = ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"built_in\">getphi</span>(n)&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;<span class=\"built_in\">getmu</span>(n)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>杜教筛是基于整除分块和预处理保证时间复杂度的，筛数论函数前缀和的有力工具，其算法复杂度为 $O(n^{\\frac{2}{3}})$，即使 $n = 10^{12}$，也可以在常数较小的情况下跑过。</p>\n<p>要达到 $O(n^{\\frac{2}{3}})$ 的时间复杂度，你需要找到合适的函数 $g$ ，使你能够快速求出其前缀和和 $f*g$ 的前缀和，一般都是在上面提到的那一堆函数里面挑。</p>\n<p>还要灵活运用莫比乌斯反演，将你要求的函数转化为好求的东西哦。</p>\n","tags":["Knowledge","数论","杜教筛"]},{"title":"对线段树的研究","url":"/2022/07/13/%E5%AF%B9%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E7%A0%94%E7%A9%B6/","content":"<h1 id=\"对线段树的研究\"><a href=\"#对线段树的研究\" class=\"headerlink\" title=\"对线段树的研究\"></a>对线段树的研究</h1><p>$\\color{lightblue}Status:OK$</p>\n<h2 id=\"咕\"><a href=\"#咕\" class=\"headerlink\" title=\"咕\"></a>咕</h2><p>李超树</p>\n<p>Segment Tree Beats</p>\n<p>线段树二分</p>\n<p>线段树合并</p>\n<p>线段树分治</p>\n<span id=\"more\"></span>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>线段树实际上是一个满二叉树，每个节点都存储一段区间内的信息，而且可以通过左右孩子的信息推出自己的信息。所以要求存储的信息具有可加性。</p>\n<p>具体线段树怎么写应该不用多说了。。。</p>\n<p>在有区间修改时，必须应用懒标记以保证复杂度，因为这样只会对 $\\log n$ 个节点的信息产生修改，这也要求了懒标记具有可加性，且下传的时间复杂度应比较低。</p>\n<h2 id=\"经典应用\"><a href=\"#经典应用\" class=\"headerlink\" title=\"经典应用\"></a>经典应用</h2><h3 id=\"特殊的信息合并——区间最大子段和\"><a href=\"#特殊的信息合并——区间最大子段和\" class=\"headerlink\" title=\"特殊的信息合并——区间最大子段和\"></a>特殊的信息合并——区间最大子段和</h3><p><a href=\"https://www.luogu.com.cn/problem/SP1716\">SP1716 GSS3 - Can you answer these queries III</a></p>\n<p>给你一个序列，操作有：</p>\n<ol>\n<li>每次询问 $[l,r]$ 中的最大子段和。</li>\n<li>单点修改一个数的值（可能有负数）。</li>\n</ol>\n<p>区间最大子段和指区间内一个连续的子区间，它们的和是这个区间内所有子区间中最大的。</p>\n<p>如果已经知道两个连续的子区间的最大子段和，这个大区间的最大子段和可以是两个里面更大的一个，也可以是横跨两个区间的新区间，难点就在于把横跨两个区间的最大区间算出来。</p>\n<p>只维护一个区间和是不行的，怎么办？维护多个信息！</p>\n<p>考虑维护 $4$ 个信息：区间和($sum$)、从左端点开始的最大子段和($lMax$)，从右端点开始的最大子段和($rMax$)，区间最大子段和($Max$)。</p>\n<p>那么，横跨两个区间的最大子段和就是左区间的 $rMax$ 加上右区间的 $lMax$。</p>\n<p>这里有个形象的图，其中绿色部分代表左区间的 $rMax$，橙色部分代表右区间的 $lMax$：</p>\n<p><img src=\"https://s2.loli.net/2024/08/18/pMskJhwZtyErQ9I.png\" alt=\".drawio.png\"></p>\n<p>于是可以合并两个子树的信息，维护当前节点的 $Max$。</p>\n<p>$lMax$ 可以是左子树的 $lMax$，也可以是左子树的 $sum$ 加上右子树的 $lMax$。</p>\n<p>$rMax$ 同理。</p>\n<p>这样，我们就可以轻松的写出 pushup 操作。</p>\n<p>但是，还有一个难题：如何写出 query？</p>\n<p>给定了区间 $[l,r]$，就意味着可能出现一个满足条件的区间在孙子里面的情况，这样就无法很好的维护 $lMax$ 和 $rMax$ 。</p>\n<p>有一个骚操作：直接将节点当作返回值，方便获取 $lMax$ 和 $rMax$，这样就和维护儿子节点一样了。</p>\n<p>这个问题启发我们：<strong>在信息不好维护时找信息之间的关系，把有关联的信息都维护掉，信息就能够维护了</strong>。</p>\n<h4 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,a[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tre</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,sum,Max,lMax,rMax;</span><br><span class=\"line\">&#125; tr[N*<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(tre &amp;node,tre lc,tre rc)</span></span>&#123; <span class=\"comment\">//传3个参数方便在query时调用 </span></span><br><span class=\"line\">\tnode.Max = <span class=\"built_in\">max</span>(-inf,<span class=\"built_in\">max</span>(lc.Max,<span class=\"built_in\">max</span>(rc.Max,lc.rMax+rc.lMax)));</span><br><span class=\"line\">\tnode.lMax = <span class=\"built_in\">max</span>(-inf,<span class=\"built_in\">max</span>(lc.lMax,lc.sum+rc.lMax));</span><br><span class=\"line\">\tnode.rMax = <span class=\"built_in\">max</span>(-inf,<span class=\"built_in\">max</span>(rc.rMax,rc.sum+lc.rMax));</span><br><span class=\"line\">\tnode.sum = (lc.sum == -inf?<span class=\"number\">0</span>:lc.sum)+(rc.sum == -inf?<span class=\"number\">0</span>:rc.sum)-((lc.sum == -inf &amp;&amp; rc.sum == -inf)?-inf:<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">\t\ttr[node].l = tr[node].r = l;</span><br><span class=\"line\">\t\ttr[node].sum = tr[node].Max = tr[node].lMax = tr[node].rMax = a[l];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>,lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(lc,l,mid);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(rc,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(tr[node],tr[lc],tr[rc]);</span><br><span class=\"line\">\ttr[node].l = tr[lc].l;</span><br><span class=\"line\">\ttr[node].r = tr[rc].r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r)&#123;</span><br><span class=\"line\">\t\ttr[node].sum = tr[node].Max = tr[node].lMax = tr[node].rMax = v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">update</span>(lc,l,r,v);</span><br><span class=\"line\">\t<span class=\"built_in\">update</span>(rc,l,r,v);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(tr[node],tr[lc],tr[rc]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">tre <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\ttre ans;</span><br><span class=\"line\">\tans.lMax = ans.rMax = ans.Max = ans.sum = -inf;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r) <span class=\"keyword\">return</span> tr[node];</span><br><span class=\"line\">\ttre lc = <span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>,l,r),rc = <span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,l,r);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(ans,lc,rc);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> op,l,r;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>) cout&lt;&lt;<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,l,r).Max&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(<span class=\"number\">1</span>,l,l,r);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"练手题：\"><a href=\"#练手题：\" class=\"headerlink\" title=\"练手题：\"></a>练手题：</h4><p><a href=\"https://www.luogu.com.cn/problem/P4513\">P4513 小白逛公园</a></p>\n<p><a href=\"https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/A\">A - Segment Tree</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P1471\">P1471 方差</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/SP2916\">SP2916 GSS5 - Can you answer these queries V</a></p>\n<h3 id=\"均摊复杂度——区间开平方\"><a href=\"#均摊复杂度——区间开平方\" class=\"headerlink\" title=\"均摊复杂度——区间开平方\"></a>均摊复杂度——区间开平方</h3><p><a href=\"https://www.luogu.com.cn/problem/SP2713\">SP2713 GSS4 - Can you answer these queries IV</a></p>\n<p>给你一个序列，操作有：</p>\n<ol>\n<li>区间内的每个数开方（下取整）。</li>\n<li>区间求和。</li>\n</ol>\n<p>给区间内的所有数开方显然不是给和开方就能解决的，貌似只能暴力在叶子节点开方。</p>\n<p>但是，这样实际上就足够了，因为一个 $10^{18}$ 以内的数 $7$ 次左右开方就能开到 $1$，所以对一个数的操作次数最多为 $7$ 次，那么对所有数的操作次数最多就是 $7n$ 次了，时间绰绰有余。</p>\n<p>但是，不要用懒标记延迟下传到儿子，因为你不能在只知道区间和的情况下求出区间开方后的值，所以无法提前改变当前节点的和，导致访问到未更新的值。</p>\n<p>这个问题告诉我们两个要点：</p>\n<ol>\n<li>使用懒标记前必须确保能在下传之前更新当前节点的值。</li>\n<li>不仅要思考如何合并区间信息，在无法合并时也要分析暴力修改的复杂度，有很多时候传到叶子节点，复杂度也是对的。</li>\n</ol>\n<h4 id=\"Code：-1\"><a href=\"#Code：-1\" class=\"headerlink\" title=\"Code：\"></a>Code：</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> a[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tre</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> l,r,flag;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> sum;</span><br><span class=\"line\">&#125; tr[N*<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">    tr[node].sum = tr[lc].sum+tr[rc].sum;</span><br><span class=\"line\">    tr[node].flag = (tr[lc].flag&amp;tr[rc].flag);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">        tr[node].l = tr[node].r = l;</span><br><span class=\"line\">        tr[node].sum = a[l];</span><br><span class=\"line\">        tr[node].flag = (a[l] &lt;= <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>,lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(lc,l,mid);</span><br><span class=\"line\">    <span class=\"built_in\">build</span>(rc,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">    <span class=\"built_in\">pushup</span>(node);</span><br><span class=\"line\">    tr[node].l = tr[lc].l;</span><br><span class=\"line\">    tr[node].r = tr[rc].r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tr[node].flag) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    tr[node].sum = <span class=\"built_in\">sqrt</span>(tr[node].sum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r &amp;&amp; tr[node].flag) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tr[node].l == tr[node].r)&#123;</span><br><span class=\"line\">        tr[node].sum = <span class=\"built_in\">sqrt</span>(tr[node].sum);</span><br><span class=\"line\">        tr[node].flag = (tr[node].sum&lt;=<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(node&lt;&lt;<span class=\"number\">1</span>,l,r);</span><br><span class=\"line\">    <span class=\"built_in\">update</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,l,r);</span><br><span class=\"line\">    <span class=\"built_in\">pushup</span>(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r) <span class=\"keyword\">return</span> tr[node].sum;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>,l,r)+<span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,l,r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cin&gt;&gt;n)&#123;</span><br><span class=\"line\">        t++;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class=\"string\">&quot;:&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">        <span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">        cin&gt;&gt;m;</span><br><span class=\"line\">        <span class=\"type\">int</span> op,l,r;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">            cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l&gt;r) <span class=\"built_in\">swap</span>(l,r);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>) cout&lt;&lt;<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,l,r)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(<span class=\"number\">1</span>,l,r);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>练手题：</p>\n<p><a href=\"https://www.luogu.com.cn/problem/CF438D\">CF438D The Child and Sequence</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/CF920F\">CF920F SUM and REPLACE</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/CF444C\">CF444C DZY Loves Colors</a></p>\n<h3 id=\"离线的力量——不重复最大子段和\"><a href=\"#离线的力量——不重复最大子段和\" class=\"headerlink\" title=\"离线的力量——不重复最大子段和\"></a>离线的力量——不重复最大子段和</h3><p><a href=\"https://www.luogu.com.cn/problem/SP1557\">SP1557 GSS2 - Can you answer these queries II</a></p>\n<p>给你一个序列，求最大子段和，其中子段中的重复数字只算一次。</p>\n<p>显然，我们是无法通过转换为二进制等方式去除重复的，所以我们需要换个思路。</p>\n<p>先改变最大子段和的方式：</p>\n<p>对于每一个位置，记录其所有前缀和，历史最大前缀和就是以那个位置为左端点的最大子段和。</p>\n<p>之后考虑重复元素对答案的贡献：</p>\n<p>记在第 $i$ 位的元素上一次出现的位置为 $las$，对左端点在 $las$ 之前的子段，由于它和 $las$ 重复，所以它不会被算进去。于是它产生贡献的子段只有 $las+1$~$i$（能加到前缀中，更新前缀和）。</p>\n<p>但是，这样算出来的前缀是没有任何限制的，也就是说最大子段和的右端点可能会超过询问的右端点，所以要边处理询问边算。</p>\n<p>容易想到把询问按右端点递增排序，每次只更新上一次的右端点到这次的前缀和，再询问左端点到右端点间的历史最大值就行了。</p>\n<p>很多时候，在不要求在线且问题难以直接处理时，用一种特殊的顺序处理询问会极大简化问题。</p>\n<h4 id=\"Code：-2\"><a href=\"#Code：-2\" class=\"headerlink\" title=\"Code：\"></a>Code：</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">3e5</span>+<span class=\"number\">10</span>,eps = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,qs,a[N],las[N];</span><br><span class=\"line\">ll ans[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tre</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r;</span><br><span class=\"line\">\tll sum,hsum,lazy,hlazy;</span><br><span class=\"line\">&#125; tr[N*<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">que</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,id;</span><br><span class=\"line\">&#125; q[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(que x,que y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x.r&lt;y.r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">\t\ttr[node].l = tr[node].r = l;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>,lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(lc,l,mid);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(rc,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\ttr[node].l = tr[lc].l;</span><br><span class=\"line\">\ttr[node].r = tr[rc].r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\ttr[node].sum+=v;</span><br><span class=\"line\">\ttr[node].hsum = <span class=\"built_in\">max</span>(tr[node].hsum,tr[node].sum);</span><br><span class=\"line\">\ttr[node].lazy+=v;</span><br><span class=\"line\">\ttr[node].hlazy = <span class=\"built_in\">max</span>(tr[node].hlazy,tr[node].lazy);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push2</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\ttr[node].hsum = <span class=\"built_in\">max</span>(tr[node].sum+v,tr[node].hsum);</span><br><span class=\"line\">\ttr[node].hlazy = <span class=\"built_in\">max</span>(tr[node].lazy+v,tr[node].hlazy);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushdown</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].hlazy)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">push2</span>(lc,tr[node].hlazy);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push2</span>(rc,tr[node].hlazy);</span><br><span class=\"line\">\t\ttr[node].hlazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].lazy)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">push</span>(lc,tr[node].lazy);</span><br><span class=\"line\">\t\t<span class=\"built_in\">push</span>(rc,tr[node].lazy);</span><br><span class=\"line\">\t\ttr[node].lazy = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">\ttr[node].sum = <span class=\"built_in\">max</span>(tr[node&lt;&lt;<span class=\"number\">1</span>].sum,tr[node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>].sum);</span><br><span class=\"line\">\ttr[node].hsum = <span class=\"built_in\">max</span>(tr[node&lt;&lt;<span class=\"number\">1</span>].hsum,tr[node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>].hsum);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">upd</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">push</span>(node,v);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">pushdown</span>(node);</span><br><span class=\"line\">\t<span class=\"built_in\">upd</span>(node&lt;&lt;<span class=\"number\">1</span>,l,r,v);</span><br><span class=\"line\">\t<span class=\"built_in\">upd</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,l,r,v);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r) <span class=\"keyword\">return</span> tr[node].hsum;</span><br><span class=\"line\">\t<span class=\"built_in\">pushdown</span>(node);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(<span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>,l,r),<span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,l,r));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">\tcin&gt;&gt;qs;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=qs;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;q[i].l&gt;&gt;q[i].r;</span><br><span class=\"line\">\t\tq[i].id = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(q+<span class=\"number\">1</span>,q+<span class=\"number\">1</span>+qs,cmp);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=qs;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (now&lt;=q[i].r)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">upd</span>(<span class=\"number\">1</span>,las[a[now]+eps]+<span class=\"number\">1</span>,now,a[now]);</span><br><span class=\"line\">\t\t\tlas[a[now]+eps] = now;</span><br><span class=\"line\">\t\t\tnow++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans[q[i].id] = <span class=\"built_in\">query</span>(<span class=\"number\">1</span>,q[i].l,q[i].r);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=qs;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>练手题：<a href=\"https://www.luogu.com.cn/problem/P4314\">P4314 CPU 监控</a></p>\n<h3 id=\"转化询问——区间区间数量\"><a href=\"#转化询问——区间区间数量\" class=\"headerlink\" title=\"转化询问——区间区间数量\"></a>转化询问——区间区间数量</h3><p><a href=\"https://www.luogu.com.cn/problem/P2184\">P2184 贪婪大陆</a></p>\n<p>每次在区间内添加一种不同于之前的元素，询问区间内不同元素数量。</p>\n<p>由于元素一定是互不相同的，所以等价于求区间中不同区间数量。</p>\n<p>假设询问的区间为 $[L,R]$，一个合法的区间为 $[l,r]$，则有以下几种情况：</p>\n<ol>\n<li>$l\\leq L,R\\leq r$，即询问区间被合法区间完全包含。</li>\n<li>$l\\leq L,L\\leq r\\leq R$，即只有左端点没有被询问区间包含。</li>\n<li>$L\\leq l\\leq R,R\\leq r$，即只有右端点没有被询问区间包含。</li>\n<li>$L\\leq l\\leq R,L\\leq r\\leq R$，即合法区间被询问区间完全包含。</li>\n</ol>\n<p>如何求解这 $4$ 种情况呢？</p>\n<p>对于 $1,2$，我们可以询问 $[1,L)$ 内左端点与右端点之差，相当与每个左端点产生 $1$ 的贡献，每个右端点产生 $-1$ 的贡献，这样就减去了左右端点都在 $[1,L)$ 内的区间，保留了合法的区间。</p>\n<p>对于 $3,4$，我们可以询问 $[L,R]$ 内左端点的数量，因为产生贡献的区间，其左端点必定在这里面。</p>\n<p>于是，我们可以用树状数组维护左端点和右端点的数量，每次回答询问时输出 $[1,R]$ 内的左端点数量减去 $[1,L)$ 内的右端点数量。</p>\n<h4 id=\"Code：-3\"><a href=\"#Code：-3\" class=\"headerlink\" title=\"Code：\"></a>Code：</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">BIT</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a[N];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (;x&lt;=n;x+=(x&amp;(-x))) a[x]+=v;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (;x;x-=(x&amp;(-x))) ret+=a[x];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; tr1,tr2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> op,l,r;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\ttr1.<span class=\"built_in\">update</span>(l,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\ttr2.<span class=\"built_in\">update</span>(r,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;(tr1.<span class=\"built_in\">query</span>(r)-tr2.<span class=\"built_in\">query</span>(l<span class=\"number\">-1</span>))&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-log-线段树\"><a href=\"#2-log-线段树\" class=\"headerlink\" title=\"$2\\log$ 线段树\"></a>$2\\log$ 线段树</h2><h3 id=\"非线性合并\"><a href=\"#非线性合并\" class=\"headerlink\" title=\"非线性合并\"></a>非线性合并</h3><p><a href=\"https://www.luogu.com.cn/problem/P4198\">P4198 楼房重建</a></p>\n<p>给你一个序列，单点修改，每次计算比前面的所有数大的数的数量（$a_i&gt;\\max(a_1,a_2\\cdots a_{i-1})$）。</p>\n<p>假设已经知道了左右儿子的数量，现在要计算当前节点的数量。左儿子的数量不会改变，因为它已经是合法的了，可是右儿子可能会因为某些原来合法的点的值比左儿子中的一些值小，而变得不合法，我们要做的就是剔除这些点。</p>\n<p>显然，右儿子中原本合法的点，只要比左儿子的最大值（记为 $Max$）大，就还是合法的。我们可以再次递归，重新访问右儿子的子树，这里分几种情况考虑：</p>\n<ol>\n<li>如果其最大值不大于 $Max$，那么这里面的点都没戏。</li>\n<li>如果其最大值大于 $Max$，不能知道合法的点的数量，要继续递归：<ol>\n<li>如果左儿子的最大值都比 $Max$ 大，那右儿子中的点显然都是合法的，只用访问左儿子，最后加上右儿子中合法的点的数量。</li>\n<li>如果左儿子的最大值比 $Max$ 小，就不用访问左儿子了，直接访问右儿子。</li>\n</ol>\n</li>\n</ol>\n<p>这样就完成了合并两个子节点信息的过程。</p>\n<h4 id=\"Code：-4\"><a href=\"#Code：-4\" class=\"headerlink\" title=\"Code：\"></a>Code：</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span> eps = <span class=\"number\">1e-12</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tre</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,len;</span><br><span class=\"line\">\t<span class=\"type\">double</span> Max;</span><br><span class=\"line\">&#125; tr[N*<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">\t\ttr[node].l = tr[node].r = l;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>,lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(lc,l,mid);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(rc,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\ttr[node].l = tr[lc].l;</span><br><span class=\"line\">\ttr[node].r = tr[rc].r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">double</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((v-tr[node].Max)&gt;eps || <span class=\"built_in\">fabs</span>(tr[node].Max-v)&lt;=eps) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l == tr[node].r) <span class=\"keyword\">return</span> tr[node].len;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tr[node&lt;&lt;<span class=\"number\">1</span>].Max-v)&gt;eps) <span class=\"keyword\">return</span> <span class=\"built_in\">get</span>(lc,v)+tr[node].len-tr[lc].len;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">get</span>(rc,v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">double</span> m = tr[node&lt;&lt;<span class=\"number\">1</span>].Max;</span><br><span class=\"line\">\ttr[node].len = tr[node&lt;&lt;<span class=\"number\">1</span>].len+<span class=\"built_in\">get</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,m);</span><br><span class=\"line\">\ttr[node].Max = <span class=\"built_in\">max</span>(tr[node&lt;&lt;<span class=\"number\">1</span>].Max,tr[node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>].Max);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">double</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;r || tr[node].r&lt;l) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (tr[node].l&gt;=l &amp;&amp; tr[node].r&lt;=r)&#123;</span><br><span class=\"line\">\t\ttr[node].len = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ttr[node].Max = v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">update</span>(node&lt;&lt;<span class=\"number\">1</span>,l,r,v);</span><br><span class=\"line\">\t<span class=\"built_in\">update</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,l,r,v);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>(<span class=\"number\">1</span>,x,x,<span class=\"number\">1.0</span>*y/x);</span><br><span class=\"line\">\t\tcout&lt;&lt;tr[<span class=\"number\">1</span>].len&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"非线性修改\"><a href=\"#非线性修改\" class=\"headerlink\" title=\"非线性修改\"></a>非线性修改</h3>","tags":["Knowledge","线段树"]},{"title":"左偏树入门","url":"/2024/07/22/%E5%B7%A6%E5%81%8F%E6%A0%91%E5%85%A5%E9%97%A8/","content":"<h1 id=\"左偏树入门\"><a href=\"#左偏树入门\" class=\"headerlink\" title=\"左偏树入门\"></a>左偏树入门</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>左偏树，是一个支持合并的堆。</p>\n<p>对于每一个点，它到最近的一个子节点数小于 $2$ 的节点的距离为 $dist$，则左偏树满足<strong>右儿子</strong>的 $dist$ 比<strong>左儿子</strong>更小。因此，这个树左边的节点似乎更多，所以叫左偏树。</p>\n<p>在代码实现中，由于可能访问到空的儿子，所以 $dist[0] = -1$，这样可以免去一些麻烦。</p>\n<span id=\"more\"></span>\n<h2 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h2><p>左偏树的核心操作是合并，即将两个堆合并到一起，且不改变堆的性质。</p>\n<p>对于一个堆，最方便操作的是堆顶（或者树根），不妨设要维护一个小根堆，那么我们将更小的数作为新堆的堆顶，一定合法。</p>\n<p>对于另一个稍大的数，让它和较小数的右儿子合并，之后递归下去。不能和左儿子合并，因为这样复杂度不对。</p>\n<p>合并结束后，我们会得到一个新的右儿子，如果它的 $dist$ 比左儿子小，就要交换，以维护树的结构。</p>\n<p>这里 $dist$ 可能改变，需要更新新的堆顶的 $dist$。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x == y) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!x || !y) <span class=\"keyword\">return</span> x|y; <span class=\"comment\">//两种特判，建议写，因为x,y可以是很神奇的值</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (v[y]&lt;v[x]) <span class=\"built_in\">swap</span>(x,y); <span class=\"comment\">//维护小根堆，作为新根的x，val要更小</span></span><br><span class=\"line\">\trc[x] = <span class=\"built_in\">merge</span>(rc[x],y); <span class=\"comment\">//递归更新左偏树</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dis[rc[x]]&gt;dis[lc[x]]) <span class=\"built_in\">swap</span>(rc[x],lc[x]);</span><br><span class=\"line\">\tdis[x] = dis[rc[x]]+<span class=\"number\">1</span>; <span class=\"comment\">//dist的相关更新</span></span><br><span class=\"line\">\tfa[lc[x]] = fa[rc[x]] = x; <span class=\"comment\">//下面讲</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h2><p>如果要查一个数所处堆的最大值，朴素的想法是一步步跳父亲，虽然 $dist$ 是 $\\log_2n$ 级别的，但是树的深度可以达到 $n$，即退化成链，复杂度不可接受。</p>\n<p>不过，对于一个数，我们只需要知道堆顶就行，可以看作所处的集合，用并查集维护。</p>\n<p>设 $fa[i]$ 表示第 $i$ 个数所处的堆顶是哪个数，初始值全部指向自己。</p>\n<p>什么时候 $fa$ 才会变呢？</p>\n<p>首先，$merge$ 操作中右儿子发生更改时，新的右儿子显然不知道自己父亲是谁，这就是上面 $merge$ 函数中那一行的作用。</p>\n<p>其次，是下面的操作。</p>\n<h2 id=\"更改\"><a href=\"#更改\" class=\"headerlink\" title=\"更改\"></a>更改</h2><p>有时，我们需要更改某个位置上的值，甚至将它删掉。</p>\n<p>其实，更改的过程，可以看成先删掉旧值，再加上新值的过程。</p>\n<p>加上新值，就是普通的 $merge$ 操作，将新的节点和原来的堆合并。</p>\n<p>删掉旧值，也可以看成合并它的左右儿子。但是，事情远不止这么简单。</p>\n<p>由于并查集的特性，还有很多节点，它的 $fa$ 是已经删掉的点，所以，我们不能抛弃删掉的节点，还要继续维护它的 $fa$，将它指向新的根。</p>\n<p>这样就完了吗，还没有！删掉的节点，它的左右儿子还是指向它的，如果让它指向新的根（左右儿子中的一个），就会造成循环。解决这个问题，需要同时维护新根的 $fa$，让它指向自己。</p>\n<p>加上新值时，我们也需要对新的节点进行初始化，将 $dist$ 和左右儿子设为 $0$，$fa$ 指向自己。</p>\n<h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><p><a href=\"https://www.luogu.com.cn/problem/P3377\">P3377 【模板】左偏树/可并堆</a></p>\n<p>每次删出现最早的，就是对大小关系加一层限制，本质还是比大小。</p>\n<p>模板题还是放个代码吧。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,del[N],fa[N],lc[N],rc[N],dis[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v,id;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span> &lt;(node b)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v!=b.v) <span class=\"keyword\">return</span> v&lt;b.v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> id&lt;b.id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; a[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x == fa[x]) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fa[x] = <span class=\"built_in\">get</span>(fa[x]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x == y) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!x || !y) <span class=\"keyword\">return</span> x|y;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a[y]&lt;a[x]) <span class=\"built_in\">swap</span>(x,y);</span><br><span class=\"line\">\trc[x] = <span class=\"built_in\">merge</span>(rc[x],y);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dis[rc[x]]&gt;dis[lc[x]]) <span class=\"built_in\">swap</span>(rc[x],lc[x]);</span><br><span class=\"line\">\tdis[x] = dis[rc[x]]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\tfa[lc[x]] = fa[rc[x]] = x;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tdis[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].v;</span><br><span class=\"line\">\t\ta[i].id = i;</span><br><span class=\"line\">\t\tfa[i] = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> op,x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op&gt;&gt;x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;y;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (del[x] || del[y]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tx = <span class=\"built_in\">get</span>(x),y = <span class=\"built_in\">get</span>(y);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">merge</span>(x,y);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (del[x])&#123;</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tx = <span class=\"built_in\">get</span>(x);</span><br><span class=\"line\">\t\t\tcout&lt;&lt;a[x].v&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t\tdel[x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tfa[lc[x]] = fa[rc[x]] = fa[x] = <span class=\"built_in\">merge</span>(lc[x],rc[x]);</span><br><span class=\"line\">\t\t\ta[x].v = a[x].id = dis[x] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h2><p><a href=\"https://www.luogu.com.cn/problem/P1456\">P1456 Monkey King</a></p>\n<p>更改操作，注意准确维护 $fa$ 数组，不要陷入循环。</p>\n","tags":["Knowledge","左偏树"]},{"title":"对莫比乌斯函数的研究","url":"/2022/05/26/%E5%AF%B9%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E7%9A%84%E7%A0%94%E7%A9%B6/","content":"<h1 id=\"对莫比乌斯函数的研究\"><a href=\"#对莫比乌斯函数的研究\" class=\"headerlink\" title=\"对莫比乌斯函数的研究\"></a>对莫比乌斯函数的研究</h1><p>$\\color{lightgreen}Status:Finished$.</p>\n<h2 id=\"更新日志\"><a href=\"#更新日志\" class=\"headerlink\" title=\"更新日志\"></a>更新日志</h2><p>2022/5/25 成文。</p>\n<p>2022/5/28 对部分语言进行了更改，简要写了一下一般用在哪。</p>\n<p>2022/6/25 更新了部分内容，补充了各种函数的基本用法，增加了一些例题。</p>\n<h2 id=\"什么是莫比乌斯函数\"><a href=\"#什么是莫比乌斯函数\" class=\"headerlink\" title=\"什么是莫比乌斯函数\"></a>什么是莫比乌斯函数</h2><p>将 $n$ 分解，$n = \\prod_{i=1}^kp_i^{c_i}$。</p>\n<p>如果对于 $1\\leq i \\leq k$，$c_i\\leq 1$，则$\\mu(k) = (-1)^k$。</p>\n<p>否则，$\\mu(k) = 0$。</p>\n<p>等于 $0$ 的 $\\mu$ 值可以避免一些乘法计算，因为乘出来的结果就是 $0$。</p>\n<span id=\"more\"></span>\n<h2 id=\"这个东西有什么用\"><a href=\"#这个东西有什么用\" class=\"headerlink\" title=\"这个东西有什么用\"></a>这个东西有什么用</h2><h3 id=\"积性函数\"><a href=\"#积性函数\" class=\"headerlink\" title=\"积性函数\"></a>积性函数</h3><p>当两个数$n$，$m$互质时，必然不包含相同的质因数，所以乘起来之后质因数的指数没有变化 ，故 $\\mu(n\\cdot m) = \\mu(n) \\cdot \\mu(m)$。</p>\n<p>这个性质使 $\\mu$ 能用线性筛筛出。</p>\n<h3 id=\"性质1\"><a href=\"#性质1\" class=\"headerlink\" title=\"性质1\"></a>性质1</h3><p>$\\sum_{d|n}\\mu(d) = [n = 1]$</p>\n<p>卷积形式：$\\mu*I = \\epsilon$。</p>\n<h4 id=\"证明\"><a href=\"#证明\" class=\"headerlink\" title=\"证明\"></a>证明</h4><p>当 $n = 1$ 时，有 $\\sum_{d|n} \\mu(d) = 1$，因为它等价于 $\\mu(d) = 1$。</p>\n<p>当 $n\\neq 1$ 时，设 $n = \\prod_{i=1}^kp_i^{c_i}$，$n’ = \\prod_{i=1}^kp_i$。</p>\n<p>注意到，对于指数 $&gt;1$ 的，它的贡献是 $0$，所以有贡献的数必然是 $n’$ 的约数，即：</p>\n<p>$\\sum_{d|n}\\mu(d) = \\sum_{d|n’}\\mu(d)$</p>\n<p>之后，根据 $\\mu$ 函数的定义，得到以下式子：</p>\n<p>$\\sum_{d|n’}\\mu(d) = \\sum_{i=0}^k C_k^i\\cdot (-1)^i$</p>\n<p>$i$ 从 $0$ 开始是为了把 $d = 1$ 的情况算进去。</p>\n<p>这个式子很眼熟（虽然我第一次看它时毫无感觉），这很像二项式定理啊：</p>\n<p>$(a+b)^k = \\sum_{i=0}^k C_k^i a^i b^{k-i}$</p>\n<p>于是可以把原式化为 $(1+(-1))^k = (1-1)^k = 0^k$。</p>\n<p>发现，当 $k\\neq 0$ 时，这个式子的值为 $0$。</p>\n<p>得证。</p>\n<h4 id=\"在哪里用\"><a href=\"#在哪里用\" class=\"headerlink\" title=\"在哪里用\"></a>在哪里用</h4><p>可能它最大的用处是下面的扩展。</p>\n<h3 id=\"性质1扩展\"><a href=\"#性质1扩展\" class=\"headerlink\" title=\"性质1扩展\"></a>性质1扩展</h3><p>$[\\gcd(i,j) = 1] = \\sum_{d|\\gcd(i,j)}\\mu(d)$</p>\n<p>直接把 $\\gcd(i,j)$ 代入性质1中的 $n$ 即可得到。</p>\n<h4 id=\"在哪里用-1\"><a href=\"#在哪里用-1\" class=\"headerlink\" title=\"在哪里用\"></a>在哪里用</h4><p>很多求 $\\gcd$ 的题目最终都是化成这个形式，之后通过反演，把难看的 $\\gcd$ 转化为可以线性求出的 $\\mu$。</p>\n<p>一般，在莫比乌斯反演题目中，最后都是要化出这个形式，再变换，所以这个东西也被称作反演结论。</p>\n<p><del>由于我太菜了，不太会莫比乌斯反演，一车题都是用这个反演结论做的，但是还没碰到有关$\\gcd$且只能用莫比乌斯反演做的题。</del></p>\n<h3 id=\"性质2\"><a href=\"#性质2\" class=\"headerlink\" title=\"性质2\"></a>性质2</h3><p>$n = \\sum_{d|n}\\varphi(d)$</p>\n<p>卷积形式：$\\varphi * I =id$</p>\n<p>由它可以推导出另一个式子：</p>\n<p>$\\varphi(n) = \\sum_{d|n}\\frac{n}{d}\\mu(d)$</p>\n<p>卷积形式：$\\mu*id = \\varphi$</p>\n<p><del>这个东西我好像只会用卷积推</del></p>\n<p>我也不知道这个有什么用，但是它看上去能把欧拉函数和莫比乌斯函数联系起来，似乎很重要的样子。</p>\n<h4 id=\"证明-1\"><a href=\"#证明-1\" class=\"headerlink\" title=\"证明\"></a>证明</h4><p><del>搬运杜教筛博客中的证明</del></p>\n<p>将 $x$ 分解质因数：</p>\n<p>$x = \\prod_{i=1}^kp_i^{c_i}$</p>\n<p>由于 $\\varphi$ 是积性函数，所以可以将式子化为下面的形式：</p>\n<p>$\\prod_{i=1}^k\\sum_{j=0}^{c_i}\\varphi(p_i^j) = x$</p>\n<p>于是，设 $x’ = p^{c}$，要证的东西变成了下面的这个：</p>\n<p>$\\sum_{i=0}^{c}\\varphi(p^i) = x’$</p>\n<p>发现，它们都只有一个质因数 $p$，所以直接套欧拉函数定义式求值：</p>\n<p>$1+p\\cdot \\frac{p-1}{p}+p^2\\cdot \\frac{p-1}{p}+\\cdots +p^{c}\\cdot \\frac{p-1}{p}$</p>\n<p>化简：</p>\n<p>$1+(p-1)\\cdot (1+p+p^2+\\cdots+p^{c-1})$</p>\n<p>等比数列求和：</p>\n<p>$1+(p-1)\\cdot \\frac{p^{c}-1}{p-1} = p^c$</p>\n<p>得证。</p>\n<h4 id=\"在哪里用-2\"><a href=\"#在哪里用-2\" class=\"headerlink\" title=\"在哪里用\"></a>在哪里用</h4><p>感兴趣的可以做做这题：<a href=\"https://www.luogu.com.cn/problem/P1447\">P1447 NOI2010 能量采集</a>。</p>\n<h3 id=\"莫比乌斯变换\"><a href=\"#莫比乌斯变换\" class=\"headerlink\" title=\"莫比乌斯变换\"></a>莫比乌斯变换</h3><p>设 $f(x)$，$g(x)$ 为两个数论函数。</p>\n<p>形式1：</p>\n<p>$f(x) = \\sum_{d|n}g(d)$，那么 $g(x) = \\sum_{d|n}\\mu(\\frac{n}{d})f(d) = \\sum_{d|n}\\mu(d)f(\\frac{n}{d})$。</p>\n<p>形式2：</p>\n<p>$f(x) = \\sum_{n|d}g(d)$，那么 $g(x) = \\sum_{n|d}\\mu(\\frac{d}{n})f(d) = \\sum_{n|d}\\mu(d)f(\\frac{d}{n})$。</p>\n<h4 id=\"证明-2\"><a href=\"#证明-2\" class=\"headerlink\" title=\"证明\"></a>证明</h4><p>考虑卷积形式：</p>\n<p>已知 $f = g<em>I$，证明 $g = f</em>\\mu$。</p>\n<p>对第二个式子变换：</p>\n<p>$g<em>I = f</em>\\mu*I$</p>\n<p>$f = f*\\epsilon$</p>\n<p>化开：</p>\n<p>$f(x) = \\sum_{d|x}f(d)\\cdot [\\frac{x}{d} = 1]$</p>\n<p>只有当 $d = x$时有贡献，故原式得证。</p>\n<h2 id=\"怎么求出莫比乌斯函数的值呢\"><a href=\"#怎么求出莫比乌斯函数的值呢\" class=\"headerlink\" title=\"怎么求出莫比乌斯函数的值呢\"></a>怎么求出莫比乌斯函数的值呢</h2><p>当然是用线性筛了！</p>\n<p>我们在判断 $vis[i]&lt;pri[j]$ 时将相等情况特判一下，因为如果 $vis[i] = pri[j]$，那么 $i\\cdot pri[j]$ 中质因子 $pri[j]$ 的指数至少是 $2$，所以 $\\mu(i\\cdot pri[j]) = 0$，其他的直接根据积性函数性质拿 $\\mu(i)\\cdot \\mu(pri[j])$ 就行了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>; <span class=\"comment\">//1要特别初始化，因为它是特殊定义的</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> lim = <span class=\"number\">5e4</span>+<span class=\"number\">10</span>; <span class=\"comment\">//筛到的数的上限</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">            vis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>; <span class=\"comment\">//质数的mu为-1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i]; <span class=\"comment\">//在vis[i] = pri[j]时要赋值为0</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果是求单个数的 $\\mu$，也可以枚举它的质因数，找出其指数，求出值，时间复杂度为$O(\\sqrt n)$。</p>\n<h2 id=\"例题1\"><a href=\"#例题1\" class=\"headerlink\" title=\"例题1\"></a>例题1</h2><p><a href=\"https://www.luogu.com.cn/problem/P3455\">P3455 POI2007 ZAP-Queries</a></p>\n<p>求 $\\sum_{i=1}^n\\sum_{j=1}^m[\\gcd(i,j) = d]$。</p>\n<p>尽量往出现 $[\\gcd(i,j) = 1]$ 的方向推，因为这样才能用反演结论：</p>\n<p>$\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{m}{d}}[\\gcd(i,j) = 1]$</p>\n<p>把这个东西反演掉：</p>\n<p>$\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{m}{d}}\\sum_{t|\\gcd(i,j)}\\mu(t)$</p>\n<p>这个 $t|\\gcd(i,j)$ 的限制不好处理，怎么办？<strong>既然 $t$ 是变的，就要确定一个枚举顺序让它在更深的循环内不变</strong>：</p>\n<p>$\\sum_{t=1}^{\\min(\\frac{n}{d},\\frac{m}{d})}\\mu(t)\\sum_{t|\\gcd(i,j)}1$</p>\n<p>发现，只有当 $t|\\gcd(i,j)$ 的时候才有贡献，也就是说，只有当 $t|i$ 且 $t|j$ 时，才会被计算进去，而这样的数对 $(i,j)$ 的个数显然是 $\\frac{n}{dt}\\frac{m}{dt}$：</p>\n<p>$\\sum_{t=1}^{\\min(\\frac{n}{d},\\frac{m}{d})}\\mu(t)\\frac{n}{dt}\\frac{m}{dt}$</p>\n<p>发现，后面的 $\\frac{n}{dt}$ 和 $\\frac{m}{dt}$ 都是裸的整除分块，于是总时间复杂度就变成了 $O(\\sqrt n)$。</p>\n<p>一般的莫比乌斯反演题目，<strong>最后都要推到能够整除分块处理的式子上，否则复杂度会很高</strong>。</p>\n<h2 id=\"例题2\"><a href=\"#例题2\" class=\"headerlink\" title=\"例题2\"></a>例题2</h2><p><a href=\"https://www.luogu.com.cn/problem/P2568\">P2568 GCD</a></p>\n<p>求 $\\sum_{i=1}^n\\sum_{j=1}^n[\\gcd(i,j)\\in Prime]$。</p>\n<p>先枚举 $\\gcd$：</p>\n<p>$\\sum_{p\\in Prime}\\sum_{i=1}^{n}\\sum_{j=1}^n[\\gcd(i,j) = p]$</p>\n<p>写成 $[\\gcd(i,j) = 1]$ 的形式：</p>\n<p>$\\sum_{p\\in Prime}\\sum_{i=1}^{\\frac{n}{p}}\\sum_{j=1}^\\frac{n}{p}[\\gcd(i,j) = 1]$</p>\n<p>这时，已经可以开始反演了，但是我们实际上有两种思路可以选择：</p>\n<h3 id=\"思路1\"><a href=\"#思路1\" class=\"headerlink\" title=\"思路1\"></a>思路1</h3><p>既然反演结论已经出现，就直接反演掉：</p>\n<p>$\\sum_{p\\in Prime}\\sum_{i=1}^{\\frac{n}{p}}\\sum_{j=1}^{\\frac{n}{p}}\\sum_{d|\\gcd(i,j)}\\mu(d)$</p>\n<p>枚举 $d$：</p>\n<p>$\\sum_{p\\in Prime}\\sum_{d=1}^{\\frac{n}{p}}\\mu(d)(\\frac{n}{pd})^2$</p>\n<p>对于每个质数都用整除分块计算一遍，时间复杂度为 $O(n\\sqrt n)$，勉强可以通过。</p>\n<h3 id=\"思路2\"><a href=\"#思路2\" class=\"headerlink\" title=\"思路2\"></a>思路2</h3><p>如果我们令 $i\\geq j$，那么后面的就是 $\\sum_{i=1}^{\\frac{n}{p}}\\sum_{j=1}^{i}[\\gcd(i,j) = 1]$。</p>\n<p>把后面的单独拿出来看：</p>\n<p>$\\sum_{j=1}^{i}[\\gcd(i,j) = 1]$</p>\n<p>这不就是 $\\varphi(i)$ 吗！</p>\n<p>于是，原式化成 $\\sum_{p\\in Prime}\\sum_{i=1}^{\\frac{n}{p}}2\\cdot \\varphi(i)-1$。</p>\n<p>至于为啥后面的是 $2\\cdot \\varphi(i)-1$：</p>\n<p>首先，刚刚是令 $i\\geq j$，显然 $i\\leq j$ 时也是对称的，所以是 $2\\cdot \\varphi(i)$。</p>\n<p>其次，这两种情况的重叠部分只有 $[\\gcd(1,1) = 1]$，所以要减去 $1$。</p>\n<p>但是，如果你想的是直接算这个式子，那还是太天真了。</p>\n<p>把后面的东西提出来：</p>\n<p>$f(n) = \\sum_{i=1}^{n}2\\cdot \\varphi(i)-1$</p>\n<p><strong>这个 $f$ 是可以预处理的，因为它里面的值和上界 $n$ 没有关系。</strong></p>\n<p>也就是说，我们可以在线性筛的时候完成这个工作，之后只用把每个质数对应的 $f$ 加起来就行了。</p>\n<p>时间复杂度 $O(n)$。</p>\n<p>但是，这种思路的应用需要满足特定的条件，即这里的 $i$、$j$ 的枚举上界都是一样的，这样才符合 $\\varphi$ 函数的性质。</p>\n<h2 id=\"例题3\"><a href=\"#例题3\" class=\"headerlink\" title=\"例题3\"></a>例题3</h2><p><a href=\"https://www.luogu.com.cn/problem/P2257\">P2257 YY的GCD</a></p>\n<p>现在，不仅有了 $n$、$m$，还加入了多测，上面两种方法全都挂了。</p>\n<p>思路2已经不可用，只能顺着思路1继续推了（下面假设 $n\\leq m$）：</p>\n<p>$\\sum_{p\\in Prime}\\sum_{d=1}^{\\frac{n}{p}}\\mu(d)\\frac{n}{pd}\\frac{m}{pd}$</p>\n<p>看看这个式子，发现最毒瘤的地方是 $\\frac{n}{pd}$，这使它受到两个变量的制约，完全不能变换。</p>\n<p>怎么办？既然它是变的，我们枚举它就好了啊！</p>\n<p>令 $T = pd$：</p>\n<p>$\\sum_{T=1}^{n}\\frac{n}{T}\\frac{m}{T}\\sum_{p\\in Prime,p|T}\\mu(\\frac{T}{p})$</p>\n<p>看上去没有办法化简了呢（实际上我也确实不知道怎么化了），直接算的复杂度还是 $O(n^2)$，是否就这样挂了呢？</p>\n<p>注意到这里有一个很特殊的地方：$p|T$。</p>\n<p>既然 $T$ 是 $p$ 的倍数，那就可以用调和级数的复杂度预处理出后面的东西了！</p>\n<p>简单来说，就是枚举质数 $p$，将 $\\mu(kp)$ 贡献到它的倍数 $kp$ 上去，这样的复杂度是：</p>\n<p>$O(\\frac{n}{1}+\\frac{n}{2}+\\cdots+\\frac{n}{n}) = O(n\\log n)$</p>\n<p>于是，只用花 $O(n\\log n)$ 的时间预处理，花 $O(\\sqrt n)$ 的时间用整除分块算出答案，可以通过。</p>\n<h2 id=\"例题4\"><a href=\"#例题4\" class=\"headerlink\" title=\"例题4\"></a>例题4</h2><p><a href=\"https://www.luogu.com.cn/problem/SP3871\">SP3871 GCDEX - GCD Extreme</a></p>\n<p>求 $\\sum_{i=1}^{n}\\sum_{j=i+1}^n\\gcd(i,j)$。</p>\n<p>这里，求的不再是 $[\\gcd(i,j) = d]$，而是所有的 $\\gcd$。怎么办？枚举 $d$：</p>\n<p>$\\sum_{d=1}^nd\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=i+1}^\\frac{n}{d}[\\gcd(i,j) = 1]$</p>\n<h3 id=\"思路1-1\"><a href=\"#思路1-1\" class=\"headerlink\" title=\"思路1\"></a>思路1</h3><p>我是莫比乌斯反演的忠实粉丝，无论如何都要用反演做出来！</p>\n<p>$\\sum_{d=1}^nd\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=i+1}^{\\frac{n}{d}}\\sum_{k|\\gcd(i,j)}\\mu(k)$</p>\n<p>这里的 $j=i+1$ 有些限制发挥了，就改写成 $j=1$：</p>\n<p>$f(x) = \\sum_{d=1}^nd\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{n}{d}}\\sum_{k|\\gcd(i,j)}\\mu(k)$</p>\n<p>答案就是 $\\frac{f(x)-(1+2+\\cdots +n)}{2}$。</p>\n<p>提出 $k$：</p>\n<p>$\\sum_{d=1}^nd\\sum_{k=1}^{\\frac{n}{d}}\\mu(k)(\\frac{n}{dk})^2$</p>\n<p>令 $T = dk$：</p>\n<p>$\\sum_{T=1}^n(\\frac{n}{T})^2\\sum_{d|T}\\mu(\\frac{T}{d})d$</p>\n<p>（眼尖的同学已经可以把这道题秒了，因为后面的东西就是 $\\mu*Id = \\varphi$）</p>\n<p>注意到 $d|t$ 这个限制，又是熟悉的用调和级数复杂度预处理出来。</p>\n<p>前面的东西直接整除分块，时间复杂度为 $O(n\\log n+T\\sqrt n)$。</p>\n<h3 id=\"思路2-1\"><a href=\"#思路2-1\" class=\"headerlink\" title=\"思路2\"></a>思路2</h3><p>我是非常NB的选手，一眼就看出它是个欧拉函数！</p>\n<p>$\\sum_{d=1}^nd\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=i+1}^\\frac{n}{d}[\\gcd(i,j) = 1]$</p>\n<p>转换枚举顺序：</p>\n<p>$\\sum_{d=1}^nd\\sum_{i=2}^{\\frac{n}{d}}\\sum_{j=1}^{i-1}[\\gcd(i,j) = 1]$</p>\n<p>后面的东西就是 $\\varphi$：</p>\n<p>$\\sum_{d=1}^n\\sum_{i=2}^{\\frac{n}{d}}\\varphi(i)$</p>\n<p>后面的可以预处理出来，前面的可以整除分块做，时间复杂度为 $O(n+T\\sqrt n)$。</p>\n<p><strong>欧拉函数在一定条件下可以极大的简化推式子的过程，因为可以用 $\\mu$ 推的最后大概都能卷成 $\\varphi$。</strong></p>\n<h2 id=\"例题5\"><a href=\"#例题5\" class=\"headerlink\" title=\"例题5\"></a>例题5</h2><p><a href=\"https://www.luogu.com.cn/problem/P1891\">P1891 疯狂 LCM</a></p>\n<p>求 $\\sum_{i=1}^n\\operatorname{lcm}(i,n)$。</p>\n<p>$\\operatorname{lcm}$ 怎么求？这里有一个常见的转化技巧：</p>\n<p>$\\operatorname{lcm}(i,j) = \\frac{i\\cdot j}{\\gcd(i,j)}$</p>\n<p>（这个应该自己推一推就出来了）</p>\n<p>转化为（不要自作聪明把 $n$ 提出来，因为这里的除实际上是下取整）：</p>\n<p>$\\sum_{i=1}^n\\frac{i\\cdot n}{\\gcd(i,n)}$</p>\n<p>枚举 $\\gcd$：</p>\n<p>$\\sum_{d=1}^n\\sum_{i=1}^n\\frac{i\\cdot n}{d}[\\gcd(i,n) = d]$</p>\n<p>往 $\\gcd(i,j) = 1$ 上化：</p>\n<p>$\\sum_{d=1}^n\\sum_{i=1}^{\\frac{n}{d}}\\frac{i\\cdot d\\cdot n}{d}[\\gcd(i,\\frac{n}{d}) = 1]$</p>\n<p>整理一下：</p>\n<p>$n\\sum_{d=1}^n\\sum_{i=1}^{\\frac{n}{d}}i[\\gcd(i,\\frac{n}{d}) = 1]$</p>\n<h3 id=\"思路1-2\"><a href=\"#思路1-2\" class=\"headerlink\" title=\"思路1\"></a>思路1</h3><p>我爱莫反！</p>\n<p>$n\\sum_{d=1}^n\\sum_{i=1}^{\\frac{n}{d}}i\\sum_{k|\\gcd(i,\\frac{n}{d})}\\mu(k)$</p>\n<p>枚举 $k$：</p>\n<p>$n\\sum_{d=1}^n\\sum_{k|\\frac{n}{d}}\\mu(k)(k+2\\cdot k+\\lfloor\\frac{n}{dk}\\rfloor \\cdot k)$</p>\n<p>后面的调和级数复杂度预处理，前面的整除分块求答案，时间复杂度为 $O(n\\log n+T\\sqrt n)$。</p>\n<h3 id=\"思路2-2\"><a href=\"#思路2-2\" class=\"headerlink\" title=\"思路2\"></a>思路2</h3><p>这不是裸的欧拉函数吗！</p>\n<p>$n\\sum_{d=1}^n\\sum_{i=1}^{\\frac{n}{d}}i[\\gcd(i,\\frac{n}{d}) = 1]$</p>\n<p>众所周知，$\\sum_{i=1}^ni[\\gcd(i,n) = 1] = \\frac{n\\cdot \\varphi(n)}{2}$</p>\n<p>可以这样理解：如果 $x$ 不和 $n$ 互质，那么 $n-x$ 也不和 $n$ 互质，所以不和 $n$ 互质的数的平均值为 $\\frac{n}{2}$。</p>\n<p>所以，和 $n$ 互质的数的平均值也为 $\\frac{n}{2}$。</p>\n<p>于是，原式可化为：</p>\n<p>$n\\sum_{d=1}^n\\frac{\\frac{n}{d}\\cdot \\varphi(\\frac{n}{d})}{2}$</p>\n<p>直接整除分块即可做到 $O(n+T\\sqrt n)$ 的复杂度。</p>\n<h2 id=\"例题6\"><a href=\"#例题6\" class=\"headerlink\" title=\"例题6\"></a>例题6</h2><p><a href=\"https://www.luogu.com.cn/problem/P3911\">P3911 最小公倍数之和</a></p>\n<p>给你一些数 $a_1,a_2\\cdots a_n$，求 $\\sum_{i=1}^n\\sum_{j=1}^n\\operatorname{lcm}(a_i,a_j)$。</p>\n<p>直接求解不太可行，但是注意到题目中 $a_i\\leq 5\\cdot 10^4$ 的特殊限制，不难想到转化为求所有数的 $\\operatorname{lcm}$。</p>\n<p>$\\sum_{i=1}^n\\sum_{j=1}^n\\operatorname{lcm}(i,j)\\cdot c_i\\cdot c_j$</p>\n<p>其中 $c_i$ 代表值为 $i$ 的数的个数有多少个。</p>\n<p>将 $\\operatorname{lcm}$ 变成 $gcd$：</p>\n<p>$$</p>\n<h2 id=\"一些练习\"><a href=\"#一些练习\" class=\"headerlink\" title=\"一些练习\"></a>一些练习</h2><p><a href=\"https://www.luogu.com.cn/problem/P1447\">P1447 NOI2010 能量采集</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P5221\">P5221 Product</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P1829\">P1829 国家集训队Crash的数字表格</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P3327\">P3327 SDOI2015 约数个数和</a></p>\n<p>这些练习里面的技巧也有十分常用的，希望各位能够掌握。<del>主要还是我太懒了，不然会把里面的技巧一起总结的。</del></p>\n<h2 id=\"说在最后\"><a href=\"#说在最后\" class=\"headerlink\" title=\"说在最后\"></a>说在最后</h2><p>首先，上面的文字都是我口胡出来的，如有错误，还请指正。</p>\n<p>这些题目的代码都分散在博客中的各篇题解中（虽然那时我对莫反的理解还十分肤浅），有兴趣的同学可以自行查看。</p>\n<p>莫比乌斯反演是十分精深的学问，对技巧性要求很高，有时候，多见一个套路可能会让你豁然开朗，而推错方向、反演时机错误、漏掉一些东西、不能观察到式子中隐藏的性质，都有可能使你功亏一篑。</p>\n<p>所以请在做莫反题时保持耐心、开阔思路，实在推不出来时，也要对自己有信心，虚心的对照题解思考自己在哪一步出了问题、哪里没有想到。这类题不是死的，灵活性很强，而我们这种平凡人能做的，就是练习，熟能生巧啊。</p>\n","tags":["Knowledge","数学","数论","莫比乌斯反演"]},{"title":"干燥剂","url":"/2023/09/02/%E5%B9%B2%E7%87%A5%E5%89%82/","content":"<h1 id=\"干燥剂\"><a href=\"#干燥剂\" class=\"headerlink\" title=\"干燥剂\"></a>干燥剂</h1><h2 id=\"酸性干燥剂\"><a href=\"#酸性干燥剂\" class=\"headerlink\" title=\"酸性干燥剂\"></a>酸性干燥剂</h2><p>浓硫酸：原理是浓硫酸的吸水性，但由于浓硫酸有强酸性，所以不能干燥碱性气体如 $NH_3$，同时因为浓硫酸有强氧化性，所以不能干燥 $H_2S$，会反应生成 $S$。</p>\n<p>$P_2O_5$：原理为和水反应生成磷酸，所以只能干燥中性或酸性气体，碱性气体如 $NH_3$ 不能用其干燥。</p>\n<h2 id=\"碱性干燥剂\"><a href=\"#碱性干燥剂\" class=\"headerlink\" title=\"碱性干燥剂\"></a>碱性干燥剂</h2><p>碱石灰：主要成分是 $CaO$ 和 $NaOH$，原理是 $CaO$ 和水结合生成 $Ca(OH)_2$，因此它不能用来干燥酸性气体，如 $CO_2$，$NO_2$ 等。</p>\n<h2 id=\"中性干燥剂\"><a href=\"#中性干燥剂\" class=\"headerlink\" title=\"中性干燥剂\"></a>中性干燥剂</h2><p>$CuSO_4$：<strong>这不是干燥剂！</strong>可以和水反应形成 $CuSO_4\\cdot 5H_2O$，但是不能用于干燥，因为吸收不充分，不过由于颜色变化，常用来作为<strong>检验水存在</strong>的试剂。同时，$CuSO_4$ 不能用于检验含 $H_2S$ 的水气，因为 $CuSO_4+H_2S = CuS\\downarrow +H_2SO_4$。而且，它也不能用来检验含有 $NH_3$ 的气体，因为会形成络合物 $[Cu(NH_3)_4]SO_4$。</p>\n<h2 id=\"物理干燥剂\"><a href=\"#物理干燥剂\" class=\"headerlink\" title=\"物理干燥剂\"></a>物理干燥剂</h2><p>无水氯化钙：自身疏松多孔，对水有强吸附性，不能干燥的东西只有两个，$NH_3$ 和 $C_2H_5OH$，因为这两个东西可以和 $CaCl_2$ 化合，形成 $CaCl_2\\cdot 8NH_3$等。</p>\n<p>硅胶：成分为 $SiO_2$，干燥原理为吸附性，是物理性质，所以可以干燥几乎所有气体，但是不能干燥 $HF$，因为酸性太强可以和硅胶起反应。</p>\n","tags":["化学","文化课"]},{"title":"导数复习","url":"/2023/07/09/%E5%AF%BC%E6%95%B0%E5%A4%8D%E4%B9%A0/","content":"<h1 id=\"导数复习\"><a href=\"#导数复习\" class=\"headerlink\" title=\"导数复习\"></a>导数复习</h1><h2 id=\"常用技巧\"><a href=\"#常用技巧\" class=\"headerlink\" title=\"常用技巧\"></a>常用技巧</h2><p>放缩</p>\n<h2 id=\"T1\"><a href=\"#T1\" class=\"headerlink\" title=\"T1\"></a>T1</h2><h3 id=\"题面\"><a href=\"#题面\" class=\"headerlink\" title=\"题面\"></a>题面</h3><p>$f(x) = 2x-\\sin x-\\sqrt{a}\\ln x$</p>\n<p>若存在 $x_1,x_2(0&lt;x_1&lt;x_2)$，使 $f(x_1) = f(x_2)$，求证 $x_1x_2&lt;a$。</p>\n<span id=\"more\"></span>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><h4 id=\"初步判断\"><a href=\"#初步判断\" class=\"headerlink\" title=\"初步判断\"></a>初步判断</h4><p>第一眼看上去，$f(x)$ 里面竟然有三个基本函数！这直接硬导肯定没有出路。</p>\n<p>再看证明的是一个不等式，大概率就要用基本函数之间的关系放缩了。</p>\n<p>那么，我们就来想一想，这些函数之间的关系有哪些？</p>\n<h4 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h4><p>在 $x&gt;0$ 时，有：</p>\n<p>$x&gt;\\sin x$</p>\n<p>$\\ln x\\leq x-1$</p>\n<h4 id=\"尝试解答\"><a href=\"#尝试解答\" class=\"headerlink\" title=\"尝试解答\"></a>尝试解答</h4><p>$2x_1-\\sin x_1-\\sqrt{a}\\ln x_1 = 2x_2-\\sin x_2-\\sqrt{a}\\ln x_2$</p>\n<p>这里有一个技巧，因为我们要求的是关于 $a$ 的，所以把带 $a$ 的放一边。</p>\n<p>$2(x_1-x_2)-(\\sin x_1-\\sin x_2) = \\sqrt{a}(\\ln x_1-\\ln x_2)$</p>\n<p>先拿 $x&gt;\\sin x$ 放缩，就有 $\\sin x_1-\\sin x_2&lt;x_1-x_2$，带回原式。</p>\n<p>$x_1-x_2&lt;\\sqrt{a}(\\ln x_1-\\ln x_2)$</p>\n<p>$\\sqrt{a}&gt;\\frac{x_1-x_2}{\\ln x_1-\\ln x_2}$</p>\n<p>到这一步，很多同学肯定已经有了答案，这里还有一个隐含的，但是又非常常用的放缩没有提及：</p>\n<p>$\\frac{x_1-x_2}{\\ln x_1-\\ln x_2}&gt;\\sqrt{x_1x_2}$</p>\n<h4 id=\"补充知识\"><a href=\"#补充知识\" class=\"headerlink\" title=\"补充知识\"></a>补充知识</h4><p>众所周知，我们刚进高一时就学到了这样一个不等式：</p>\n<p>$\\frac{2}{\\frac{1}{a}+\\frac{1}{b}}\\leq \\sqrt{ab}\\leq \\frac{a+b}{2}\\leq \\sqrt{\\frac{a^2+b^2}{2}}$）（$a = b$ 时取等）</p>\n<p>现在，升到了高三，就必须知道对数不等式了：</p>\n<p>$\\sqrt{ab}&lt;\\frac{a-b}{\\ln a-\\ln b}&lt;\\frac{a+b}{2}$</p>\n<p>证明网上有很多，自己找着看，不难，里面的换元思想很重要。</p>\n<h4 id=\"最终解答\"><a href=\"#最终解答\" class=\"headerlink\" title=\"最终解答\"></a>最终解答</h4><p>知道了上面的不等式，就可以很简单地推出：</p>\n<p>$\\sqrt{a}&gt;\\sqrt{x_1x_2}$</p>\n<p>即 $x_1x_2&lt;a$。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>看到多个基本函数时不要慌，一个个放缩，化成一样的。</p>\n<p>一些常用的不等式要记得，有时候真的是棋差一着。</p>\n<p>这道题其实不难，对吧？</p>\n<h2 id=\"T2\"><a href=\"#T2\" class=\"headerlink\" title=\"T2\"></a>T2</h2><h3 id=\"题面-1\"><a href=\"#题面-1\" class=\"headerlink\" title=\"题面\"></a>题面</h3><p>当 $x&gt;2$ 时，$x\\ln(x-1)&lt;a(x-2)$ 有解，求 $a$ 的取值范围。</p>\n<h3 id=\"解析-1\"><a href=\"#解析-1\" class=\"headerlink\" title=\"解析\"></a>解析</h3><h4 id=\"初步判断-1\"><a href=\"#初步判断-1\" class=\"headerlink\" title=\"初步判断\"></a>初步判断</h4><p>两边的函数都很简单，并且只有两个初等函数，参变分离之后求导不难（而且题目里面的 $x&gt;2$ 相当于提示你把它除过去），考虑先参变分离，再求出含 $x$ 的函数的最小值。</p>\n<h4 id=\"工具-1\"><a href=\"#工具-1\" class=\"headerlink\" title=\"工具\"></a>工具</h4><p>$\\ln x\\leq x-1$</p>\n<h4 id=\"尝试解答-1\"><a href=\"#尝试解答-1\" class=\"headerlink\" title=\"尝试解答\"></a>尝试解答</h4><p>$a&gt;\\frac{x\\ln (x-1)}{x-2} = f(x)$</p>\n<p>$f^{‘}(x) = \\frac{\\frac{x^2-2x}{x-1}-2\\ln (x-1)}{(x-2)^2}$</p>\n<p>底下的东西和正负无关，去除。</p>\n<p>$\\frac{x^2-2x}{x-1}-2\\ln(x-1)$</p>\n<p>$(x-1)-\\frac{1}{x-1}-2\\ln(x-1)$</p>\n<p>一个飘带一个对数，都是单增的，不好判断正负，考虑放缩：</p>\n<p>$(x-1)-\\frac{1}{x-1}-2\\ln(x-1)&gt;(x-1)-\\frac{1}{x-1}-2x+4 = -x-\\frac{1}{x-1}+3$</p>\n<p>可惜，右边的在 $x$ 极大时为负，判断不了原式正负，放太大了。</p>\n<h4 id=\"再次观察\"><a href=\"#再次观察\" class=\"headerlink\" title=\"再次观察\"></a>再次观察</h4><p>$f^{‘}(2) = 0$</p>\n<p>这也是为什么不能放缩的原因，$x$ 取的非常近，容易有偏差。在不能放缩，且导函数值十分精确的情况下，考虑求二阶导。</p>\n<p>$f^{‘’}(x) = 1+\\frac{1}{(x-1)^2}-\\frac{2}{x-1}$</p>\n<p>这不就是个二次函数吗，对称轴：$\\frac{1}{x-1} = 1\\rightarrow x = 2$。</p>\n<p>$x&gt;2$ 时$f^{‘’}(x)&gt;0$。</p>\n<p>于是，$f^{‘}(x)$ 单增，$x&gt;2$ 时 $f^{‘}(x)&gt;0$，$f(x)$ 在 $x = 2$ 时取最小值。</p>\n<p>但是，我们还面临一个难题，$x = 2$ 时，$f(x)$ 没有意义。</p>\n<h4 id=\"扩展知识\"><a href=\"#扩展知识\" class=\"headerlink\" title=\"扩展知识\"></a>扩展知识</h4><p>我们发现，要求的实际上就是 $\\lim_{x\\rightarrow 2}\\frac{x\\ln (x-1)}{x-2}$。</p>\n<p>对于这种<strong>分子分母都是 $0$，或者都是正无穷</strong>的极限，就要用洛必达法则了。</p>\n<p>洛必达法则：$\\lim\\frac{f(x)}{g(x)} = \\lim\\frac{f^{‘}(x)}{g^{‘}(x)}$。</p>\n<h4 id=\"解法1\"><a href=\"#解法1\" class=\"headerlink\" title=\"解法1\"></a>解法1</h4><p>开洛！开导！</p>\n<p>$\\lim_{x\\rightarrow 2}\\frac{x\\ln (x-1)}{x-2} = \\lim_{x\\rightarrow 2}\\frac{\\ln(x-1)+\\frac{x}{x-1}}{1}$</p>\n<p>把 $x = 2$ 带进去，可以直接得到极限为 $2$。</p>\n<h4 id=\"解法2\"><a href=\"#解法2\" class=\"headerlink\" title=\"解法2\"></a>解法2</h4><p>看到 $\\ln$，第一个想到的应该是放缩。</p>\n<p>但是刚刚放一阶导不是失败了吗，为什么又要放呢？</p>\n<p>因为这题的条件十分特殊，我们要求的恰好是 $x = 2$ 时的极限。</p>\n<p>放缩，就是 $\\ln x\\leq x-1$，而这个等号从何而来？就是在 $x = 1$ 时取等！</p>\n<p>所以，当 $x = 2$ 时，$\\ln(x-1) = x-2$！</p>\n<p>于是，原式可化为 $\\frac{x(x-2)}{x-2} = x$。</p>\n<p>显然极限为 $2$。</p>\n<h4 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>要弄明白问题的实质，这里的放缩，有成有败，实际上是有原因的，自己要体会。</p>\n<p>洛必达法则虽然好用，但是解答题慎用，除非实在做不出来才用。</p>\n<h2 id=\"T3\"><a href=\"#T3\" class=\"headerlink\" title=\"T3\"></a>T3</h2><h3 id=\"题面-2\"><a href=\"#题面-2\" class=\"headerlink\" title=\"题面\"></a>题面</h3><p>存在 $a\\in R$，使得对任意 $x\\in [\\frac{1}{e},e]$，不等式 $\\ln x\\leq ax^2+bx\\leq (e^2-2e)\\ln x+e$ 恒成立，求 $b$ 的最小值。</p>\n<h3 id=\"解析-2\"><a href=\"#解析-2\" class=\"headerlink\" title=\"解析\"></a>解析</h3><h4 id=\"初步判断-2\"><a href=\"#初步判断-2\" class=\"headerlink\" title=\"初步判断\"></a>初步判断</h4><p>一般的双变量问题都是先定一个变量，之后再确定另一个的范围。</p>\n<p>但是，这道题中，$a$ 没有任何范围，我们不好处理。</p>\n<p>不过，中间的东西比较简洁，可以看成一个二次函数，但是这样不好让它在两个函数之间。</p>\n<p>考虑同时除 $x$，把中间的东西变成一个直线，就可以方便的放进去了。</p>\n<h4 id=\"尝试解答-2\"><a href=\"#尝试解答-2\" class=\"headerlink\" title=\"尝试解答\"></a>尝试解答</h4><p>$f(x) = \\frac{\\ln x}{x}$</p>\n<p>$f^{‘}(x) = \\frac{1-\\ln x}{x^2}$</p>\n<p>$g(x) = \\frac{(e^2-2e)\\ln x+e}{x}$</p>\n<p>$g^{‘}(x) = \\frac{e^2-2e-(e^2-2e)\\ln x-e}{x^2} = \\frac{(2e-e^2)\\ln x+e^2-3e}{x^2}$</p>\n<p><img src=\"https://s2.loli.net/2023/07/02/HXF6IboBYRMul3c.png\" alt=\"导数复习1\"></p>\n<p>截距的最小值就是 $P$ 作函数 $f(x)$ 的切线，这样才能保证这条直线在两个函数之间。</p>\n<p>设切点为 $(x_0,\\frac{\\ln x_0}{x_0})$。</p>\n<p>对于斜率，我们可以用两点式和导数分别算出，而且它们是相等的：</p>\n<p>$\\frac{e-1-\\frac{\\ln x_0}{x_0}}{e-x_0} = \\frac{1-\\ln x_0}{x_0^2}$</p>\n<p>解得 $x_0 = 1$。</p>\n<p>于是可以算出斜率等于 $\\frac{1-0}{1^2} = 1$，进而求出 $b = -1$。</p>\n<h4 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>这道题的主要难点在于想到用直线代替二次函数。</p>\n<h2 id=\"T4\"><a href=\"#T4\" class=\"headerlink\" title=\"T4\"></a>T4</h2><h3 id=\"题面-3\"><a href=\"#题面-3\" class=\"headerlink\" title=\"题面\"></a>题面</h3><p>已知直线 $y = kx+b$ 和函数 $y = e^x$ 相切于点 $(x_1,y_1)$，和函数 $y = \\ln x$ 相切于点 $(x_2,y_2)$，若 $x_2&gt;1$，且 $x_2\\in (n,n+1)$，$n \\in \\Z$，求 $n$。</p>\n<h3 id=\"解析-3\"><a href=\"#解析-3\" class=\"headerlink\" title=\"解析\"></a>解析</h3><h4 id=\"初步判断-3\"><a href=\"#初步判断-3\" class=\"headerlink\" title=\"初步判断\"></a>初步判断</h4><p>乍一看，好像有 $4$ 个变量，而且我们还真能列出 $4$ 个方程，但是，这样就会陷入繁杂的计算中，且最后得到的式子不会很优美（需要多次放缩）。</p>\n<p>不过，仔细分析一下，会发现 $y = kx+b$ 不就是公切线吗？那我们其实完全不用管 $k$ 和 $b$，它们被两个切点唯一确定了，于是只用找出两个切点之间的关系了。</p>\n<h4 id=\"尝试解答-3\"><a href=\"#尝试解答-3\" class=\"headerlink\" title=\"尝试解答\"></a>尝试解答</h4><p>我们可以把过两个点的切线分别写出来：</p>\n<p>$y = e^{x_1}x+e^{x_1}-e^{x_1}x_1$</p>\n<p>$y = \\frac{1}{x_2}x+\\ln x_2-1$</p>\n<p>由于是公切线，所以这两条直线的斜率和截距是相等的。</p>\n<p>$e^{x_1} = \\frac{1}{x_2}$</p>\n<p>$e^{x_1}-e^{x_1}x_1 = \\ln x_2-1$</p>\n<p>$\\frac{1}{x_2}(1+\\ln x_2) = \\ln x_2-1$</p>\n<p>$x_2\\ln x_2-x_2-\\ln x_2-1 = 0$</p>\n<p>有了这个方程，我们是肯定可以把 $x_2$ 解出来的，但是在高中阶段不是很可解，这也是为什么题目让我们求 $x_2$ 所处的区间。</p>\n<p>$f(x) = x\\ln x-x-\\ln x-1$</p>\n<p>$f^{‘}(x) = \\ln x+1-1-\\frac{1}{x} = \\ln x-\\frac{1}{x}$</p>\n<p>在 $x &gt; 2$ 时，$f^{‘}(x)&gt;0$，且 $f(2) = \\ln 2-3&lt;0$。</p>\n<p>$f(3)<0,f(4)<0,f(5)>0$，所以 $n = 4$。</p>\n<h4 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>这道题比较迷惑人的一点在于给出了毫无用处的 $y = kx+b$，所以今后做题一定要明确题目中各个变量之间的关系，尽量减少变量个数，以起到简化计算的效果。</p>\n<h2 id=\"T5\"><a href=\"#T5\" class=\"headerlink\" title=\"T5\"></a>T5</h2><h3 id=\"题面-4\"><a href=\"#题面-4\" class=\"headerlink\" title=\"题面\"></a>题面</h3><p>已知 $f(x) = ae^x-x^2$ 有两个极值点 $x_1,x_2$。若 $x_2\\geq 3x_1$ 时，$x_1+\\lambda x_2\\geq 2x_1x_2$ 恒成立，求 $\\lambda$ 的最小值。</p>\n<h3 id=\"解析-4\"><a href=\"#解析-4\" class=\"headerlink\" title=\"解析\"></a>解析</h3><h4 id=\"初步判断-4\"><a href=\"#初步判断-4\" class=\"headerlink\" title=\"初步判断\"></a>初步判断</h4><p>这种含有两个变量的题目叫做双变量问题，常见的处理方法有极值点偏移、单变量表示。这里既然给出了 $x_1,x_2$ 之间的倍数关系，就可以设 $t = \\frac{x_1}{x_2}$，这样即可以不用 $a$ 就把两个变量表示出来，也可以知道 $t$ 的范围。</p>\n<h4 id=\"尝试解答-4\"><a href=\"#尝试解答-4\" class=\"headerlink\" title=\"尝试解答\"></a>尝试解答</h4><p>令 $x_1 = tx_2$，则 $t\\leq \\frac{1}{3}$。</p>\n<p>下面的几步是常见的处理，主要目的是消掉 $a$，把 $x_1$ 代换为 $tx_2$，把 $t$ 看成已知量，解出用 $t$ 表示 $x_2$ 的式子，请第一次接触的读者深入理解：</p>\n<p>$ae^{x_1} = 2x_1$</p>\n<p>$ae^{x_2} = 2x_2$</p>\n<p>相除，消掉 $a$：</p>\n<p>$\\frac{e^{x_1}}{e^{x_2}} = \\frac{x_1}{x_2}$</p>\n<p>带入 $x_1 = tx_2$：</p>\n<p>$\\frac{e^{tx_2}}{e^{x_2}} = t$</p>\n<p>解出 $x_2$：</p>\n<p>$e^{tx_2} = te^{x_2}$</p>\n<p>$tx_2 = \\ln t+x_2$</p>\n<p>$x_2 = \\frac{\\ln t}{t-1}$</p>\n<p>$x_1 = tx_2 = \\frac{t\\ln t}{t-1}$</p>\n<p>（没看懂的再看一遍，之后用这种方法解题，都会直接解出 $x_1,x_2$，不会再写详细过程了）</p>\n<p>带入题面中不等式：</p>\n<p>$\\frac{t\\ln t}{t-1}+\\lambda \\frac{\\ln t}{t-1}\\geq 2\\frac{t\\ln^2t}{(t-1)^2}$</p>\n<p>$\\lambda\\geq \\frac{2t\\ln t}{t-1}-t = f(t)$</p>\n<p>$f^{‘}(t) = \\frac{2(\\ln t+1)(t-1)-2t\\ln t}{(t-1)^2}-1 = \\frac{2(t-\\ln t-1)}{(t-1)^2}-1$</p>\n<p>当 $f^{‘}(t)&gt;0$ 时，$2(t-\\ln t-1)\\geq (t-1)^2$，即 $t^2-4t+3+2\\ln t&lt;0$。</p>\n<p>这个东西不好直接看，再求导：</p>\n<p>$g^{‘}(t) = 2t-4+\\frac{2}{t}\\geq 2\\sqrt{2t\\frac{2}{t}}-4 = 0$</p>\n<p>所以前面的 $t^2-4t+3+2\\ln t$ 单增，又发现它在 $t = 1$ 时等于 $0$，于是在 $t\\in (0,1)$ 时小于 $0$，这覆盖了 $t$ 的范围。</p>\n<p>所以推出 $f^{‘}(t)$ 在 $(0,\\frac{1}{3})$ 内恒大于 $0$，即 $f(t)$ 单增。</p>\n<p>所以 $\\lambda$ 大于等于它的最大值 $f(\\frac{1}{3}) = \\ln 3-\\frac{1}{3}$。</p>\n<h4 id=\"总结-4\"><a href=\"#总结-4\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>在高中导数题中，双变量问题出现的频率很高，这里的单变量代替法是很常用的方法，适用于给出了两个变量之间的倍数关系的情况，否则可能会因为单变量没有范围而放大或放小。</p>\n<p>难点还是在求导，在肉眼看不出关系，又不好放缩时，多导几次是最好的选择，不过要注意导数之间 $&gt;0$ 和单增的区别，别弄混淆了。</p>\n<h2 id=\"T6\"><a href=\"#T6\" class=\"headerlink\" title=\"T6\"></a>T6</h2><h3 id=\"题面-5\"><a href=\"#题面-5\" class=\"headerlink\" title=\"题面\"></a>题面</h3><p>已知 $f(x) = 2\\sin x-\\ln (1+x)$，设 $f(x)$ 在 $(0,\\pi)$ 内的极值点为 $\\alpha$，零点为 $\\beta$，比较 $2\\alpha$ 和 $\\beta$ 的大小。</p>\n<h3 id=\"解析-5\"><a href=\"#解析-5\" class=\"headerlink\" title=\"解析\"></a>解析</h3><h4 id=\"初步分析\"><a href=\"#初步分析\" class=\"headerlink\" title=\"初步分析\"></a>初步分析</h4><p>先看看这个函数长什么样，之后再确定怎么做。</p>\n<h4 id=\"尝试解题\"><a href=\"#尝试解题\" class=\"headerlink\" title=\"尝试解题\"></a>尝试解题</h4><p>$f^{‘}(x) = 2\\cos x-\\frac{1}{1+x}$</p>\n<p>显然在 $x\\in (\\frac{\\pi}{2},\\pi)$ 时，$f^{‘}(x)&lt;0$，但是 $x\\in (0,\\frac{\\pi}{2})$ 时不好分析，直接求二阶导：</p>\n<p>$f^{‘’}(x) = -2\\sin x+\\frac{1}{(1+x)^2}$</p>\n<p>可以看出，它在 $(0,\\frac{\\pi}{2})$ 上单减。</p>\n<p>$f^{‘’}(0) = 1&gt;0,f^{‘’}(\\frac{\\pi}{2}) = -2+\\frac{1}{(1+\\frac{\\pi}{2})^2}&lt;-2+1&lt;0$</p>\n<p>所以，一定存在 $x_0$，使 $f^{‘’}(x_0) = 0$。</p>\n<p>于是，$f^{‘}(x)$ 在 $(0,x_0)$ 上单增，在 $(x_0,\\frac{\\pi}{2})$ 上单减。</p>\n<p>$f^{‘}(0) = 2-1&gt;0,f^{‘}(\\frac{\\pi}{2}) = -\\frac{1}{1+\\frac{\\pi}{2}}&lt;0$，所以在 $(0,x_0)$ 上都大于 $0$，之后减到小于 $0$，那么必然有一个点为 $0$，这既是极值点。</p>\n<p>我们确定了 $\\alpha \\in (0,\\frac{\\pi}{2})$。</p>\n<p>$f(0) = 0,f(\\frac{\\pi}{2}) = 2-\\ln(1+\\frac{\\pi}{2})&gt;2-\\frac{\\pi}{2}&gt;0$</p>\n<p>（这里用了 $\\ln x&lt;x-1$）</p>\n<p>于是，$f(x)$ 在 $(0,\\frac{\\pi}{2})$ 上都大于 $0$。</p>\n<p>$f(\\pi) = -\\ln(1+\\pi)&lt;0$，又因为 $f(x)$ 在 $(\\frac{\\pi}{2},\\pi)$ 上单调递减，所以 $f(x)$ 在 $(\\frac{\\pi}{2},\\pi)$ 上有一个零点。</p>\n<h4 id=\"再次分析\"><a href=\"#再次分析\" class=\"headerlink\" title=\"再次分析\"></a>再次分析</h4><p>求 $2\\alpha$ 和 $\\beta$ 的大小，其实就是比较 $f(2\\alpha)$ 和 $0$ 的大小，之后根据 $f(x)$ 在 $(\\alpha,\\pi)$ 上单调递减的性质即可推出大小关系。</p>\n<h4 id=\"继续解题\"><a href=\"#继续解题\" class=\"headerlink\" title=\"继续解题\"></a>继续解题</h4><p>根据极值点，我们可以知道下面的等式：</p>\n<p>$2\\cos \\alpha-\\frac{1}{1+\\alpha} = 0$</p>\n<p>再没有其它的条件了，开始算 $f(2\\alpha)$。</p>\n<p>$f(2\\alpha) = 2\\sin 2\\alpha-\\ln(1+2\\alpha) = 4\\sin \\alpha \\cos\\ \\alpha-\\ln(1+2\\alpha)$</p>\n<p>正好把条件用上：</p>\n<p>$f(2\\alpha) = \\frac{1}{1+\\alpha}2\\sin \\alpha-\\ln(1+2\\alpha)$</p>\n<p>接下来只能求导了，不过这里有一个技巧，把分式先提出来，因为它和大小无关，所以可以忽略它，接下来的式子就没有分式了，好导一些。</p>\n<p>$f(2\\alpha) = \\frac{1}{1+\\alpha}(2\\sin \\alpha-(1+\\alpha)\\ln(1+2\\alpha))$</p>\n<p>$f^{‘}(2\\alpha) = 2\\cos\\alpha-\\ln(1+2\\alpha)-2\\frac{\\alpha+1}{2\\alpha+1} = 2\\cos\\alpha-\\ln(1+2\\alpha)-1-\\frac{1}{2\\alpha+1}$</p>\n<p>$f^{‘’}(2\\alpha) = -2\\sin\\alpha-\\frac{2}{1+2\\alpha}+\\frac{2}{(1+2\\alpha)^2} = 2(-\\sin \\alpha-\\frac{1}{1+2\\alpha}+\\frac{1}{(1+2\\alpha)^2})$</p>\n<p>可以发现，后面的东西很类似于 $x^2-x$，然后这玩意在 $(0,1)$ 是恒小于 $0$ 的。</p>\n<p>可是，我们的 $\\alpha \\in (0,\\frac{\\pi}{2})$，所以 $0&lt;\\frac{1}{1+2\\alpha}&lt;1$，这不正好吗？</p>\n<p>前面的 $-\\sin \\alpha$ 显然小于 $0$，所以整个二阶导小于 $0$，也就是说一阶导单调递减。</p>\n<p>$f^{‘}(0) = 2-0-1-1 = 0$，所以整个一阶导也小于 $0$，也就是说 $f(2\\alpha)$ 单调递减。</p>\n<p>$f(0) = 1(0-0) = 0$，那不就恒小于 $0$ 了吗？</p>\n<p>于是，$f(2\\alpha)<0 = f(\\beta)$，所以 $2\\alpha>\\beta$。</p>\n<h4 id=\"总结-5\"><a href=\"#总结-5\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>遇到这种题不要怕，函数复杂的就先把函数的大概走势看清楚。</p>\n<p>导数题，就怕不求导，别看二阶导多么复杂的样子，实际上几阶导不都是导数吗，看不出来的再求导就完了。</p>\n<p>最后就是基本函数也要敏感一点，免得求导浪费时间。</p>\n<p>导数题，一切都为求导服务，所有的计算都是为了更清晰的看出函数的走势。</p>\n<h2 id=\"T7\"><a href=\"#T7\" class=\"headerlink\" title=\"T7\"></a>T7</h2><h3 id=\"题面-6\"><a href=\"#题面-6\" class=\"headerlink\" title=\"题面\"></a>题面</h3><p>$f(x) = e^x-x$，当 $t&gt;1$ 时，有 $\\frac{1}{f^{‘}(\\ln t)}&gt;\\frac{\\lambda}{f^{‘}(-\\ln t)}+\\frac{\\lambda+1}{\\ln t}$，求正实数 $\\lambda$ 的取值范围。</p>\n<h3 id=\"解析-6\"><a href=\"#解析-6\" class=\"headerlink\" title=\"解析\"></a>解析</h3><h4 id=\"初步分析-1\"><a href=\"#初步分析-1\" class=\"headerlink\" title=\"初步分析\"></a>初步分析</h4><p>所有的条件都在题目中，直接开做就完了。</p>\n<h4 id=\"尝试解答-5\"><a href=\"#尝试解答-5\" class=\"headerlink\" title=\"尝试解答\"></a>尝试解答</h4><p>$f^{‘}(x) = e^x-1$</p>\n<p>$\\frac{1}{t-1}&gt;\\frac{\\lambda}{\\frac{1}{t}-1}+\\frac{\\lambda+1}{\\ln t}$</p>\n<p>化简，得 $\\lambda&gt;\\frac{-\\ln t+t-1}{t\\ln t-t+1} = g(t)$</p>\n<p>$g^{‘}(t) = \\frac{\\ln^2t-t-\\frac{1}{t}+2}{(t\\ln t-t+1)^2} = \\ln^2t-t-\\frac{1}{t}+2$</p>\n<p>$g^{‘’}(t) = 2\\ln t\\frac{1}{t}-1+\\frac{1}{t^2} = 2t\\ln t-t^2+1$</p>\n<p>$g^{‘’’}(t) = 2\\ln t+2-2t$</p>\n<p>由于 $2\\ln t&lt;2t-2$，所以 $g^{‘’’}(t)&lt;0$，$g^{‘’}(t)$ 单减。</p>\n<p>$g^{‘’}(1) = 0$，所以 $g^{‘}(t)$ 单减。</p>\n<p>$g^{‘}(1) = 0$，所以 $g(t)$ 单减。</p>\n<p>于是，我们只要求出 $g(1)$，即可知道 $\\lambda$ 的最小值了。</p>\n<p>但是，$g(t)$ 在 $t = 1$ 时分子分母都是 $0$，于是可以开洛。</p>\n<p>$\\lim_{t\\rightarrow 1}\\frac{-\\ln t+t-1}{t\\ln t-t+1} = \\lim_{t\\rightarrow 1}\\frac{-\\frac{1}{t}+1}{\\ln t+1-1} = \\lim_{t\\rightarrow 1}\\frac{\\frac{1}{t^2}}{\\frac{1}{t}} = 1$</p>\n<h4 id=\"总结-6\"><a href=\"#总结-6\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>小清新导数题，只需要求出三阶导，即可快速判断单调性，再<del>合理</del>使用洛必达法则，即可快速出结果。</p>\n<h2 id=\"T8\"><a href=\"#T8\" class=\"headerlink\" title=\"T8\"></a>T8</h2><h3 id=\"题面-7\"><a href=\"#题面-7\" class=\"headerlink\" title=\"题面\"></a>题面</h3><p>对于正实数 $a$ 有 $f(x) = e^{x+1}-a\\ln x-\\ln\\frac{a^a}{e^a}\\geq 0$ 在定义域内恒成立，求 $a$ 的取值范围。</p>\n<h3 id=\"解析-7\"><a href=\"#解析-7\" class=\"headerlink\" title=\"解析\"></a>解析</h3><h4 id=\"初步判断-5\"><a href=\"#初步判断-5\" class=\"headerlink\" title=\"初步判断\"></a>初步判断</h4><p>简洁的题面，开导就完事了。</p>\n<h4 id=\"尝试解答-6\"><a href=\"#尝试解答-6\" class=\"headerlink\" title=\"尝试解答\"></a>尝试解答</h4><p>$f(x) = e^{x+1}-a\\ln x-a\\ln a+a$</p>\n<p>$f^{‘}(x) = e^{x+1}-\\frac{a}{x}$</p>\n<p>容易发现导函数是单调递增的，所以只存在一个点 $x_0$，使得 $e^{x_0+1} = \\frac{a}{x_0}$。</p>\n<p>在 $(0,x_0)$ 上，$f^{‘}(x)&lt;0$；在 $(x_0,+\\infty)$ 上，$f^{‘}(x)&gt;0$。</p>\n<p>所以，$f(x)$ 在 $x_0$ 处取得最小值。</p>\n<p>$f(x_0) = \\frac{a}{x_0}-a\\ln a+ax_0+a-a\\ln a+a = \\frac{a}{x_0}-2a\\ln a+ax_0+2a$</p>\n<p>$\\frac{1}{x_0}-2\\ln a+x_0+2\\geq 0$</p>\n<p>$2\\ln a\\leq x_0+\\frac{1}{x_0}+2$</p>\n<p>右边的用均值不等式，可以看出最小值为 $4$，此时 $x_0 = 1$。于是左边的最大值就是 $4$，所以 $2\\ln a\\leq 4$，$a\\in (0,e^2]$。</p>\n","tags":["数学","文化课","导数"]},{"title":"并查集总结","url":"/2023/02/07/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%80%BB%E7%BB%93/","content":"<h1 id=\"并查集总结\"><a href=\"#并查集总结\" class=\"headerlink\" title=\"并查集总结\"></a>并查集总结</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>并查集，通过将一些元素划分到同一个集合，从而实现维护归属，连通性等功能。</p>\n<p>不要把并查集和子树搞混，虽然二者都有父子关系，但是子树更强调级别的不同，属于一个数统领下面的数，而并查集中的元素是平等的，强调的是它们都属于同一个集合，而并查集就是维护这个集合。</p>\n<span id=\"more\"></span>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>并查集的维护只需要一个数组：fa，代表每个点的父亲。初始时，每个点的 fa 都是自己本身。</p>\n<p>由于合并方式的不同，一个集合的根可能是集合中的任意一个数，但是，一个集合中，只有一个 fa 等于自己的数，它就是集合的根，如果要查询两个数是否在同一集合中，只用查询根是否相同。</p>\n<p>如果要合并两个集合，就是把其中一个集合的根的父亲设为另一个集合的根。</p>\n<p>伪代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> root[x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    x = <span class=\"built_in\">get</span>(x),y = <span class=\"built_in\">get</span>(y);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x == y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    x = <span class=\"built_in\">get</span>(x),y = <span class=\"built_in\">get</span>(y);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == y) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    father[x] = y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，merge 函数除了维护父亲外，还可能维护集合大小，距离等其他信息，所以要判断是否是不同的集合，才能保证合并后的信息正确。</p>\n<p>get 函数常见的实现方式有两种。</p>\n<ol>\n<li><p>朴素求解</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == fa[x]) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">get</span>(fa[x]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度最高可达 $O(n)$。</p>\n</li>\n<li><p>路径压缩</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == fa[x]) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fa[x] = <span class=\"built_in\">get</span>(fa[x]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以这样做，是因为一个集合内，我们只关心谁是根，所以把所有点的父亲都设为根也不会影响，并且还能减小递归的次数。</p>\n<p>可以证明，这样做的时间复杂度最差为 $O(\\log n)$，平均下来接近 $O(1)$。</p>\n</li>\n</ol>\n<p>但是，第一种方法的时间复杂度，很大程度上被合并集合的方式决定，如果加上启发式合并的技巧，即每次把大小较小的集合合并到较大的集合中，这样每次集合的大小至少变成原来的 $2$ 倍，最多合并 $O(\\log n)$ 次，最终深度也是 $O(\\log n)$。</p>\n<p>这也是常说的“按秩合并”。</p>\n<p>这两种合并方法都要求掌握（毕竟都不难嘛），因为有时候，我们不能改变原来的形态，这时就只能用按秩合并了。</p>\n<p>两种方法同时用，效果更好，复杂度接近线性。</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P3367\">P3367 【模板】并查集</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,fa[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x == fa[x]) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fa[x] = <span class=\"built_in\">get</span>(fa[x]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) fa[i] = i;</span><br><span class=\"line\">\t<span class=\"type\">int</span> op,x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\tx = <span class=\"built_in\">get</span>(x);</span><br><span class=\"line\">\t\ty = <span class=\"built_in\">get</span>(y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x!=y) fa[x] = y; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;(x == y?<span class=\"string\">&#x27;Y&#x27;</span>:<span class=\"string\">&#x27;N&#x27;</span>)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"边带权并查集\"><a href=\"#边带权并查集\" class=\"headerlink\" title=\"边带权并查集\"></a>边带权并查集</h2><p><a href=\"https://www.luogu.com.cn/problem/P1196\">P1196 [NOI2002] 银河英雄传说</a></p>\n<p>合并操作大家肯定都会，但是询问时还要输出之间的距离，这该怎么办呢？</p>\n<p>并查集的合并，本质上就是一个集合的根向另一个集合的根连边，只不过我们没有真正的建出边。那么，只要把这个边的边权赋值为 $1$，统计两点之间的边权和，不就是它们之间的距离吗。</p>\n<p>具体的，对每个点维护一个 $dis$，表示它到它所在集合根的距离。根据定义，$dis$ 初始为 $0$。</p>\n<p>每次合并时，我们只更新根的 $dis$，将它设为另一个集合原来的大小，表示它前面有这么多艘舰艇。</p>\n<p>又怎么确保每个点 $dis$ 的正确呢？在执行 get 操作时，一个点的 $dis$ 要加上它父亲的 $dis$，由于根的 $dis$ 在合并时就已经修改，所以后面的 $dis$ 就都是正确的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> t,fa[<span class=\"number\">30005</span>],d[<span class=\"number\">30005</span>],size[<span class=\"number\">30005</span>],a,b;</span><br><span class=\"line\"><span class=\"type\">char</span> com;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x == fa[x]) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> root = <span class=\"built_in\">get</span>(fa[x]);</span><br><span class=\"line\">\td[x] += d[fa[x]];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fa[x] = root;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\ta = <span class=\"built_in\">get</span>(a),b = <span class=\"built_in\">get</span>(b);</span><br><span class=\"line\">\tfa[a] = b,d[a] = size[b],size[b]+=size[a];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=<span class=\"number\">30005</span>;i++) fa[i] = i</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=<span class=\"number\">30005</span>;i++) size[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;t;k++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;com&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (com == <span class=\"string\">&#x27;M&#x27;</span>) <span class=\"built_in\">merge</span>(a,b);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">get</span>(a) == <span class=\"built_in\">get</span>(b)) cout&lt;&lt;<span class=\"built_in\">abs</span>(d[a]-d[b])<span class=\"number\">-1</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"扩展域并查集\"><a href=\"#扩展域并查集\" class=\"headerlink\" title=\"扩展域并查集\"></a>扩展域并查集</h2><p><a href=\"https://www.luogu.com.cn/problem/P2024\">P2024 [NOI2001] 食物链</a></p>\n<p>这道题边带权和扩展域都可以做，实际上边带权的空间复杂度更小，但是扩展域更容易理解，这里就讲解扩展域。</p>\n<p>把每个动物拆成三个点，表示它的同类，天敌和食物，即我们扩展了一个动物的域。</p>\n<p>如果说 $x,y$ 是同类，说明它们的三个点所在的集合相同，分别合并这三个点。</p>\n<p>如果说 $x$ 吃 $y$，即 $x$ 的食物是 $y$ 的同类，$y$ 的天敌是 $x$ 的同类，又因为食物链是环形的，所以 $y$ 的食物是 $x$ 的天敌。</p>\n<p>每次合并前，检查这句话是不是对的。</p>\n<p>如果说是同类，但是出现 $x$ 吃 $y$ 或 $y$ 吃 $x$ 就不对。</p>\n<p>如果说 $x$ 吃 $y$，但是出现 $y$ 吃 $x$ 或 $x$ 和 $y$ 是同类就不对。</p>\n<p><del>（代码就不放了，我写的边带权，先咕掉！）</del></p>\n<h2 id=\"可撤销并查集\"><a href=\"#可撤销并查集\" class=\"headerlink\" title=\"可撤销并查集\"></a>可撤销并查集</h2><p><a href=\"https://www.luogu.com.cn/problem/CF1444C\">Team-Building</a></p>\n<p>在讲这道题之前，先说说撤销和删除的区别。</p>\n<p>撤销，只能是从最后一个操作开始；而删除，可以是对任何一个操作。</p>\n<p>我们所说的可撤销并查集，就是能回退<strong>最后进行的若干个操作</strong>的并查集。</p>\n<p>判断是否是二分图，就是判断是否存在奇环，而常见的方法就是染色，如果一个边连接的两个点颜色相同，则存在奇环、</p>\n<p>正难则反，考虑求出存在奇环的图的个数。</p>\n<p>由于是黑白染色，我们将每个点用两个点表示，分别代表它染黑色和白色，即使用扩展域并查集。</p>\n<p>先在每个组内部连边，看是否有点的黑白点在同一个集合中，如果有，即存在奇环。</p>\n<p>而剩下的集合要两两合并，再判断，时间上肯定不允许。</p>\n<p>我们发现，其实边只有 $5e5$ 个，可以从边入手。</p>\n<p>每次处理连接的集合相同的所有边，看是否存在奇环，之后把这些边都撤销，再处理后面的边。</p>\n<p> 具体怎么撤销呢？我们要记录下连边前，发生改变的两个集合的根的所有信息，之后把这些信息按时间顺序（先还原后发生的）倒着还原回去就行了。</p>\n<p>由于这里只改变两个集合的根的信息，所以<strong>只能使用按秩合并</strong>。</p>\n<p>复杂度显然还是 $O(n\\log n)$，因为每个边都只被加入一次，删除一次。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,k,c[N],fa[N*<span class=\"number\">2</span>],sz[N*<span class=\"number\">2</span>],ok[N],bakFa[N*<span class=\"number\">2</span>],bakSz[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125; edge[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (fa[x]!=x) x = fa[x];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(e x,e y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (c[x.x]!=c[y.x]) <span class=\"keyword\">return</span> c[x.x]&lt;c[y.x];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c[x.y]&lt;c[y.y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mer</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (sz[x]&gt;sz[y]) <span class=\"built_in\">swap</span>(x,y);</span><br><span class=\"line\">\tfa[x] = y;</span><br><span class=\"line\">\tsz[y]+=sz[x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clr</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!l || !r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=r;i&gt;=l;i--)&#123;</span><br><span class=\"line\">\t\tfa[bakFa[i]] = bakFa[i];</span><br><span class=\"line\">\t\tsz[bakSz[i]]-=sz[bakFa[i]];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++) ok[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) fa[i] = i,fa[i+n] = i+n,sz[i] = sz[i+n] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;c[i];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;edge[i].x&gt;&gt;edge[i].y;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[edge[i].x]&gt;c[edge[i].y]) <span class=\"built_in\">swap</span>(edge[i].x,edge[i].y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[edge[i].x] == c[edge[i].y])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> x = <span class=\"built_in\">get</span>(edge[i].x),y = <span class=\"built_in\">get</span>(edge[i].y+n);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x!=y) <span class=\"built_in\">mer</span>(x,y);</span><br><span class=\"line\">\t\t\tx = <span class=\"built_in\">get</span>(edge[i].x+n),y = <span class=\"built_in\">get</span>(edge[i].y);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x!=y) <span class=\"built_in\">mer</span>(x,y);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">get</span>(edge[i].x) == <span class=\"built_in\">get</span>(edge[i].x+n) || <span class=\"built_in\">get</span>(edge[i].y) == <span class=\"built_in\">get</span>(edge[i].y+n)) ok[c[edge[i].x]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++) <span class=\"keyword\">if</span> (ok[i]) ans++;</span><br><span class=\"line\">\tans = ans*(ans<span class=\"number\">-1</span>)/<span class=\"number\">2</span>; <span class=\"comment\">//OK</span></span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(edge+<span class=\"number\">1</span>,edge+<span class=\"number\">1</span>+m,cmp);</span><br><span class=\"line\">\t<span class=\"type\">int</span> lasx = <span class=\"number\">0</span>,lasy = <span class=\"number\">0</span>,las = <span class=\"number\">0</span>,fl = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (c[edge[i].x] == c[edge[i].y] || !ok[c[edge[i].x]] || !ok[c[edge[i].y]]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!(lasx == c[edge[i].x] &amp;&amp; lasy == c[edge[i].y]))&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">clr</span>(las,(i<span class=\"number\">-1</span>)*<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\tans-=fl;</span><br><span class=\"line\">\t\t\tlas = i*<span class=\"number\">2</span><span class=\"number\">-1</span>,lasx = c[edge[i].x],lasy = c[edge[i].y];</span><br><span class=\"line\">\t\t\tfl = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = <span class=\"built_in\">get</span>(edge[i].x),y = <span class=\"built_in\">get</span>(edge[i].y+n);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x!=y)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (sz[x]&gt;sz[y]) <span class=\"built_in\">swap</span>(x,y);</span><br><span class=\"line\">\t\t\tbakFa[i*<span class=\"number\">2</span><span class=\"number\">-1</span>] = x,bakSz[i*<span class=\"number\">2</span><span class=\"number\">-1</span>] = y;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">mer</span>(x,y);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tx = <span class=\"built_in\">get</span>(edge[i].x+n),y = <span class=\"built_in\">get</span>(edge[i].y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x!=y)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (sz[x]&gt;sz[y]) <span class=\"built_in\">swap</span>(x,y);</span><br><span class=\"line\">\t\t\tbakFa[i*<span class=\"number\">2</span>] = x,bakSz[i*<span class=\"number\">2</span>] = y;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">mer</span>(x,y);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">get</span>(edge[i].x) == <span class=\"built_in\">get</span>(edge[i].x+n) || <span class=\"built_in\">get</span>(edge[i].y) == <span class=\"built_in\">get</span>(edge[i].y+n)) fl = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tans-=fl;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"可持久化并查集\"><a href=\"#可持久化并查集\" class=\"headerlink\" title=\"可持久化并查集\"></a>可持久化并查集</h2><p>本质上是一个可持久化数组，因为还原某一次操作的状态，就是还原 $fa$ 的状态。</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P3402\">P3402 可持久化并查集</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,glonow,rt[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tre</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lc,rc,v,dep;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">SegT</span>&#123;</span><br><span class=\"line\">\ttre tr[N*<span class=\"number\">30</span>];</span><br><span class=\"line\">\t<span class=\"type\">int</span> tot;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t\tnode = ++tot;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">\t\t\ttr[node].v = l;</span><br><span class=\"line\">\t\t\ttr[node].dep = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> node;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\ttr[node].lc = <span class=\"built_in\">build</span>(tr[node].lc,l,mid);</span><br><span class=\"line\">\t\ttr[node].rc = <span class=\"built_in\">build</span>(tr[node].rc,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> node;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">clone</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">\t\ttr[++tot] = tr[node];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> beg,<span class=\"type\">int</span> en,<span class=\"type\">int</span> v,<span class=\"type\">int</span> mode)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (beg&gt;r || en&lt;l) <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">\t\tnode = <span class=\"built_in\">clone</span>(node);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (beg&gt;=l &amp;&amp; en&lt;=r)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (mode == <span class=\"number\">1</span>) tr[node].v = v;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> tr[node].dep = <span class=\"built_in\">max</span>(tr[node].dep,v+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> node;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttr[node].lc = <span class=\"built_in\">update</span>(tr[node].lc,l,r,beg,(beg+en)&gt;&gt;<span class=\"number\">1</span>,v,mode);</span><br><span class=\"line\">\t\ttr[node].rc = <span class=\"built_in\">update</span>(tr[node].rc,l,r,((beg+en)&gt;&gt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>,en,v,mode);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> node;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> beg,<span class=\"type\">int</span> en)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (beg&gt;r || en&lt;l) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (beg&gt;=l &amp;&amp; en&lt;=r) <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(tr[node].lc,l,r,beg,(beg+en)&gt;&gt;<span class=\"number\">1</span>)+<span class=\"built_in\">query</span>(tr[node].rc,l,r,((beg+en)&gt;&gt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>,en);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\trt[<span class=\"number\">0</span>] = t.<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret = t.<span class=\"built_in\">query</span>(rt[glonow],x,x,<span class=\"number\">1</span>,n),now = t.tr[ret].v;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (now == x) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">get</span>(now);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"built_in\">init</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> op,a,b,dep1,dep2;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op&gt;&gt;a;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op!=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;b;</span><br><span class=\"line\">\t\t\ta = <span class=\"built_in\">get</span>(a);</span><br><span class=\"line\">\t\t\tb = <span class=\"built_in\">get</span>(b);</span><br><span class=\"line\">\t\t\tdep1 = t.tr[a].dep;</span><br><span class=\"line\">\t\t\tdep2 = t.tr[b].dep;</span><br><span class=\"line\">\t\t\ta = t.tr[a].v;</span><br><span class=\"line\">\t\t\tb = t.tr[b].v;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (dep1&gt;dep2)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">swap</span>(dep1,dep2);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">swap</span>(a,b);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\trt[i] = t.<span class=\"built_in\">update</span>(rt[i<span class=\"number\">-1</span>],a,a,<span class=\"number\">1</span>,n,b,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t\trt[i] = t.<span class=\"built_in\">update</span>(rt[i],b,b,<span class=\"number\">1</span>,n,dep1,<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\trt[i] = rt[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t\t\tcout&lt;&lt;(a == b?<span class=\"number\">1</span>:<span class=\"number\">0</span>)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> rt[i] = rt[a];</span><br><span class=\"line\">\t\tglonow = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><p><a href=\"https://www.luogu.com.cn/problem/CF1713E\">Cross Swapping</a></p>\n<p>注意到 $(i,j)$ 和 $(j,i)$ 是否交换，完全取决于 $k = i$ 和 $k = j$ 时是否交换，由于只有是和否两种选择，所以可以用扩展域并查集。</p>\n<p>具体的，对于每个 $a_{i,j}$，如果 $a_{i,j}&gt;a_{j,i}$，那么合并 $i$ 的是和 $j$ 的否，$i$ 的否和 $j$ 的是。</p>\n<p>如果 $a_{i,j}&lt;a_{j,i}$，那么合并 $i$ 的是和 $j$ 的是，$i$ 的否和 $j$ 的否。</p>\n<p>合并之前，看一下能否合并即可。</p>\n<h2 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h2><p><a href=\"https://www.luogu.com.cn/problem/P4185\">P4185 [USACO18JAN]MooTube G</a></p>\n<p>并查集常见的应用是维护连通性，如最小生成树的 Kruskal 算法。</p>\n<p>由于只有询问操作，先把询问离线下来。</p>\n<p>之后一个很经典的 trick 是对询问排序，然后一个个加入符合要求的边。</p>\n<p>之所以不能一个个删，是因为并查集很难支持删除功能，但加入却很容易，这也是以后做题中需要考虑的问题。</p>\n<h2 id=\"例3\"><a href=\"#例3\" class=\"headerlink\" title=\"例3\"></a>例3</h2><p><a href=\"https://www.luogu.com.cn/problem/P2502\">P2502 [HAOI2006]旅行</a></p>\n<p>考虑到边的数量很小，我们可以对边排序，之后选定一个起点，不断加入后面的边，这样就能枚举所有可能。</p>\n<p>并查集的作用就是维护两点间连通性。</p>\n<h2 id=\"例4\"><a href=\"#例4\" class=\"headerlink\" title=\"例4\"></a>例4</h2><p><a href=\"https://www.luogu.com.cn/problem/CF292D\">Connected Components</a></p>\n<p>这道题就比较有意思了，因为 $n$ 非常小，我们可以对每个前后缀都存下当时的 $fa$ 数组。</p>\n<p>每次询问的时候合并前缀后缀即可。</p>\n<h2 id=\"例5\"><a href=\"#例5\" class=\"headerlink\" title=\"例5\"></a>例5</h2><p><a href=\"https://www.luogu.com.cn/problem/CF466E\">Information Graph</a></p>\n<p>先把所有边都加入，建立信息网，由于这里有复杂的父子关系，所以要保留原来的结构，用按秩合并。</p>\n<p>对于每个发文件的操作，在建图的过程中，找到当时的根（最后一个看文件的人），查询一个人是否看过某文件，即查询它是否在传文件的人和最后看文件的人的路径上。</p>\n<p>建出来的图显然是个森林，查询一个点是否在某条深度不增的链上，可以通过两次 LCA 解决。具体的，设拿到文件的人为 $x$，最后看文件的人为 $y$，现在查询的人为 $z$，则 $z$ 在 $x,y$ 的路径上，当且仅当 $lca(x,z) = z,lca(y,z) = y$。当然，$z$ 首先要在 $x,y$ 所在的树上，这可以用并查集解决。</p>\n<p>在这道题中，并查集更像是辅助作用，可以快速判断连通性和一个点的最远祖先。</p>\n","tags":["Knowledge","并查集"]},{"title":"数位 DP 入门","url":"/2022/11/21/%E6%95%B0%E4%BD%8D-DP-%E5%85%A5%E9%97%A8/","content":"<h1 id=\"数位-DP-入门\"><a href=\"#数位-DP-入门\" class=\"headerlink\" title=\"数位 DP 入门\"></a>数位 DP 入门</h1><h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><p><a href=\"https://www.luogu.com.cn/problem/P2602\">P2602 [ZJOI2010] 数字计数</a></p>\n<p>求 $[a,b]$ 间的数每个数位出现了多少次。</p>\n<p>容易发现，暴力求解中包含了许多重复计算，如 $1000$~$1999$ 和 $2000$~$2999$ 中后 $3$ 位单独拎出来看，是完全一样的。</p>\n<span id=\"more\"></span>\n<p>于是，我们可以计算出 $0$~$9$，$0$~$99$，$0$~$999$ 之类的区间内的答案。</p>\n<p>比方说，我们要求出 $0$~$65536$ 中所有数位出现的次数，则可以先求出 $0$~$59999$ 的答案，再求出 $60000$~$64999$，$65000$~$65499$，$65500$~$65529$，$65530$~$65536$ 的答案。</p>\n<p>假设我们已经求出了 $0~9999$ 的答案，那么 $1$~$59999$ 的后四位不就相当于 $6$ 个这种东西吗？至于万位的，显然是 $1$ 到 $5$ 各 $10000$ 个，把这些贡献加起来即可。</p>\n<p>再求 $60000$~$64999$ 的贡献，先算万位，就是 $5000$ 个 $6$，之后的后四位，不就是前面的问题的子问题吗？</p>\n<p>这样不断缩小问题的规模，就能求解了。</p>\n<p>再来看如何求出 $0$~$9\\cdots 9$ 中各数位的数量。</p>\n<p>显然，$0$~$9$ 中就是各个数字出现一次。</p>\n<p>$0$~$99$ 中，个位相当于 $10$ 个前面的子问题，十位显然是各个数字出现 $10$ 次（假设我们允许前导 $0$，其实你也发现了，我们求答案的过程中，除了第一个可能前面没有数，后面的前面都填了数，所以前导 $0$ 是合法的）。</p>\n<p>后面的都是一模一样的子问题，直接递推求解即可。</p>\n<p>于是，我们可以写出下面的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">//预处理</span></span><br><span class=\"line\">\tten[<span class=\"number\">0</span>] = <span class=\"number\">1</span>; <span class=\"comment\">//预处理出10^i</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=<span class=\"number\">9</span>;i++) f[<span class=\"number\">0</span>][i] = <span class=\"number\">1</span>; <span class=\"comment\">//初始化边界</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">12</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">9</span>;j++) f[i][j] = f[i<span class=\"number\">-1</span>][j]*<span class=\"number\">10</span>+ten[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">        ten[i] = ten[i<span class=\"number\">-1</span>]*<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，你有没有发现，其实 $0$ 到 $9$ 各个数字出现的次数是相同的！</p>\n<p>也就是说，我们只用计算一个即可。</p>\n<p>Code：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">int</span> dig[<span class=\"number\">15</span>];</span><br><span class=\"line\">ll a,b,f[<span class=\"number\">15</span>],ten[<span class=\"number\">15</span>],ans[<span class=\"number\">15</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tten[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">12</span>;i++)&#123;</span><br><span class=\"line\">\t\tf[i] = f[i<span class=\"number\">-1</span>]*<span class=\"number\">10</span>+ten[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\tten[i] = ten[i<span class=\"number\">-1</span>]*<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">calc</span><span class=\"params\">(ll x,<span class=\"type\">int</span> flag)</span></span>&#123; <span class=\"comment\">//计算0到x中各个数出现的次数，flag表示是加到还是减到答案里面 </span></span><br><span class=\"line\">\t<span class=\"type\">int</span> tot = <span class=\"number\">0</span>; <span class=\"comment\">//x的位数</span></span><br><span class=\"line\">\tll tmp = x;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (tmp)&#123; <span class=\"comment\">//把各位上的数提出来</span></span><br><span class=\"line\">\t\tdig[++tot] = tmp%<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\ttmp/=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=tot;i&gt;=<span class=\"number\">1</span>;i--)&#123; <span class=\"comment\">//根据我们的算法，从高位到低位依次求解 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">9</span>;j++) ans[j]+=f[i<span class=\"number\">-1</span>]*dig[i]*flag; <span class=\"comment\">//减掉dig[i]本身,加上一个0,就是dig[i]个 </span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;dig[i];j++) ans[j]+=ten[i<span class=\"number\">-1</span>]*flag; <span class=\"comment\">//当前位上的数的贡献</span></span><br><span class=\"line\">\t\tx-=ten[i<span class=\"number\">-1</span>]*dig[i],ans[dig[i]]+=(x+<span class=\"number\">1</span>)*flag; <span class=\"comment\">//由于后面的数也会对当前位产生贡献,就在这里先算了</span></span><br><span class=\"line\">\t\tans[<span class=\"number\">0</span>]-=ten[i<span class=\"number\">-1</span>]*flag; <span class=\"comment\">//最后减去前导0的贡献</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">calc</span>(b,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">calc</span>(a<span class=\"number\">-1</span>,<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=<span class=\"number\">9</span>;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h2><p><a href=\"https://www.luogu.com.cn/problem/P2657\">P2657 [SCOI2009] windy 数</a></p>\n<p>设 $f[i][j][0/1]$ 表示从小到大第 $i$ 位填 $j$ 的方案数，$0/1$ 代表是否顶格。</p>\n<p>显然，我们只能从 $f[i-1][k][0/1]$ 转移过来，其中 $abs(j-k)\\geq 2$。</p>\n<p>显然，如果当前就没有顶格，那么 $i-1$ 位显然也要按不顶格处理。</p>\n<p>如果当前顶格，那么 $i-1$ 位中 $k$ 的大小就有限制了，并且当 $k$ 顶格时，要按顶格处理。</p>\n<p>考虑到这里面的限制很多，并且不是很好固定一个顺序 dp，采用记忆化搜索实现本题。</p>\n<p>注意到可能有前导 $0$，而这种情况下是不用限制的，所以再记录一维表示当前位是否是前导 $0$ 即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e2</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a,b,dig[N],tot,f[N][N][<span class=\"number\">2</span>][<span class=\"number\">2</span>],ans;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(<span class=\"type\">int</span> now,<span class=\"type\">int</span> val,<span class=\"type\">int</span> flag,<span class=\"type\">int</span> zer)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (f[now][val][flag][zer]&gt;=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> f[now][val][flag][zer];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (now == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> f[now][val][flag][zer] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tf[now][val][flag][zer] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (flag)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;dig[now<span class=\"number\">-1</span>];j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(val-j)&gt;=<span class=\"number\">2</span>) f[now][val][flag][zer]+=<span class=\"built_in\">dp</span>(now<span class=\"number\">-1</span>,j,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(val-dig[now<span class=\"number\">-1</span>])&gt;=<span class=\"number\">2</span>) f[now][val][flag][zer]+=<span class=\"built_in\">dp</span>(now<span class=\"number\">-1</span>,dig[now<span class=\"number\">-1</span>],<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=<span class=\"number\">9</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(val-j)&gt;=<span class=\"number\">2</span> || zer) f[now][val][flag][zer]+=<span class=\"built_in\">dp</span>(now<span class=\"number\">-1</span>,j,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (val&gt;=<span class=\"number\">2</span> || zer) f[now][val][flag][zer]+=<span class=\"built_in\">dp</span>(now<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,zer);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> f[now][val][flag][zer];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\tcin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = a<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (tmp)&#123;</span><br><span class=\"line\">\t\tdig[++tot] = tmp%<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\ttmp/=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dig[tot]) ans-=<span class=\"built_in\">dp</span>(tot,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> ans--;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;dig[tot];i++) ans-=<span class=\"built_in\">dp</span>(tot,i,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dig[tot]) ans-=<span class=\"built_in\">dp</span>(tot,dig[tot],<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\ttot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\ttmp = b;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (tmp)&#123;</span><br><span class=\"line\">\t\tdig[++tot] = tmp%<span class=\"number\">10</span>;</span><br><span class=\"line\">\t\ttmp/=<span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\tans+=<span class=\"built_in\">dp</span>(tot,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;dig[tot];i++) ans+=<span class=\"built_in\">dp</span>(tot,i,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tans+=<span class=\"built_in\">dp</span>(tot,dig[tot],<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>练习：<a href=\"https://www.luogu.com.cn/problem/P4124\">P4124 [CQOI2016]手机号码</a></p>\n<h2 id=\"例3\"><a href=\"#例3\" class=\"headerlink\" title=\"例3\"></a>例3</h2><p><a href=\"https://www.luogu.com.cn/problem/P4127\">P4127 [AHOI2009]同类分布</a></p>\n<p>先拆成两个前缀和相减。</p>\n<p>考虑到数字的和至多只有 $18\\times 9 = 162$，可以枚举这个和，之后相当于求模某一特定数为 $0$ 的数的个数。</p>\n<h2 id=\"例4\"><a href=\"#例4\" class=\"headerlink\" title=\"例4\"></a>例4</h2><p><a href=\"https://www.luogu.com.cn/problem/P4317\">P4317 花神的数论题</a></p>\n<p>考虑到 $n$ 最大只有 $10^{15}$，在二进制表示下不会超过 $63$ 位所以 $sum(i)$ 不会超过 $63$。直接枚举所有 $sum(i)$，用数位 DP 计算有且仅有 $i$ 位是 $1$ 的数的个数就行了。</p>\n<h2 id=\"例5\"><a href=\"#例5\" class=\"headerlink\" title=\"例5\"></a>例5</h2><p><a href=\"https://www.luogu.com.cn/problem/P2235\">P2235 [HNOI2002]Kathy函数</a></p>\n<p>看到这种递推且范围很大的题，二话不说先打表。</p>\n<p>打出来发现符合要求的数在二进制表示上都是回文数！（以后打表还是要看看二进制表示啊）</p>\n<p>于是转化为数位 DP，位数肯定不超过 $16^{100} = 2^{400}$，即 $400$ 位。</p>\n<p>长度 $&lt;n$ 的回文数，就是限制首尾必须是 $1$，中间的随便填，答案就是 $\\sum_{i=1}^{n-1}2^{\\lfloor\\frac{i-1}{2}\\rfloor}$。</p>\n<p>一个长度为 $n$ 的回文数，我们只需要确定它的前 $\\lceil\\frac{n}{2}\\rceil$ 位就可以唯一确定它了。如果有一位没有顶到上界，则最后肯定是小于原数的，如果全部顶到上界，这种情况显然只有一种，特殊处理一下即可。</p>\n<p>还要用高精度，建议随便扒个模板过来。</p>\n<h2 id=\"例6\"><a href=\"#例6\" class=\"headerlink\" title=\"例6\"></a>例6</h2><p><a href=\"https://www.luogu.com.cn/problem/P3281\">P3281 [SCOI2013]数数</a></p>\n<p>考虑一个长度为 $n$ 的数，在后面加一位，对子串和的贡献。</p>\n<p>设 $f[s]$ 表示串 $s$ 的贡献，$l[s]$ 表示串 $s$ 的长度，$g[s]$ 表示 $s$ 的后缀和，这次加入的字符为 $q$，则：</p>\n<p>$f[s+q] = f[s]+g[s]\\cdot b+q\\cdot (l[s]+1)$</p>\n<p>$l[s+q] = l[s]+1$</p>\n<p>$g[s+q] = g[s]\\cdot b+q\\cdot (l[s]+1)$</p>\n<p>容易发现，$q$ 的选择不同，只在最后一项中产生影响，而且由于 $q$ 的选择范围肯定是从 $0$ 开始连续的一段，所以这个影响是可以被预处理出来的。</p>\n<p>之后就只用确定 $q$ 的取值范围了，分别计算当前是否顶格即可。</p>\n<p>注意：</p>\n<ul>\n<li>上式在求 $\\sum$ 的时候需要适当变化。</li>\n<li>每次要把不再有前导零的情况算进去。</li>\n</ul>\n<p>细节比较多，贴一份代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>,mod = <span class=\"number\">20130427</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> b,n,a[N];</span><br><span class=\"line\">ll f[N][<span class=\"number\">2</span>],g[N][<span class=\"number\">2</span>],l[N][<span class=\"number\">2</span>],c[N][<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">sum</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l&gt;r) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1ll</span>*(l+r)*(r-l+<span class=\"number\">1</span>)/<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">calc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tc[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> tmp = (i == <span class=\"number\">1</span>?<span class=\"number\">0</span>:b);</span><br><span class=\"line\">\t\tc[i][<span class=\"number\">1</span>] = c[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\tc[i][<span class=\"number\">0</span>] = (tmp<span class=\"number\">-1</span>+c[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>]*b%mod+c[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]*a[i]%mod)%mod;</span><br><span class=\"line\">\t\tl[i][<span class=\"number\">1</span>] = (l[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]+<span class=\"number\">1</span>)%mod;</span><br><span class=\"line\">\t\tl[i][<span class=\"number\">0</span>] = (tmp<span class=\"number\">-1</span>+l[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>]*b%mod+c[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>]*b%mod+l[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]*a[i]%mod+c[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]*a[i]%mod)%mod;</span><br><span class=\"line\">\t\tg[i][<span class=\"number\">1</span>] = (g[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]*b%mod+a[i]*l[i][<span class=\"number\">1</span>]%mod)%mod;</span><br><span class=\"line\">\t\tg[i][<span class=\"number\">0</span>] = (<span class=\"built_in\">sum</span>(<span class=\"number\">0</span>,tmp<span class=\"number\">-1</span>)+g[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>]*b%mod*b%mod+<span class=\"built_in\">sum</span>(<span class=\"number\">0</span>,b<span class=\"number\">-1</span>)*(l[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>]+c[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>])%mod+g[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]*b%mod*a[i]%mod+<span class=\"built_in\">sum</span>(<span class=\"number\">0</span>,a[i]<span class=\"number\">-1</span>)*l[i][<span class=\"number\">1</span>]%mod)%mod;</span><br><span class=\"line\">\t\tf[i][<span class=\"number\">1</span>] = (f[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]+g[i][<span class=\"number\">1</span>])%mod;</span><br><span class=\"line\">\t\tf[i][<span class=\"number\">0</span>] = (f[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>]*b%mod+g[i][<span class=\"number\">0</span>]+f[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]*a[i]%mod)%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (f[n][<span class=\"number\">1</span>]+f[n][<span class=\"number\">0</span>])%mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;b;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (a[<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=n;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[i]&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\ta[i]--;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\ta[i] = b<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!a[n] &amp;&amp; n!=<span class=\"number\">1</span>) n--;</span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tans = (ans-<span class=\"built_in\">calc</span>())%mod;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class=\"line\">\tans = (ans+<span class=\"built_in\">calc</span>())%mod;</span><br><span class=\"line\">\tcout&lt;&lt;(ans+mod)%mod&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例7\"><a href=\"#例7\" class=\"headerlink\" title=\"例7\"></a>例7</h2><p><a href=\"https://www.luogu.com.cn/problem/P3286\">P3286 [SCOI2014]方伯伯的商场之旅</a></p>\n<p>显然，通过朴素的 DP，我们不好处理求最小值的最优化问题。</p>\n<p>首先，一个数中的所有数都要一次移到同一个位置上，显然移动两次不如一次好。</p>\n<p>假设当前所有数都移动到了第 $i$ 位，要计算移动到第 $i+1$ 位贡献的变化量，显然就是 $a_1+a_2+\\cdots+a_i-a_{i+1}-a_{i+2}-\\cdots-a_n$。</p>\n<p>先把所有数都移到第 $1$ 位上，再依次枚举这个 $i$，计算所有贡献小于 $0$ 的和，这个可以通过数位 DP 解决。</p>\n<p>由于和可能是负数，所以要把数组开两倍值域。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">63</span>,bas = <span class=\"number\">1000</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> l,r,k,dig[N],tot,f[N][<span class=\"number\">2000</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> now,<span class=\"type\">int</span> sum,<span class=\"type\">int</span> d,<span class=\"type\">int</span> lim)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (f[now][sum+bas][lim]!=<span class=\"number\">-1</span>) <span class=\"keyword\">return</span> f[now][sum+bas][lim];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (now == tot+<span class=\"number\">1</span>) <span class=\"keyword\">return</span> f[now][sum+bas][lim] = <span class=\"built_in\">max</span>(<span class=\"number\">0ll</span>,sum);</span><br><span class=\"line\">\tf[now][sum+bas][lim] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> up = (lim?dig[now]:k<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=up;i++)&#123;</span><br><span class=\"line\">\t\tf[now][sum+bas][lim]+=<span class=\"built_in\">dfs</span>(now+<span class=\"number\">1</span>,sum+(d == <span class=\"number\">1</span>?(now<span class=\"number\">-1</span>)*i:(now&gt;=d?<span class=\"number\">1</span>:<span class=\"number\">-1</span>)*i),d,i == up &amp;&amp; lim);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> f[now][sum+bas][lim];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">calc</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = x;</span><br><span class=\"line\">\ttot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (tmp)&#123;</span><br><span class=\"line\">\t\tdig[++tot] = tmp%k;</span><br><span class=\"line\">\t\ttmp/=k;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot/<span class=\"number\">2</span>;i++) <span class=\"built_in\">swap</span>(dig[i],dig[tot-i+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\t\tret+=(i == <span class=\"number\">1</span>?<span class=\"number\">1</span>:<span class=\"number\">-1</span>)*<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>,i,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"built_in\">calc</span>(r)-<span class=\"built_in\">calc</span>(l<span class=\"number\">-1</span>)&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","DP","数位DP"]},{"title":"想做的事","url":"/2024/02/23/%E6%83%B3%E5%81%9A%E7%9A%84%E4%BA%8B/","content":"<h1 id=\"想做的事\"><a href=\"#想做的事\" class=\"headerlink\" title=\"想做的事\"></a>想做的事</h1><p>夏。</p>\n<p>和小学同学重聚。</p>\n<p>读些书，有点文化。</p>\n<p>如果《纯白交响曲》中文重制版推出，可趁此推完樱乃线和纱凪线。</p>\n<p>看能不能个学乐器，成天打 osu! 似乎并不合适。</p>\n<p>认真画画。</p>\n<p>提前规划一下大学生活，我好像一直都后知后觉，也许，正因如此，才会有如此多的遗憾吧。</p>\n<p>和喜欢的人聊天。</p>\n<p>规律作息。</p>\n<p>总之，找点放松的，有意义的，幻想中的事，然后，开始吧！</p>\n","tags":["Life"]},{"title":"数字表格 题解","url":"/2022/06/03/%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"数字表格-题解\"><a href=\"#数字表格-题解\" class=\"headerlink\" title=\"数字表格 题解\"></a>数字表格 题解</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>求$\\prod_{i=1}^n\\prod_{j=1}^mf_{\\gcd(i,j)}$，其中$f_i$表示斐波那契数列的第$i$项。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先把斐波那契数列去掉，因为这样写是没办法直接求的。</p>\n<p>因为是$\\prod$，所以我们可以把$\\gcd$相同的数的个数算出来，而那一项上的指数就是这个个数啦。</p>\n<span id=\"more\"></span>\n<p>转化为求这个东西：</p>\n<p>$\\prod_{d=1}^{\\min(n,m)}f_d^{\\sum_{i=1}^n\\sum_{j=1}^m[\\gcd(i,j) = d]}$</p>\n<p>同时除以$d$：</p>\n<p>$\\prod_{d=1}^{\\min(n,m)}f_d^{\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{m}{d}}[gcd(i,j) = 1]}$</p>\n<p>将$\\gcd$变为$\\mu$：</p>\n<p>$\\prod_{d=1}^{\\min(n,m)}f_d^{\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{m}{d}}\\sum_{k|\\gcd(i,j)}\\mu(k)}$</p>\n<p>枚举$k$：</p>\n<p>$\\prod_{d=1}^{\\min(n,m)}f_d^{\\sum_{k=1}^{\\min(\\frac{n}{d},\\frac{m}{d})}\\mu(k)\\lfloor \\frac{n}{dk}\\rfloor \\lfloor \\frac{m}{dk} \\rfloor}$</p>\n<p>设$t=kd$：</p>\n<p>$\\prod_{d=1}^{\\min(n,m)}f_d^{\\sum_{d|t,t\\leq\\min(n,m)}\\mu(\\frac{t}{d})\\lfloor \\frac{n}{t}\\rfloor \\lfloor \\frac{m}{t}\\rfloor}$</p>\n<p>改枚举$t$：</p>\n<p>$\\prod_{t=1}^{\\min(n,m)}\\prod_{d|t}f_d^{\\mu(\\frac{t}{d})\\lfloor \\frac{n}{t}\\rfloor \\lfloor \\frac{m}{t}\\rfloor}$</p>\n<p>把一样的提出来：</p>\n<p>$\\prod_{t=1}^{\\min(n,m)}(\\prod_{d|t}f_d^{\\mu(\\frac{t}{d})})^{\\lfloor \\frac{n}{t}\\rfloor \\lfloor \\frac{m}{t}\\rfloor}$</p>\n<p>外面的式子可以用整除分块做到$O(\\sqrt n)$求解，我们把里面的式子拎出来：</p>\n<p>$\\prod_{d|t}f_d^{\\mu(\\frac{t}{d})}$</p>\n<p>看到求一个数的所有约数的贡献，首先应该想到用调和级数级别复杂度的算法：</p>\n<p>枚举$d$，贡献到它的所有倍数上，时间复杂度为$O(n\\log n)$，每次查询的时间复杂度为$O(1)$。</p>\n<p>注意前缀积也要预处理，方法是线性求逆元，不然可能无法通过。</p>\n<p>总时间复杂度为$O(n\\log n+T\\sqrt n)$。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>,mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,m,vis[N],pri[N],tot,mu[N];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> sum[N],fib[N],inv[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ksm</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> ret = <span class=\"number\">1</span>,bas = x;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ret = (ret*bas)%mod;</span><br><span class=\"line\">\t\tbas = (bas*bas)%mod;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmu[<span class=\"number\">1</span>] = sum[<span class=\"number\">1</span>] = inv[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lim = <span class=\"number\">1e6</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsum[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfib[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++) fib[i] = (fib[i<span class=\"number\">-1</span>]+fib[i<span class=\"number\">-2</span>])%mod;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;i*j&lt;=lim;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (mu[j] == <span class=\"number\">1</span>) sum[i*j] = (sum[i*j]*fib[i])%mod;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mu[j] == <span class=\"number\">-1</span>) sum[i*j] = (sum[i*j]*<span class=\"built_in\">ksm</span>(fib[i],mod<span class=\"number\">-2</span>))%mod;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">long</span> <span class=\"type\">long</span> tim = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) tim = (tim*sum[i])%mod;</span><br><span class=\"line\">\ttim = <span class=\"built_in\">ksm</span>(tim,mod<span class=\"number\">-2</span>);</span><br><span class=\"line\">\tinv[lim] = tim;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=lim<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">1</span>;i--) inv[i] = (inv[i+<span class=\"number\">1</span>]*sum[i+<span class=\"number\">1</span>])%mod;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++) sum[i] = (sum[i]*sum[i<span class=\"number\">-1</span>])%mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r,Min = <span class=\"built_in\">min</span>(n,m);</span><br><span class=\"line\">\t\t<span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>;l&lt;=Min;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tr = <span class=\"built_in\">min</span>(n/(n/l),m/(m/l));</span><br><span class=\"line\">\t\t\tans = (ans*<span class=\"built_in\">ksm</span>(sum[r]*inv[l<span class=\"number\">-1</span>]%mod,(<span class=\"number\">1ll</span>*n/l*(m/l))%(mod<span class=\"number\">-1</span>)))%mod;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>有些时候，推不了了就想办法换一个枚举的东西，之后重新推，而且式子中变量越少越好，比如这道题中，如果直接用$\\frac{n}{dk}$，是需要确定两个变量才行的，所以就想到把$dk$打包成一个变量。</p>\n<p>而且，在这种多组数据的题目里，一般需要预处理出一些东西，加快计算，这就要求其中的变量尽量少（如果有两个变量，复杂度就直接爆炸了）。</p>\n<p>而最快的预处理方式一般是调和级数级别的，所以要往推出形如$\\sum_{d|k}f(d)$之类的东西。</p>\n<p>总之，这是一道比较考验推式子的技巧（<del>套路</del>）的好题。</p>\n","tags":["Editorial","数学","数论","莫比乌斯反演","逆元"]},{"title":"数学期望入门","url":"/2022/11/04/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B%E5%85%A5%E9%97%A8/","content":"<h1 id=\"数学期望入门\"><a href=\"#数学期望入门\" class=\"headerlink\" title=\"数学期望入门\"></a>数学期望入门</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>我们把一个随机试验的结果称为<strong>样本点</strong>，这些结果组成<strong>样本空间</strong>。</p>\n<p>对于样本空间内的一个<strong>随机事件</strong> $A$，定义 $P(A)$ 为 $A$ 发生的概率。</p>\n<p>假设一个<strong>随机变量</strong> $X$ 的取值有 $n$ 个，分别为 $x_1,x_2\\cdots x_n$，那么定义随机变量 $X$ 的<strong>数学期望</strong>为 $E(X) = \\sum_{i=1}^np_i\\cdot x_i$，也就是出现的概率乘上取值。</p>\n<span id=\"more\"></span>\n<p><strong>下面很重要！</strong></p>\n<p>$E(aX+bY) = a\\cdot E(X)+b\\cdot E(Y)$</p>\n<p>证明：</p>\n<ol>\n<li>$E(X+Y) = \\sum_{i=1}^np_ix_i+\\sum_{i=1}^mq_iy_i = E(X)+E(Y)$</li>\n<li>$E(aX) = a\\sum_{i=1}^np_ix_i = aE(x)$</li>\n</ol>\n<p>当然，可以加的前提是<strong>样本空间相同</strong>。比如你掷骰子，两个骰子面数不同，那么最终的期望显然不能简单的相加，因为在总样本空间内，相对于两个骰子分别的样本空间，概率的变化不是相同的。</p>\n<h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><p><a href=\"https://www.luogu.com.cn/problem/P6154\">P6154 游走</a></p>\n<p>先把期望写出来：</p>\n<p>$\\sum p_ix_i$</p>\n<p>发现这里的 $p_i$ 都是一样的，提出来。</p>\n<p>$p\\sum x_i$</p>\n<p>于是就变为求一个有向无环图的路径条数和路径长度和。</p>\n<p>进行拓扑排序，同时 dp。</p>\n<p>设 $f[i]$ 为 $i$ 点的路径数量，$g[i]$ 为 $i$ 点的路径长度和。</p>\n<p>每次转移时，$f[j]+=f[i]$，$g[j]+=g[i]+f[i]$。</p>\n<p>注意路径的起点和终点可能相同，需要把 $f[i]$ 的初值设为 $1$。</p>\n<h2 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h2><p><a href=\"https://www.acwing.com/problem/content/218/\">216. Rainbow的信号</a></p>\n<p>由于概率只和段本身有关系，所以可以先粗略的算一下每个段被选择的概率。</p>\n<p>如果段的长度为 $1$，那么被选择的概率为 $\\frac{1}{n^2}$，由于$l&gt;r$ 时，可以交换，所以如果段的长度大于 $1$，那么被选择的概率为 $\\frac{2}{n^2}$。</p>\n<p>看到这种只有位运算的，一般都是把每一位拆开算，这样可以少很多限制。</p>\n<p>再具体看第 $k$ 位的情况。</p>\n<p>假设某一位上值为 $1$，那么它对期望的贡献为 $\\frac{1}{n^2}\\cdot 2^k$。</p>\n<p>再考虑长度 $\\geq 2$ 的段的贡献。</p>\n<p>枚举左端点，假设为 $i$。</p>\n<p>and 和，在下一个 $0$ 之前都是 $2^k$，即记 $i$ 处往后第一个 $0$ 的位置为 $j$，那么对答案的贡献就是 $\\frac{2\\cdot (j-i)}{n^2}\\cdot 2^k$。</p>\n<p>or 和，在下一个 $1$ 之后都是 $2^k$，即记 $i$ 处往后第一个 $1$ 的位置为 $j$，那么对答案的贡献就是 $\\frac{2\\cdot (n-j+1)}{n^2}\\cdot 2^k$。</p>\n<p>xor 和，遇到 $0$ 不变，遇到 $1$ 取反，即遇见第一个 $1$ 和第二个 $1$ 之间是 $1$，第三个 $1$ 和第四个 $1$ 之间是 $1$。</p>\n<p>显然，这三个所需的信息都可以预处理出来，于是就是 $O(n)$ 的，带上 $31$ 大常数。</p>\n<h2 id=\"例3\"><a href=\"#例3\" class=\"headerlink\" title=\"例3\"></a>例3</h2><p><a href=\"https://www.luogu.com.cn/problem/UVA10288\">优惠券 Coupons</a></p>\n<p>这道题需要用到一个结论：概率为 $p$ 的事件期望 $\\frac{1}{p}$ 次发生。</p>\n<p>假设现在有 $i$ 张牌，要得到新的牌，则概率为 $\\frac{n-i}{n}$，根据上面的结论，这个事件期望在 $\\frac{n}{n-i}$ 次后发生。</p>\n<p>我们设 $X$ 表示所有从 $0$ 到 $1$，从 $1$ 到 $2$，这样的事件的集合。</p>\n<p>则根据期望的线性相加，$E(X) = \\sum_{i=0}^{n-1}\\frac{n}{n-i}$</p>\n<p>把 $n$ 提出来，里面的就是 $E(X) = n\\sum_{i=0}^{n-1}\\frac{1}{n-i}$，就是调和级数。</p>\n<p>现在就可以算了。</p>\n<h2 id=\"例4\"><a href=\"#例4\" class=\"headerlink\" title=\"例4\"></a>例4</h2><p>高妙题。</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P1654\">P1654 OSU!</a></p>\n<p>（话说 osu! 真的好难啊，我连2星的谱都打不过）</p>\n<p>看到这种每次增加的只和当前位有关的，一般都是 dp。</p>\n<p>依次考虑每一位，设 $ans[i]$ 表示前 $i$ 位的答案，显然只有当第 $i$ 位的操作成功时才会对 $ans[i]$ 产生贡献。</p>\n<p>假设我们已经求出了 $ans[i]$，现在要求 $ans[i+1]$。怎么求？</p>\n<p>显然，在第 $i$ 位时，长度从 $0$ 到 $i$ 都有可能，假设对于每个长度 $l$，它出现的概率为 $p_l$，且第 $i+1$ 位为 $1$ 的概率为 $P$，则可以写出 $ans$ 的转移方程：</p>\n<p>$ans[i+1] = ans[i]+P\\cdot \\sum_{l=0}^i p_l(3l^2+3l+1)$</p>\n<p>解释一下后面那一块：</p>\n<p>显然，能对答案产生贡献的只能是 $i+1$ 位为 $1$，也就是说后面的贡献产生的概率为 $P$，故要乘 $P$。</p>\n<p>而这一位是 $1$，对所有 $l$ 来说，从 $l^3$ 变成了 $l^3+3l^2+3l+1$，但是我们只算加上的贡献，这是因为，这两个东西实际上是互斥的，也就是说，你只能选择其中的一个，所以还需要把选择原来的贡献，即 $ans[i]$ 加上去。</p>\n<p>发现后面的期望不好求，而且里面还是一个多项式，考虑展开：</p>\n<p>$3\\sum_{l=0}^i p_l\\cdot l^2+3\\sum_{l=0}^ip_l\\cdot l+\\sum_{l=0}^i p_l$</p>\n<p>设 $E(A_i) = \\sum_{l=0}^i p_l$，$E(B_i) = \\sum_{l=0}^i p_l\\cdot l$，$E(C_i) = \\sum_{l=0}^i p_l\\cdot l^2$。</p>\n<p>先看第一个，显然，在第 $i$ 位，所有长度从 $0$ 到 $i$ 的序列构成了整个样本空间，于是 $E(A_i) = 1$。</p>\n<p>对于第二个，考虑第 $i$ 位的可能：</p>\n<ol>\n<li>为 $0$，则以 $i$ 结尾的全 $1$ 段的长度只能为 $0$，$E(B_i) = (1-P)\\cdot (p_0\\cdot 0) = 0$。</li>\n<li>为 $1$，则以 $i$ 结尾的全 $1$ 段的长度至少为 $1$，至多为 $i$，而这些长度对应发生的概率就等于 $i-1$ 时的 $0$ 到 $i-1$ 的长度发生的概率，所以可以通过 $E(B_{i-1})$ 转移，$E(B_i) = P\\cdot (\\sum_{i=0}^{i-1}(p_l\\cdot (l+1))) = P\\cdot (E(B_{i-1})+E(A_{i-1})) = P\\cdot (E(B_{i-1})+1)$</li>\n</ol>\n<p>再看第三个，考虑第 $i$ 位的可能：</p>\n<ol>\n<li>为 $0$，则贡献为 $0$。</li>\n<li>为 $1$，则 $l$ 从 $1$ 到 $i$，发生概率对应 $E(C_{i-1})$，$E(C_i) = P\\cdot (\\sum_{l=0}^{i-1}(p_l\\cdot (l^2+2l+1))) = P\\cdot (E(C_{i-1})+2E(B_{i-1})+1)$</li>\n</ol>\n<p>于是就做完了。</p>\n<h2 id=\"例5\"><a href=\"#例5\" class=\"headerlink\" title=\"例5\"></a>例5</h2><p><a href=\"https://www.luogu.com.cn/problem/P4550\">P4550 收集邮票</a></p>\n<p>如果期望次数为 $x$ 次，那么答案就是 $\\frac{x^2+x}{2}$。</p>\n<p>根据期望的线性相加，需要求出次数的期望和次数平方的期望。</p>\n<p>设 $f[i]$ 表示已经有了 $i$ 张牌，期望再取多少次取到所有牌。</p>\n<p>这里先不说怎么求这个东西，谈一下为什么要这样设。</p>\n<p>有很多人（比如我）一开始会直接设 $f[i]$ 表示拿到 $i$ 张牌的期望次数，这固然是好求的，但是别忘了，我们后面还要求平方，而在求这个时，我们需要知道关于它的等式。</p>\n<p>假设我们设 $f[i]$ 表示拿到 $i$ 张牌的期望次数，显然，这个次数只能从已经有了 $i$ 张，拿了一个旧的，和只有 $i-1$ 张，拿了一个新的贡献出来。但是，直接这样贡献就出问题了，因为我们说概率都是对于同一样本空间而言的，期望的线性相加也建立在此之上，但是，你贡献的时候，前面一种情况的概率 $\\frac{i}{n}$，是对于“已经有 $i$ 张牌，下一张牌可能的情况”这一样本空间而言，可是后面一种情况的概率 $\\frac{n-i+1}{n}$，是对于“已经有 $i-1$ 张牌，下一张牌可能的情况”这另一个样本空间而言的，既然样本空间不是相同的，那么就不符合期望的线性相加前提，所以你得到的等式，实际上是不成立的。</p>\n<p>再来看一看设为还要多少次才能拿全的好处：</p>\n<ol>\n<li>拿到旧牌，概率为 $\\frac{i}{n}$，对期望的贡献为 $\\frac{i}{n}(f[i]+1)$。</li>\n<li>拿到新牌，概率为 $\\frac{n-i}{n}$，对期望的贡献为 $\\frac{n-i}{n}(f[i+1]+1)$。</li>\n</ol>\n<p>你会发现，这样一来，概率就对应着同一个样本空间了，所以期望也就是对的了。</p>\n<p>于是列出等式如下：</p>\n<p>$f[i] = \\frac{i}{n}(f[i]+1)+\\frac{n-i}{n}(f[i+1]+1)$</p>\n<p>化简：</p>\n<p>$f[i] = f[i+1]+\\frac{n}{n-i}$</p>\n<p>你会发现，这和例3中依靠期望的性质给出的式子一样，所以这样做是对的。</p>\n<p>为什么只能倒推不能正推呢（如果你是像某篇题解一样利用高等数学正推的大佬，当我没说）？究其原因，还是因为如果拿到新牌，必然是从后面一项贡献过来，所以只能先把后面的期望算出来，再算这里的。设计状态的时候可以想一些极端的情况：比如 $i = n$ 是我们倒推的第一项，说明这东西的期望应该是个定值，如果拿到 $n$ 张牌了，显然期望再拿的次数为 $0$，于是就设计出 dp 的状态了。</p>\n<p>再说明一个简单一点的问题：为什么平方的期望不是期望的平方？</p>\n<p>你可能在算期望的平方时，直接把期望拿来平方一遍，但这样是不对的，因为期望本质上是概率乘上数值，而我们要求的期望的平方，只是在数值上面平方，而概率不变，所以这两者不等价。</p>\n<p>于是，设 $g[i]$ 表示拿到 $i$ 张牌，还要拿次数的平方的期望，可以列出等式如下：</p>\n<p>$g[i] = \\frac{i}{n}(g[i]+2f[i]+1)+\\frac{n-i}{n}(g[i+1]+2f[i+1]+1)$</p>\n<p>化简：</p>\n<p>$g[i] = \\frac{i}{n-i}(2f[i]+1)+g[i+1]+2f[i+1]+1$</p>\n<p>倒推转移即可。</p>\n<h2 id=\"例6\"><a href=\"#例6\" class=\"headerlink\" title=\"例6\"></a>例6</h2><p><a href=\"https://www.luogu.com.cn/problem/P1850\">P1850 [NOIP2016 提高组] 换教室</a></p>\n<p>这道题相对于前面几道来说，简单一点。</p>\n<p>首先预处理出两点间最短路。</p>\n<p>之后考虑 dp，设 $f[i][j][0/1]$ 表示前 $i$ 个时间段，用了 $j$ 次申请，这一次是否申请。</p>\n<p>转移的时候注意，如果是从 $1$ 转移过来，那么要计算两个期望，一个是成功申请的，一个是申请失败的，因为每次申请成功都是有概率的，如果这次申请了，也要把这次成功和失败的期望分别计算，这一点想清楚了，这道题也就不难了。</p>\n<h2 id=\"例7\"><a href=\"#例7\" class=\"headerlink\" title=\"例7\"></a>例7</h2><p><a href=\"https://www.luogu.com.cn/problem/P4316\">P4316 绿豆蛙的归宿</a></p>\n<p>怎么越来越简单了啊，看来我的编排水平不太行啊。</p>\n<p>根据前面的经验，我们设 $f[i]$ 表示走到 $i$ 期望还要走多远才能走到终点，这样可以保证概率都是对于 $i$ 而言的。</p>\n<p>显然 $f[n] = 0$。</p>\n<p>$i$ 有 $\\frac{1}{k}$ 的概率走到 $j$，贡献为 $\\frac{1}{k}(f[j]+w)$。</p>\n<p>建反图跑 dp 即可。</p>\n","tags":["Knowledge","数学","期望"]},{"title":"春雨","url":"/2023/05/14/%E6%98%A5%E9%9B%A8/","content":"<h1 id=\"春雨\"><a href=\"#春雨\" class=\"headerlink\" title=\"春雨\"></a>春雨</h1><h2 id=\"信息\"><a href=\"#信息\" class=\"headerlink\" title=\"信息\"></a>信息</h2><p>写于 5 月初，写的是四月初刚回归文化课的一场雨，印象很深。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>那是四月初，一场大雨毫无征兆的到来。黑云压境，漫天的乌云，来了又去，连绵不绝，如同黑色的战马在天空奔腾；雷声阵阵，挥之不去的回音，去了又来，滔滔滚滚，和雨声一起演奏春的终章、夏的序曲。我拖着久坐的身躯，来到窗边张望。</p>\n<p>小区的路面上，是破碎的银镜，是激昂的水花，是匆忙的脚步，是失足的花瓣。平日里肆虐的杂草，此时也不得不收敛，那几棵开着花的树，也风韵尽失，在寂寞的春雨中黯然神伤，甚至平日里一直为我讨厌的，遮挡着阳光的高大的树，也谦卑的弯下了腰，臣服在水之神的淫威下。哈，所谓生机，也不过是雨水的仆从罢了，我只怕这树，是永远直不起腰板来了咯！</p>\n<p>时隔几日，一切却都恢复如初。树冠又找到了太阳的方位，花开的更艳丽，草长得更茂盛了。原来，这些花草树木，用地上的枝干，承受了春雨的试炼，而地下的根系，在经历了秋冬的干旱后，疯狂地吮吸着春的甘露，现在，它们又重整衣装，再次朝着光明出发。苦难本身，并不是值得期望的事，但是，当苦难平等的降临到所有人面前时，有的人就此一蹶不振，有的人默默忍受，积蓄力量，勇敢而坚定的奔向所追寻的光，在人生的春天中焕发出无限生机。</p>\n","tags":["语文","作文"]},{"title":"数论 题解","url":"/2022/05/18/%E6%95%B0%E8%AE%BA-%E9%A2%98%E8%A7%A3/","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"f47335ec00c1e0cf247512bf81a29edeb0d37cd1f4c55d12309f479fe2209eb7\">7834362f950599cdb5db0897431343df3392469bb64c0a7d7e1daf9a788b03e117f85bdf84dcf851c3718bc5b3bf4149d4ffad7ca561ef244ec407d412eba0943d4568c8944d116906b6d4559e3dc28d34757a3f2ebc88a76d5e72b8cc4ac7cde0de1a23a173f3e33203046ad8242a9683a3449e693a1ef86da6dccf32e9e8e5b9c67497049851ed476ea7a7c02b33dce767cd9a85dfe430d5f4a761b3c809ee363720c8913bda67887cc744fb210933a8a0ceac9560ef15d583ffe503406c0daf4a67bf74368fd85345eff69fea7bce6958eb3c670baeb43d6983bf95064ba402b597602857b4db192d9dd3dd8eb0c08da87e25d39b31d4ed2ad6351cf92e0aabae272ccbee3e898cf4b274c5036122cd8ef257806bfe0cb7a2e6a79fe9411a16993e8bec8abaa65f8b76b1d91702a5471028e3d1f5ea6d288b64568d8d081d1e8e097156fa3a3eca77d2f1152fa6c6189fad7c0aa27eb18cf99ca79dbb7193135fd7c44c98d913b45bed0c51aaf80f38d14a2a62c6f215e7ef989abaf1671d330106394c8660bb408c7712f3f1d46cd934b7594559dc7c4f0ca0634b0a9f3cbd81edc36f7bf20364d619285c9541ad394d825470e15410f24c0ef00a2e17e0ede05c48edd01684d5c065f1a2c1dff2252244fc7b3ae4e98772d31041951725917106d691d9b294e7defb6c59e0881612a4f1e6fa2698fc5cdc2f3fe71daf7f0d2a7ad27ff1a65c95704f144b3b773f5b0a9fd5091f0a9ffa40d44dea2ec160ccba538fd903c857af7ebb8919aed7455bff6cc89cf53e8d15801be69ce9b31bbf48276e93a1850a1cef25acd96acd186c8e3402bed12e5abc91b2cd13ee85e29dcd4a3bfdab4df443fe1bc278d27c4ecca1c44d4a1b131f46cf326ed63159872f7201ff564dac9c5f23c9f1d5ac55034a43a4f5d6c22e3f583e99cce62547ace7ae865d3300c6810c1b35797760ee963faf2151548fe19f07332ccad0ba7112809301ca3f963324ee960be77945bd087dd11f662c22771f4321b1e2282332ad46b171757950a027652ce2abcb416c83edeb084dd518750c85116146126b8bdf2d58ad4819837f0098b7e886c392f931afc0fcce1e4d19071ad0d7ac93e75f755bbdb8550cb0ea45a87e7b2823316fcb9c6ae069c2312b8b4189aa6101d5254f32065b2f351c084ce1b0d10f89d0e1642ffda0d02fef38f205387bde99c27def5c78970e9696698381f567cf40972e597f90245db91c821ef67823a8428494347c2e9cb4d5275ac314590128937ee2ee19f54ae010029a6d9c7b2e16dfd77a9dccee2be31953ec00f237adfb589eaede06ddca02ba7a6c0a1732b4bc9bc48299bcb0a856026737c55ddb28a46b47c15b4fab68ae104c349fe5c21f1e064903d7783cafc83a96b5039f81c19d72c8cc711516ab463e90e39472d6890ae2110d609b055dca029a0a95e1430d18bdd23e6bfb1623ff15cc579116df1209d21d2b6c74fe0e60e86abcd36cc28c46c894960acf93cf9e23097c837952833725060788adb38eb8bf369962b710e4954cb099776b3aedc2a8766d3840083d2e5a3e05a117dba490b4f7257d9310246240ee00ea7bb079f28c2b0d4333a577f04a2a9836aa9773f3df95e60cdfc82d355c2ff021e8d7150dc6c63920048b1e837d2542dd0fb50a6ec4e0805746130b9c73aea6af5ba5a866ed8b7d03639ada9fbe24ff506ae8e39e45161609df05b966a6927d5d46862dd1c129b792c9f5ffbfbe9634d4fd93600fc45ac086cd2e415b3ab48888ae0a41b29dc7cbaa512826b7a12c2c67c7533bdb8087adab22f6dae95459c5e0852d6e08e2d37145756f807a9ca501776986a697151182263be3c81edbb5f0dda9f3d5937a56eb2cc4dd529a077d1bf2ebca9e0f0c4405dcf7752fb394610d65e45748b308b4b05cc73f22b88205262189eae87aa4d9c5318ac1005d13e2e1a9cf86509727cfc3e57a5bb4e32d6abaf97193d9407902ca350c7b696633a4636fbcac15edbcd48f3f3525c5123458909fc15f56e2e24c52d8bc225ad2cfd2dfb8fb6f308cb22480e1c6bcf2a3ff2c45c3e5922fdf81181e9f4417b0d878e5520e746b0cb9ca50aa5d0606d1f90638b73816d0d7e20239445e1a61e8d6257ba574cdad5a57454f78f9e00172728433ed2d9b372e9c94470e7932dad7c92f21f6130c3b61cc9fcdb2cb7930bd624f1816a7c4651430f353d98291a149866070762926cd3470cfe45d7f4a947ccedcfe83b1633b7ef034cdd5d9d1e8605874b52c1f65f7da5038a2a2d7778c385d03b516090ee638c2465bc58e176f932ed82537e2adf68f1dd16a38e90765ccdd5cd5f9fccab540dd23a70cb7f64c415167f1640d7cefb637452936303f9cc70b2ef01a540f7f2dfe5ba3810b11b21c8b96b80282e1705d1370d3218ec6a34234efe7d3a77723cab55c512ad52b67cc0c4dbcbde2d6dd66790c8fc5a4387cbb67c9d0e20b700a6abd84b7ee43273dbf61063bb2eb0dece71301362eb712f6b369019cd1937d4d634a1b7a91a5974e1fed9cb20872f07493c721d0a9215f46472731a8e57a95d8b63b7aa50c2bbdf3c59acce0e261a9f8b249c44e38ef3f3888cb8b6465175b8b2b5daf365b97b5bdd2673399f1f88e08f706314d5bfb60de94fd6b150325f2f5b9b96064d92e766d528e03a7e5c2c135b843e4013cd22744c978d748b133a960c7841d104d0b500d71c1c1c033f1cbecdda384779ffc27c6d483d014888e73912a72f5f647475241fbd40058b8ac42dc287026fd3ab441c2995a66e4f5f1f2b1088eec493e50c0c4f88799736d9f2edb10b9fe86c6c3378ae85ab0a2acd67aea61b3b120eaa435289f6d6036c4085b1ec47bb9289c4935844ae54fd55d3a6f2bc9392be50ee48706493b8dc22c8895202d4d1519b6fb2956fe396cd49e213f17e5177ceb2cb529440463d9d881a130552457adccee8f6492209a633459196345d38951ec11a101f51e8f5113a078eabff18c8270d5be1a66e6cac8f45ff7f153a22e60ae81b023470f33e6841fd88e0b4be47db8bcc44a5e5b5f9ce435b687cd2a23d4c997cc89cd5da1740f078f96cfb7ca9269948016d5d011a352be3d18e2b07d83904ab1c383232d1f3946e28928fbda4d921702558ce4f606294a2b6359ecbbd3221ec2b1b0fc816916de9320c0334f3cd240d8e292df6d3827e532274adaabb5f10b8386b832fde830fe8ace6e2c9c09ed73cb545a804628cbf751bab6e66f905d7eb443744e065c976fac2f2a6133e3e127744a7d25a030bd716b667df98fe24dda3b35546701f3bdaec743f9d65629727625bb39b22a0afe4b7f6119f71b8730594269fc1db8a039ddc5ccf0ece6ad5c5c835f209500294bbfe05ef8bb77b1c368a205da0e95e55bf49acfebbbad9154936a30c43e33bc7aae4d1d58501768c878ce1c8a5fbbcab999d8814a45ecedd8887c5305924091f6cd3262bd2878f3c5d8732d9e81211e52e4da5eb83a4de4a6ba59b549b3dade5b2d4b6a4a52627a40825b77c10122d77cd2facec61412d00301ce9f4e37b16a53551a76e8e17c38dac81c2b390e0566977d78bd004e7bb8a76e84c7c2aa30d4c5d1b31493d8a49729a8bc83bbd0e4ef1fb2bf2988d8a11f294a7f71efb54418eef68f226c5efb666eaced89627c56087330c72be45f5f730473bb9c1050484cb670864695bda965b640ccd4af9b0384f4fa6a443631495a9fdca6845a112e09f37ae14e0031522e210cdc7fcbd31c4174f5b1d0ddbc4236a3fc11b20c6240ec9441a56fe9a545df90ba87c697bda0bbed8d29e9a526e164f3993130408c40f92f400825131ef00f7cd65faae8b663bbe308019737d726da087ef24e38393edaa893f5a97d2242ddb5e33476bbd8e881707502bec1e8e105ee01bb6f2b1772cf97c57cd2f4ffba835b6109a2a2f1cf3ef3dcf6a646374e3d62fb827335d2e9b92d91aaf6fb7fbe64bcbd2d46bf5f29fe19de911ff9f65111aa11bef71ba6124a97a48b11ea309a6a2215320734ac3d8fc2152963d6d27d2d49d9dc2d0b2ce86e77d053cecd367161f34cf3f547731d4c2c2ead6793883880a7b6e99bf9751641bd4d17afa2cd7ec9920c378e23e9357e9f93c9419ebe27d3400a7e797573aeb83dc65fd1545519b3e5a178dbdb045c07f1729bb369630cb83d9a3010e8eedc04518fa048ee2d12f830154971b9f2b6461c11946e7b936a7f8639e0060a40ac0d3be851d0cba0ac9c37cbd833d1e51ccb2787963875909de639ee74400c6a0695ca9959a8f4da786b657a3a3ae67f197fe5f8c1a6b9bf59134db770f3d392b3e688621ca2199a17dc13d273052c656db619a2d128369e9f8b04042e8d303464c190c5abf7be31a67944a3c6e3abfe6ee587115783780bd4ee005dba885ec7b332a12536e3f56af1e04dd179b1308299e9017a55f73526a0c41cb7674e43fec74d6c36fd3ff6f23894176d822f791345f02be4e3632613fa552d8f52637bee35cfdab3cfee9c56fede09736f19a6a06157e6123a811e37a89d36c35fbb286d91f4c0857eb9182ae400397d45724778b9dff176975fc1fb2e2fb154d3aff3dcd6eb0942ca5038ab80e1ca45ff11fc99a1bd54bd9e3f239b7e188cdb7ebaa96b1f6b6ddb6f4fd9ddc50a7e8eb16bed7c81b875afe3e61fc5e51a3d979942381bfa3c6d12bf9d0fd2271c2f0ba54ce92cd2ba62ce351dcdfc292c9b56823a1fefaaa7537e5702ce71bf73da92757e663cac5099bf558c1cd7ae7d94f97cfec638021bf3bba2a6170c8cde42a07e947d25778ee7e3d284e200a90e85dda5b5d0d94ff8a50b177e5f18938dc186c0e5930ceb4fc236de63b1858468f6fcaffeead48163563bc39f83ff1c2fed9588289d0c445468aadc8b09163f7d6d13f83d0717b36537672ee05f55f0482e28b8e14ffa7ac68f445ce62c9dbfb49b073915cf02a3c4c62c3d0c00c449b13bbc3f07e398eb24d4c745ad41b7e9c965e047fbdfa1cf2e30f1d5099f315a6b191220d3d1ae7cf0a76a52574b92a919360e196954517b656383271105c993ff881d751c5d8b31b3f2525e2c280ff651d4a1f500c347ac11a661122d2ad1f7ae4f30bf9ca4829557b0b555b6054ca69aecfd6181303107ad57aa7d43667cf64800bc2830fc8ebe2c4421b70db21699845b1e203a7d91624a7523931ee7aa9be669fa23429234f914d26c7e325016f022072057d585a3f9d9aef639c35e0e8b1826eb6a965dff6e304b10ffa00c02fa91894b52cb8fbef7a9b60dbba4220325f5dfb104830d9d9b8392a6506c2d80819988edf6fef37fe7ebe7b59c62132f8d46de1d923ad4e5b5de9d433823434e07c2dc05bef318c30afbaecf0cf1dd48cab3d4574225c7f8a24e792868ddcfc06bbadc649e3cb77587d1b233f176cebf3bf3e15c4f1850a090b1c637be6d51d2bfafa8fb5232934abd83d5a94a141de01f126f85c75ded62cb4f0fc6ed7e53743d5f84ecf050823bf7e2fa17be674561aaee94743009d080eb60a3ccbdcda62544f6b46ce441f70a5bc8956edd9335028d998f02f60511377dd377037633d139160ec196533a4e723c62c70e3356bf2b3c3402459a6f7ddad25c61dfc08faea0ad21ffe50c2098b457b9eae75d4057a77040e69864e49ba7223511a8522dd71d392f4f615579e4aecb88a9d84f4d287d7a2001e816b32df3d50417f8fcd3f92bfc8dbfc39caee48bb61747a06923c04c0008732eb9879098aee0e091e79d33bc72192628550c42013b58b9d8f3d13c180553fa84c878a18e07fda217c37a76fcd1645541e11d79e23d5a2b292369e7b4e15564c83569c8df0f57034dd13458c6dff796ad8ed35d7e45054d278c0b96ff3540814995db47f16ba5a3812ae67b8813c41cc79faae6cca2e3c956851c900d73ee6fd1063e8bf25d48fd1bba7e7b23bef148f57deb8be91ba1d39b878d43228aa654b3226aa9cff5983177c480022041fb41fc3e7e666227c8dbd8c6e5bd684617d5b5b4289a8be07872eeb6d10f231718de84eb6fb133b8adee5f4be9eb7165897c4e67dffff7eefab890076557b4209305a6a1479d3a98a786202185221294fedd9aaf1bcff38d56c0b1b2c79c7c5628ab6ee98f49233320a21f4866741f4d38bb248b29067f6b7673ab1888b4c64a54333e8d6ee690a25da91370925b7bb551de1dfd5def50183302aae4fc2aab03583e52ba936ff9da261488f32300af7e6408af918d88fb78724dc20311d281d3e9a62b2dd0052c7de4650756f1e08f5b03f4508f109f8bf3c8e7874b7920dfa4a8baaee5afe5acd8cd8b01c539462e0259b953a5b053ccb5219afec82e9552c970e1ec6726c9145790ec92dbd279a86f1eca0d8bc6106f552513aca8b9eba22cf3f67769b72a12ba6d27a36a7e44947c2f9ba65ab318057a833f33e91677821f937d71e56cdd19eba35853c2b15c922efaf1756a5b88fc7a1485bd605387f64094017fa65cc6b5efe7f49cd5aeea3344573b415b133ccda5a25c73317021ae5305da2b3c7c6cd1716a4c58bb7e526febb57cd0dc3ce30a9ad00106a604a1ffbfbef4b7c94368b3aec29dcc7f4660c8812a55ed01b31eefdf7d56f41d1c88b569f678107f5c58031282e60759b68294a21fad20b80870062ce56beda10a01a72d1bdadea977a431d7bfec0b9ad06729803434e591a8990553a266edb4a3a4abd30f2d17954d38baf476d00314f198d4c9208efc36595aaeb728fd488daf44805601d36312f3cd81093d98abc6fde43651343f53cb06e7926dcec0ad7f7bef0aa99b076ee277c7186f0c2f8be5e9bdc0ff5fda0ea7bd296945ade4241a5ca2b2b079eb09eaf6f5914a32a063873b54fc4678b28b0491460d4e12569ac1ed7796b6d5a102d3a602ca6acac4e13ebf4e8ea14114d010d89ff4d7b1b648fef90e20d72d2706a62bf51f41eb44c1f1cef0c6fa1c07ec26299471d9c9b7be1e441efd5c9791a3019e2e848063a7b20b0281a66e4ac5f4d3019f9f43bb31433d9f3aff5dda82ad5ba9f4b2d9a7db3652b1b36e8780cc6f5ba87f5b5674b807fdc43d1e12d04b78a55d63ce3c343d0827f41918a9d46cc217812702a13c47a32879e32e745f298e139dde927e5498d473aef003dd887f43c3f6cc8d5bee490a37b1f510053f6eda6be5f2cabe943e9847ce8cde87f8c1c3ac6a043675ea8bf011e4dadf9ae3c10160dfdb7d8c47d953fb7c643b100cf93ddd99094c671e6c2c6115de12e1e4b290de7b921350f90e6efb2da70aa0802acfaa00f2d6bb3bbb8246e928b97f2b4c14b9faab100307570e7347311e673151b3549bf6ed3631b7eb61692b4fdcbe1d3acc00c824bdd86dfe485593226610aa398f41b599e16b3db1183059f39f4bf8777209016473614d837b9d950f9a6ead3832c28abc58dd449009a542048fda6959e1964401438a8d42fd66f59390a4d434025f9d0e293a779ddf0892538ba6581f2001f48dea79977a66c34f20a2dc068ae2acac8d5587f297b9bdcc5a6a64e10da0a2ac268f0ec19794a2b86bfe9de8ef86c259ad3caa85749b0e1639ccbef42f0697007375d51c94ae1cfd55b26dd62a326635101dc9136ae5a9413066e0e7468fd9e075b3ebd1f32870f16d48580908539a733c712bbe73bf8aed38740d5e164093d5f697722182182c7ce5b857ab9956ac38c8e50c2990441664df5e035576de26dcc8ce634ef99f06cfd6a750e4d1dc9a4319f16148e3f0ff62628a3aee920d5c6ac4a5d6bf95d6690afdd7265eefc7b1dac5dec5ac5137a4154b5d473922203d787c9c88963efc184696a022f2ae0d3a7f8517fd08561874dcafcef3c93ca334e2125e7d86fe4886322d0366f8c9fe8081eed69e79fdef9e6c553a4555b7c1e2231fbdeb539b084db1c5bd5d2e337cf12b33198c0c4b412f4db3139434d9aee35aaea1506ae1bc0d3ad781d9910f4072b5cb79274ddf875376200acfc49c2084c6c02f18289616fb4c4ed5ff8db165e068ca575e0d2fe3eed1712fda6ab9b622be580ba5a445d615264b36c426444460b01ea7ed6a21c5d6d6c993cc9e8b38c0ab6646d0d417ff792604ecb17d92268b3b70987bb7c46b4df6b428a055059581d2b143a2a8cb3dfc49806fb3029e2b4d9c16ba5b94f43500576390c723fd3fd666ff7df77f7395fa3ad3e1b554ae240def055a1461eb07b1d4744aa984484ddf5d9413a0008fcdc4dc8fe795ccffe07590393bb56a16126a1407cbbed38c7d2ba56f6f03a640104f378da22972d1b60512f5e6b44743061c25adc9225db3690ff622b5e6672a700f4108158dba2744db5e8631ede21982f3f8907dea2f94bff6f26096f510924761509b6c8a00bacfec865c755ba33eaaaf0060b8ed210a699b4fa75d2fa9f55cb0f23595258c5a6f6b667f6462837aa0820da368ea4a72258c05272f207bff6f18866605b37fa22898135383d915737a6439e0dc5bb145b0e8eb8111071119d6884b59db97f830b2c7c1c3cb0cde2798a6f44cdb60e0c6554c63c4602fe4a46a27511764417f80b54f4931f1c7acc7922a1bf9ec89a12ba21145f5f492136e01dfeff875b108898693acec195f6e978357bdbfb3bab11fad673ad11e4426276c1f7af76a79c5961162a5f65b214f3446776ca509b85ce94c3c8f048629b4a8fb7c09e3f9ba6f9d286adefbcfbd920f9de8899b2a771b7ad0c6743d9b37b818ec93059a72ca0e2e6fb97d52da480d36123edddc55f29995c68c629215debab03c206aebc412909f428e8b7c6b13ebb31910b7693d1986d107ff346b9f7ad810627a106c19e629283462d3d0f02313a5120304153d50c9512ee5bda85f9e333128daaebf2cca8182db785d26d7abecbffae78a2c9890633c13948b5e9f6f015dd1737889cd411fe2a8e30a37f925daccd5d19eced0f688e8e2e10c9b3c45c8807900467a9eddf0c8d75becaa5a61dcf40da10282e6584fdabdae375be640d15434acb943435a38c4fe33636bc150ecae2f7e3af2e18d43de06dd50ea4d787ce814d7b72b110d28231aa53f0c155e97a224b24f28c69b5bfb042769cf86afa31e96daf822fb6c31b18cc75d062f9ebb7d523ffb3a12f3c2fe9552354d8329905ab3d930e7ae2fc50693ee7c4652a1e15889b78bb11756f76b2ed3b124990d7b40d48858047ea7a81b2b1c0ccab81733f9ca97f8b830565ba231cf96b9920f829502f99a138ef0cda986e9ae498abe80a6ea2896b7c2fed2048663ad309be57ea432efaa90409cf5e290a12b975a13e125c891a00229c368765d78fb14b7e7b26219ec25c890a5afa09d73996c3770412e6059ed3ebd938ff6a90cdb2c0cad66689ffa6d0b9b9e1a288a575e27a3e4995aa38e6e261524efdbc943f00f64bc5122618d43c1076b9a5200a91e15643090ce1a4297861f683db493b24c417c730f56ab74432d82e1816eafcea30307412048265a08c87c23bd0a57cafa59507e68700ff1d33aa7e2e29857f2637c86a93958d152056f12f7da87b29493f4b93d24f7c26633d1cd299181a3124df7819fb4a2669f24c866e27619838f3089ad82987d408e8c21053428c4a9cd79a037da0907d68e0c458bf263dea162826f96cb37cb5edd45b6e9a2a0922f428c1a7cb11a78ac9127d7bb27657008b498d17cd70f8c544b0cf985e8b361b1b84b7539a88f8bb9933a12d1ff15cf981d531e02af22ecc24b825cea30a93b149910a2620d7337a29a6306d91bae6540d186c4c39a771569c68f36b4f8cda4ffa308fcff524b5aee6735bef8fb5dc71ffb9ad69c9880ddc90f7e9b3d5b3941e85f16fc0fc2be658d8217eeab920e5d7b2dddc03cfe0c67660dbf549e27036b507c168794dfaacaa56815dc7ef90dadd3fbe008dfb4302ed3d125979eb2f7344ccd6ecbdeca5efdce570d7c4a22b99851e61e5232d211c83848115da0c9e6475cffb81ae5dc568d9c50d21ef87d384030c732e0c0d5634d8d396d54bd74c06fd101b8b05807c21017f4899d0f09430958ab0a0c6f9666fe02a525b61368d858ed418df93efa4842aa2e0da2e9fa64eac4829c4d4afe94c79e375277009b0e29ff34185a85fc6e5abfad6467890c1ad430f36f6e043baab90e6b2ceacc46598f372d08e6c4ec1ae7ca3efce7bc2f73eea1380d4b1c5674cb027a036f6650df57a54609a8fecd0bd342e164ff4d684a64c1ef3a673188221ef5e76b1067e311f5419ee341ada3bb2a45c7abebb4180223e1b41a5e052e211217d1ffa934a05af6c1240600ad2bc544ccd245dd819ccae229978709235c5b73a7b9c83b76882cd8be8d67b28a6b10c3b659c9d38c050fe8d9e14aff40eee351a05d34a398e1dd8995ce6064df44e5ec2e523c84665d2a34c40ded216afb38ac4a513d2ae3281936c923e5fd3cbbde3b0674aee0c99473c3b729d39212092573c8a2c5a04d9ad5961ae5dc508b93320ad5dc1daa7bb32cf0cdd45e7a814aba1fc13f5c2e2111357a908c9b736bfd4d78a2d8d899e398d404a25b66afacce2b5ee2eec33f52c7bb756d2adffca9b3545ec4cfbb7f48986e39e1fc08f0f417dc7d3e116715ec0c38b4ff092faeae70710146e680c29ad96acbe3974b76cebb4cb7f221680a38c3bc952f5b9b9a8ab1b81af3965cb20ae618144566231b1b7086db2cd62c4b4267c9c42c3a1fa2e21eab37910b9f0a5bf320e82ad5515bc40f3f9560aae08373773ab4216149a1bc53ab3a2af9354c736ef44d6e0e5e782d4ad6181e31c77e141c8f5245744b7d672505912342352937822339c1f6c33dc2267214c72819cdb442c6b03c676de239c7d20b94742e2e9368cb1acb155fcc01bcb4432931f6f69c9e6d8b5387e4d48a4538c7a684ce75255107cae4b8f1e43d0af470afa54f4ab93d431b1030e2c42fd2731145acc087591babef9f404697ff42290bbcb3149dc584abc0de0e6ed6a947a2a2bef3ee3d1054e2649366793f18348f51cc83502d1d67982704b7b77cc906421c18b68f935d1273cf5e10b3dfae7f0644148135569aaa0f1c946e154febc53369871117b98c27577341222bd897ad2592a38a33e7426f35eefe1499f075f9c65eba55337fe87de7a99f7b6af2a791af790dd7b2c2667ffe572a42a4ce1ae1bb12dcb564a85fde60f5f0037be5a6b6acd7d8e289dd33cf3308f4a2ec17c739e3ee52ca134fe293e158da13453fa1ac2a54c52c9ed7fc99be49839a14ca78999c04dfa97e34014114228471e58ef198c4ea873f81d0eb7b90d3dd8e739f8b2580bbdded69232af851d6ef558d5b7252260712dd7a64b4890f9b79df154eddf45a75435c948a388065eaf526206dcc16b2eb81fa9cc8b41b6d3c2e01a0d952986cc7ec43d3711b2d1ccf31d5d0eb9f1b293f9066427ce281ff718be011ad762f25f53ed508a7dd77f3547f9ff8ab1fc26e972e96b24367dfda405fca70ad9e6555b6add308b591c18a49bc21bc567521822607a94b8915fc4ae2d72aa84c102e30b7cc7c26589437c0e6b8c708e66f22a56772677c3e3cc89e3ec84b8ac5d945f1b6a49a845b34afa250c5cbd9cfe3b321d398278da8cb1cd825f67c89f01e1abb5c23ea77ec7bc131b6d7e47cd090a7af5b5895b689abf85338d7cad91f19b4e85fccab4bb2ae7952805ddffed14b1f34d6ba49eea1fb733051c40100dcca180231c50cc43575c099ca62173b76fe82b0644a500c7899fc7977c4e7dc930d54d44c2e4c7d9ccc92700272c1d48b6be8337012a2c2b6095b5b22cf21d63ed22621c1c2566e0dc6117fce2226425581b2d94faa37ba919d42eda7e86b2b206974752f7a789488d60eec9c125b63498e3125f8e6d38e621fa10fd87cb54a97d40cb4273ac4833e258a433eb4cff25a0defb65ab2e6bb7479c99934e8cba7d07ff46735cfcc200ecde28357ea15edca9c78b5b57724ea631fc4916d0f3fe27ca05e2a5c630857e641c5c631962f8d0380480b6b79ac1ed7eb218de6140a3cb8a0bfb232ca4eeec5b59ac72b6dbfb1dcf62b6a239b38bee4850b55116a34bbccdf3533b7cfded4385a00a7b426596f2d6756c7e61cb6102e678bb5f04f910eb468b011fb4f47a8b068097478ad7a887087e48dee389712327b531745d374d3228a48c5a228a75c4a42853c055cf2e7cd74ab33442253a6f1bb2203d8642d52682c160ac19a4a40ae0f3d7dd99e6982eaddf5d076045b0ffb14213bfca4d9d0540be30bffa8cb0ff458b907a7387cf1f2764b76393879c1a98353d846c2013ec4092148824003c5f230c780a613328fa2aceab977b1967d74431e19b23abd9d131645194387c7ecc92153f68568fccea6e4bd6cc364675270c5d65f497e6038efe701d038bf276d930bd59f3504f8982acc9ac21f2b630ec28c9a8f68cf1837aca5822768eafb90f6b0600c9017c5a669743703aa0e0087c67fee6f65d7abef2d88aa28d8606e4ca9fd5bdc18646bf767d37693f18f8f4e340a40325753412ef4d6e562a75456a019a4605c3c247a60276d6eeeed2e0ebd7c2aad3f8ce00c2f062c8c9537ea87c686e9ac436f3379a795377a30bb3a961462b9d66bb380381f7d4bedaaf10940aaa76ed07470670045318da0a20ee3cb2490e7e331cd9ddc7a04930244e8b70766097b905020a697ea04f3793f3212ec3a48971e71bc86b3edee34ed51933ea91a7935d3e558bffcaf3954fa4cc56144554950e89a6b0cb78c5fe9be7b5a91983046ab8d34b4f2c62f20d6108c965b2db26a83ed5c7fbdc8e63e07c0ff5b21b77fb564684037bb59144ba891fe461787484955aab96b74637ef036b5d823d360b17a0eaedf1f78ce99862013426e9c100bd5f8db2890a4c61c4802a3d864fb3706719fe1a04311853ba9a23bf23e1853a4e01d1eb8aea6b4866824a394b22a0ba34437591e8bf1eb90a66a3cb4d844d5e9eef1c7acd2527c0973f927992a3194cfd87078f1a644aef61116822a02c28d8be3cc43aacd46641bf1c4b946bb1efb22b26134618bcbf138cbc815ff12567e7dc7f9b222a9179cdcf17e757900907c9ba7c97689b4fde6afc672edd29dacc7b633b629877e97591c979de9b55c81c766581750941399c8c51237c37546cabd1d1950762087117490ab728f67bf3b0fef7c1f2efcdcca0eee9b7d990547b1034d6670a6092ee0fb9780d621490f27672ffdddba24eab8f8135b13e6036858</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">输入我在2022-05-18 23:28:12提交记录的id</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","tags":["Editorial","数学","欧拉函数"]},{"title":"树屋阶梯 题解","url":"/2022/04/12/%E6%A0%91%E5%B1%8B%E9%98%B6%E6%A2%AF-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"树屋阶梯-题解\"><a href=\"#树屋阶梯-题解\" class=\"headerlink\" title=\"树屋阶梯 题解\"></a>树屋阶梯 题解</h1><h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>最开始，没有任何思路。</p>\n<p>于是看了两眼样例，猜了一些结论，发现这个有可能是对的。</p>\n<p>结论1：每个长度为$n$的阶梯都至少需要$n$个钢板。</p>\n<p>使用数学归纳法证明：</p>\n<span id=\"more\"></span>\n<p>当$n=1$时，需要一个钢板。</p>\n<p>假设这个结论在$[0,n-1]$都成立，我们需要钢板的数量最少，就需要搭建长度为$n-1$的阶梯的最小钢板数量，即$n-1$个，而新增的$n$的这个钢板最上面的一个方格是不可能被之前的任何一个钢板覆盖的，所以这个地方必须要有一个钢板。其他地方的钢板可以直接让长度为$n-1$的阶梯的钢板延伸过来，于是只用$n$个钢板的方案一定存在。</p>\n<p>结论2：我们从右往左看，每次都能在竖直范围内找到一个新的钢板。且这个钢板必然覆盖嘴上面的一块。</p>\n<p>由结论1易得。</p>\n<p>必然有一块钢板覆盖左下角这个点，而它必然覆盖了一个顶点，我们枚举这个钢板覆盖的位置，发现它正好把这个阶梯分成另外两个部分，于是这就变成了求解子问题。</p>\n<p>$f[i] = \\sum_{j=0}^{i-1}f[j]\\cdot f[i-j-1]$。</p>\n<p>这个东西打个表可以发现，跟卡特兰数一模一样，在oi-wiki上也有这个公式的介绍。</p>\n<p>于是，我们的目标就是求第$n$项卡特兰数。</p>\n<h2 id=\"Code-：\"><a href=\"#Code-：\" class=\"headerlink\" title=\"$Code$：\"></a>$Code$：</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>())</span><br><span class=\"line\"><span class=\"built_in\">sum</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">int</span>(a)+<span class=\"number\">1</span>,<span class=\"built_in\">int</span>(a)*<span class=\"number\">2</span>+<span class=\"number\">1</span>,<span class=\"number\">1</span>):</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span>*i</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span> (<span class=\"number\">1</span>,<span class=\"built_in\">int</span>(a)+<span class=\"number\">1</span>,<span class=\"number\">1</span>):</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span>/i</span><br><span class=\"line\"><span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span>/(<span class=\"built_in\">int</span>(a)+<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">int</span>(<span class=\"built_in\">sum</span>))</span><br></pre></td></tr></table></figure>\n<p>（实在不想写高精啊）</p>\n","tags":["Editorial","数学","组合数学"]},{"title":"树网的核 题解","url":"/2022/07/01/%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"树网的核-题解\"><a href=\"#树网的核-题解\" class=\"headerlink\" title=\"树网的核 题解\"></a>树网的核 题解</h1><p>$\\color{red}Status: Unfinished$.</p>\n<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给你一个无根树，求出直径上的一段长度不超过 $s$ 的路径，使树上的所有点到它的距离的最大值最小。</p>\n<p>其中，一个点到路径的距离为点到路径上的任意一点距离的最小值。</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>先思考几个性质：</p>\n<ol>\n<li><p>树的所有直径中，不管选择哪一个，最终的结果都是一样的。</p>\n<p>证明：</p>\n<p>咕掉了。</p>\n</li>\n<li><p>在直径上的点，离它最远的点必然是直径的端点之一。</p>\n<p>证明：</p>\n<p>反证法。</p>\n<p>假设有一个不在直径上的点，它到这个点的距离比直径的一个端点到这个点的距离更大，那么把直径的一个端点替换为这个点，长度会更长，与原路径是直径矛盾。</p>\n</li>\n</ol>\n<p>现在，我们已经有了基本的思路：</p>\n<p>根据性质1，我们随便找一个直径求答案。</p>\n<p>根据性质2，答案就在直径的两个端点到路径的两个端点的距离和非两个端点到其他非直径上点的距离。（这里先让你们自己思考一下吧，有时间应该会更具体的过程，还算比较好想）</p>\n<p>然后，每次把 $s$ 距离填满最优，这也是性质2的一个推论。</p>\n<p>于是，维护一个单调队列，把 $\\max$ 求一下就行了。</p>\n<p>但是，根据性质2，我们不剔除左端点前面的非直径点到它的距离，也无伤大雅，因为它们肯定小于左端点到直径的一个端点的距离，这样只用扫一遍就行了。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,s,head[N],tot,dep[N],fa[N],a[N],cnt,d[N],Max,dis[N],vis[N],ans;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to =  y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fat)</span></span>&#123;</span><br><span class=\"line\">\tvis[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tMax = <span class=\"built_in\">max</span>(Max,dep[u]);</span><br><span class=\"line\">\tfa[u] = fat;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tdep[v] = dep[u]+edge[i].w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getdia</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> mpos = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++) <span class=\"keyword\">if</span> (dep[mpos]&lt;dep[i]) mpos = i;</span><br><span class=\"line\">\tdep[mpos] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(mpos,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">if</span> (dep[mpos]&lt;dep[i]) mpos = i;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (mpos)&#123;</span><br><span class=\"line\">\t\td[++cnt] = mpos;</span><br><span class=\"line\">\t\tdis[cnt] = dep[d[cnt]];</span><br><span class=\"line\">\t\tmpos = fa[mpos];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">\tMax = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tans = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++) vis[d[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (dis[l]-dis[i]&gt;s) l++;</span><br><span class=\"line\">\t\tdep[d[i]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(d[i],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tans = <span class=\"built_in\">min</span>(ans,<span class=\"built_in\">max</span>(dis[<span class=\"number\">1</span>]-dis[l],<span class=\"built_in\">max</span>(dis[i]-dis[cnt],Max)));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,z);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,z);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">getdia</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","树的直径","树"]},{"title":"树上启发式合并","url":"/2022/10/03/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/","content":"<h1 id=\"树上启发式合并\"><a href=\"#树上启发式合并\" class=\"headerlink\" title=\"树上启发式合并\"></a>树上启发式合并</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>对于一些难以转化的统计类问题，我们可以用启发式合并的思想完成子树信息的合并。</p>\n<p>步骤：</p>\n<ol>\n<li>访问轻儿子，计算它们的答案，并且不保留计算的东西。</li>\n<li>访问重儿子，计算它的答案，保留得到的东西。</li>\n<li>枚举轻儿子的所有节点，计算它们对现在这个子树答案的贡献，上传给父亲。</li>\n</ol>\n<span id=\"more\"></span>\n<p>伪代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> f)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (u in light son) <span class=\"built_in\">dfs</span>(u,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(heavy,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (u in subtree) <span class=\"built_in\">calc</span>(u);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!f) <span class=\"built_in\">clear</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>考虑几个问题：</p>\n<ol>\n<li><p>时间复杂度是 $O(n^2)$ 吗？</p>\n<p>其实是 $O(n\\log n)$。因为根据重儿子的定义，它的大小一定是最大的，所以其他儿子每次合并，所处的子树大小至少变为原来的 $2$ 倍。所以每个节点最多被访问 $\\log n$ 次，于是时间复杂度即为 $O(n\\log n)$。</p>\n</li>\n<li><p>为什么要先遍历轻儿子，交换顺序会怎样？</p>\n<p>先明确一点：这里的统计数组是共用的。</p>\n<p>如果先遍历重儿子，根据之后我们遍历轻儿子就要把数组清空的原则，重儿子的信息会丢失，所以不行。</p>\n</li>\n</ol>\n<p>来看一些例题。</p>\n<h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><p><a href=\"https://www.luogu.com.cn/problem/CF741D\">CF741D Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths</a></p>\n<p>至于为啥这题的名字这么长，你可以去问出题人，他就是树上启发式合并算法的提出者。</p>\n<h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>给你一棵树，每条边有字符形式（a~v）的边权，求出每个子树内的最长路径，满足边权的字符，每个都出现偶数次。</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>根据上面的思想，我们先做一次树链剖分，求出重儿子。</p>\n<p>之后，考虑我们要统计的信息是什么。</p>\n<p>如果一条路径满足条件，那么出现次数为奇数的字符个数 $\\leq 1$。</p>\n<p>这提示我们只用关注每个字符出现次数的奇偶性，于是可以状压。</p>\n<p>一条路径，就是两个端点到 $lca$。那么确定了两个端点，我们就能 $O(1)$ 求出是否满足了。</p>\n<p>具体来说，设 $f[u]$ 表示 $u$ 到根路径上的边状压成的二进制数，于是这条路径的二进制数可以表示为 $f[lca]\\oplus f[u]\\oplus f[v]$。</p>\n<p>之后用 map 维护一下 $f$ 的值，访问轻子树的 $v$ 节点时，枚举为奇数的位置 $p$，看 $f[lca]\\oplus f[v]\\oplus 2^p$ 是否存在即可。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>一般用树上启发式合并的题，难点在于统计。</p>\n<p>例如此题，需要发现可以使用状压存储答案，且可以用 map 维护是否可行，才能做出来。</p>\n<p>而且，由于统计的东西在上传的过程中不能改变，所以都是全局值，是固定的，这时候就要想维护它到根节点的信息。</p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p><a href=\"https://www.luogu.com.cn/problem/P4149\">P4149 IOI2011 Race</a></p>\n<h2 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h2><p><a href=\"https://www.luogu.com.cn/problem/CF600E\">CF600E Lomsat gelral</a></p>\n<h3 id=\"题意-1\"><a href=\"#题意-1\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>给你一棵有根树，每个节点都有一个编号。</p>\n<p>一个子树中可能有多个出现次数最多的编号，你要对每棵子树，求出出现次数最多的编号的和。</p>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>容易想到维护每个编号的出现次数，这个可以用一个桶搞一下，于是，我们已经有了要统计的东西。</p>\n<p>先依次遍历轻儿子和重儿子，现在我们知道重儿子里面每个编号出现的次数。</p>\n<p>枚举其他所有节点，加到桶里面去，每次加的时候更新一下最大值就行了。</p>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>比较显然的一道题，因为不用在想统计的信息如何存储上面花心思，直接用桶就行了。</p>\n<h3 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p><a href=\"https://www.luogu.com.cn/problem/CF375D\">CF375D Tree and Queries</a></p>\n<h2 id=\"例3\"><a href=\"#例3\" class=\"headerlink\" title=\"例3\"></a>例3</h2><p><a href=\"https://www.luogu.com.cn/problem/CF208E\">CF208E Blood Cousins</a></p>\n<h3 id=\"题意-2\"><a href=\"#题意-2\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p>$q$ 次询问，每次询问有根树中 $u$ 的 $k$ 级祖先有多少个孙子和 $u$ 的深度相同。</p>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>由于答案和深度有着千丝万缕的练习，故想到以子树内某一深度的点有多少个为统计对象。</p>\n<p>而且，访问到一个点，只能计算它的子树内的贡献，所以考虑将询问放到祖先身上，这个可以直接 ST 表处理出来。</p>\n<p>假设现在已经求出了深度数组，那么如何计算答案呢？</p>\n<p>可以直接遍历在当前节点上的询问，每个询问都形如 $(u,dep)$ 的形式，则 $u$ 这个点的答案就是 $cnt[dep]-1$。</p>\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>重点是想什么信息是全局不变的，因为这正是保证时间复杂度的一大要素。</p>\n<h3 id=\"练习-2\"><a href=\"#练习-2\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p><a href=\"https://www.luogu.com.cn/problem/CF246E\">CF246E Blood Cousins Return</a></p>\n","tags":["Knowledge","树","Notes","启发式合并"]},{"title":"武大游记","url":"/2024/09/03/%E6%AD%A6%E5%A4%A7%E6%B8%B8%E8%AE%B0/","content":"<h1 id=\"武大游记\"><a href=\"#武大游记\" class=\"headerlink\" title=\"武大游记\"></a>武大游记</h1><h2 id=\"2024-9-2\"><a href=\"#2024-9-2\" class=\"headerlink\" title=\"2024.9.2\"></a>2024.9.2</h2><p>第一天报到，基本上就是到处跑，很累，下午还极限拿了奖状和高考截图，赶上了晚上的班会，貌似对数学要求很高，难顶。</p>\n<p>吃了信部的三四食堂，四食堂的小碗菜好吃一点。</p>\n<span id=\"more\"></span>\n<p>晚上洗澡简直是灾难，首先把要换的衣服放在了外面，水卡还要预约，忘带内裤，洗衣服只洗了一半，要挂的时候发现还有一堆洗衣液残留，总之很难蚌。</p>\n<h2 id=\"2024-9-3\"><a href=\"#2024-9-3\" class=\"headerlink\" title=\"2024.9.3\"></a>2024.9.3</h2><p>军训第一天。</p>\n<p>早上拉去开了新生讲座，主要是不要做违法乱纪的事，虽然自由，还是要对学习上点心，能力、态度、方法至少具备其一。辅导员感觉平易近人，像是啥事都可以问问的。借此机会也把去自强大道的路熟悉了一下。</p>\n<p>下午军训推迟 1h，喜提午睡。</p>\n<p>军训还是很累的，要求很多，站军姿是真的折磨，总是忘记一些细节，之后再改进吧。主要是天太热了，不在太阳底下都满脸是汗，而且武汉好像一周都是大晴天。</p>\n<p>晚上体验了一下校巴，突然发现之前好像都没刷卡就坐了，也不知道有没有啥问题。还是挺方便的，各个站点之间的距离较为合理，而且手机上能看到实时信息。</p>\n<h2 id=\"2024-9-4\"><a href=\"#2024-9-4\" class=\"headerlink\" title=\"2024.9.4\"></a>2024.9.4</h2><p>参加了二次选拔的笔试和机试，完全寄掉。看见两个很原的题，但是想不起来，最后只有 200 pts。</p>\n<p>军训很累。</p>\n<h2 id=\"2024-9-5\"><a href=\"#2024-9-5\" class=\"headerlink\" title=\"2024.9.5\"></a>2024.9.5</h2><p>上午参加了开学典礼，最亮眼的是开始之前放的一顿宣传片（可能是去年校庆的时候集中产出的），感觉导演很厉害，镜头都很强，武大真有实力的。</p>\n<p>晚上参加英语分班考试，听力一点听不懂，后面的只有阅读和完型可以做做，随缘吧。</p>\n<h2 id=\"2024-9-6\"><a href=\"#2024-9-6\" class=\"headerlink\" title=\"2024.9.6\"></a>2024.9.6</h2><p>上午去参加了面试，等了 2h，和一个新认识的一个考场的同学，在武大文理学部走了一圈，看了下樱花城堡，还看到了古朴而气派的建筑（不知道叫啥）。之后就是面试了，我大概把我的竞赛生涯讲了一遍，之后回答了一些问题，被问到为啥不来计院，知不知道什么叫多态和指针，然而我并不会。</p>\n<p>下午参加了开学第一课，校长讲的还是很有水平的，不是照稿子念，中间加了很多自己的经历，再次感受到了武大的用心。反复强调兴趣的重要性，不要选错专业了，还谈到要兼顾学业和生活，这方面目前是我最大的困惑。</p>\n<p>晚上去填学籍表，照片貌似大了一号，不过勉强可以放进去。填到一半，xyr 突然发消息说我进了雷军班，我一开始是不相信的，直到回宿舍后亲自确认了这一点。感觉上午面试吹太大了，说啥本来可以拿 ag，搞得别人认为我真有 ag 水平，不过事已至此，只能拼尽全力，梦回高中了，要自律啊！！！</p>\n<p>演讲时，校长谈到了大学是人生的“拐点”，今天，大概可以算得上我大学生涯的一个重要“拐点”吧。</p>\n<h2 id=\"2024-9-7\"><a href=\"#2024-9-7\" class=\"headerlink\" title=\"2024.9.7\"></a>2024.9.7</h2><p>上午站了大概 2h 军姿，累趴了，腿部关节尤其酸。</p>\n","tags":["Life","大学"]},{"title":"浅谈 01BFS","url":"/2022/10/27/%E6%B5%85%E8%B0%88-01BFS/","content":"<h1 id=\"浅谈-01BFS\"><a href=\"#浅谈-01BFS\" class=\"headerlink\" title=\"浅谈 01BFS\"></a>浅谈 01BFS</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>01BFS 的名字来自于它的性质：只能应用在边权只有 $0$ 和 $1$ 的图上。</p>\n<p>具体的，我们用一个 deque 维护（请 NOI2022 考生不要 PTSD），先插入起点，之后每次取出队首元素 $u$，如果 $u$ 没有被访问过，就标记为访问过，之后遍历每一条出边，假设到达点 $v$。</p>\n<span id=\"more\"></span>\n<ol>\n<li>边权为 $0$，且满足 $dis[v]&gt;dis[u]$，更新 $dis$，将 $v$ 插入<strong>队首</strong>。</li>\n<li>边权为 $1$，且满足 $dis[v]&gt;dis[u]+1$，更新 $dis$，将 $v$ 插入<strong>队尾</strong>。</li>\n</ol>\n<p>这样，我们可以在 $O(n+m)$ 的时间内求出一张有向图的最短路，这也是 01BFS 的优势所在。</p>\n<p>时间复杂度好证明，就不再做赘述，这里主要证明其正确性。</p>\n<p>假设队列中只有起点，其 $dis$ 为 $x$，则它遍历完之后，插入队列的点的 $dis$ 必然为 $x$ 或 $x+1$。</p>\n<p>我们归纳一下，可以得到队列中元素不降这个性质。</p>\n<p>如果队列中有多个元素，还是设队首元素的 $dis$ 为 $x$，则队列中也只包含 $x$ 和 $x+1$。</p>\n<p>为什么？因为在 $x$ 之前遍历的元素一定 $\\leq x$，所以它最大只能贡献到 $x+1$。</p>\n<p>于是，我们每次取出的一定是 $dis$ 最小的点，符合 Dijkstra 算法的流程，是正确的。</p>\n<h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><p><a href=\"https://atcoder.jp/contests/abc246/tasks/abc246_e\">E - Bishop 2</a></p>\n<p>题目中的换方向加 $1$ 代价，其实相当于边权为 $1$，不换方向边权为 $0$，这样就转化为了 01BFS 问题。</p>\n<p><a href=\"https://atcoder.jp/contests/abc246/submissions/35984989\">Submission #35984989</a></p>\n<p>练习：<a href=\"https://codeforces.com/problemset/problem/173/B\">Problem - 173B - Codeforces</a></p>\n<h2 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h2><p><a href=\"https://codeforces.com/problemset/problem/1063/B\">Problem - 1063B - Codeforces</a></p>\n<p>我们考虑从 $(a,b)$ 走到 $(c,d)$。</p>\n<p>上下步数没有代价，不用考虑，则只需满足 $r-l = d-b$ 即可。</p>\n<p>发现，当 $l$ 最小时，$r$ 也最小，所以 $l$ 最小必然最优。</p>\n<p>于是，我们只需要让往左走的代价变为 $1$，往右走的代价为 $0$，最后再判断一下是否满足 $r$ 的限制即可。</p>\n<p><a href=\"https://codeforces.com/contest/1063/submission/178110384\">Submission #178110384 - Codeforces</a></p>\n<p>练习：<a href=\"https://www.luogu.com.cn/problem/P4667\">P4667 [BalticOI 2011 Day1]Switch the Lamp On</a></p>\n","tags":["Knowledge","图论","BFS","最短路"]},{"title":"概率充电器 题解","url":"/2022/11/21/%E6%A6%82%E7%8E%87%E5%85%85%E7%94%B5%E5%99%A8-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"概率充电器-题解\"><a href=\"#概率充电器-题解\" class=\"headerlink\" title=\"概率充电器 题解\"></a>概率充电器 题解</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>考虑到 $n-1$ 条导线连接 $n$ 个原件，构成的是一棵树。</p>\n<p>考虑一个元件，它是否能充上电，只能是自己直接充电或者其他点直接充电到它来。</p>\n<p>自己直接充电的概率为 $q_i$，$j$ 元件直接充电成功，将点输送到它这里来，需要路径上的所有边都通电才行。</p>\n<span id=\"more\"></span>\n<p>设 $f[i]$ 表示从子树中放电的节点充电到自己的概率：</p>\n<p>首先，充电到自己上，必然是自己还没有充电，所以要先乘一个自己不能直接充电的概率：$(1-q_i)$。</p>\n<p>枚举儿子，显然，只有儿子能充电，自己到儿子的边能通电，才能给自己充上电。</p>\n<p>这部分也是好搞的，相当于 $1-\\sum_{u\\in son_i}(1-p_i)$。</p>\n<p>之后，再看父亲传来的电。</p>\n<p>发现，根节点的答案一定是对的，也就是说，我们可以默认知道了父亲的答案。</p>\n<p>现在，父亲的答案是所有树中的节点都可以贡献的，所以我们需要减去当前节点及其子树的答案。</p>\n<p>考虑没有加入当前子树的贡献之前的答案 $f’[fa]$，则转移时遵守下面的方程：</p>\n<p>$f[fa] = f’[fa]+(1-f’[fa])\\cdot f[u]\\cdot w$</p>\n<p>所以，$(1-f[u]\\cdot w)f’[fa]+f[u]\\cdot w = f[fa]$</p>\n<p>$f’[fa] = \\frac{f[fa]-f[u]\\cdot w}{1-f[u]\\cdot w}$</p>\n<p>乘上导电的概率即为当前节点答案。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">double</span> eps = <span class=\"number\">1e-7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,head[N],tot;</span><br><span class=\"line\"><span class=\"type\">double</span> f[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">\t<span class=\"type\">double</span> w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">double</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs1</span>(v,u);</span><br><span class=\"line\">\t\tf[u]+=(<span class=\"number\">1</span>-f[u])*edge[i].w*f[v];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">fabs</span>(<span class=\"number\">1</span>-f[v]*edge[i].w)&lt;eps)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs2</span>(v,u);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tf[v]+=((f[u]-f[v]*edge[i].w)/(<span class=\"number\">1</span>-f[v]*edge[i].w))*(<span class=\"number\">1</span>-f[v])*edge[i].w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs2</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcout&lt;&lt;fixed&lt;&lt;<span class=\"built_in\">setprecision</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"type\">double</span> p;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;p;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,p/<span class=\"number\">100</span>),<span class=\"built_in\">add</span>(y,x,p/<span class=\"number\">100</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;f[i];</span><br><span class=\"line\">\t\tf[i]/=<span class=\"number\">100</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs1</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">dfs2</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"type\">double</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans+=f[i];</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","DP","期望","树形DP"]},{"title":"浅谈 Tarjan 算法","url":"/2022/10/27/%E6%B5%85%E8%B0%88-Tarjan-%E7%AE%97%E6%B3%95/","content":"<h1 id=\"浅谈-Tarjan-算法\"><a href=\"#浅谈-Tarjan-算法\" class=\"headerlink\" title=\"浅谈 Tarjan 算法\"></a>浅谈 Tarjan 算法</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这个知识点非常抽象，建议多画图，记忆好各个变量的定义，能准确的理解这个算法为什么正确。</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>以下定义都建立在无向图的基础上。</p>\n<span id=\"more\"></span>\n<p>一个点是割点，相当于把连向它的所有边都删掉，之后把它删掉，图中的连通块个数发生改变。</p>\n<p>一条边是桥，相当于把它删去，图中的连通块个数发生改变。</p>\n<p>我们用 dfs 的方式遍历整个图，每次只访问没有访问过的节点，显然，最后形成的是一棵树。（即每一个点都被访问过恰好一次，只有一个父亲）</p>\n<p>我们把这棵树称作搜索树。</p>\n<p>$dfn[x]$ 表示 $x$ 是第几个被访问到的，学术一点的叫法叫时间戳。</p>\n<p>$low[x]$ 的定义比较复杂，其为以下几种情况中 $low[x]$ 的最小值：</p>\n<ol>\n<li><p>自己的时间戳，$low[x] = dfn[x]$。</p>\n</li>\n<li><p>所有儿子的时间戳的最小值 $low[x] = dfn[y]$，此时 $fa[y] = x$。</p>\n<p>（其实 1 和 2 放在一起就是严谨的定义：$x$ 的子树内所有点的时间戳的最小值。不过这两个是等价的，可以想想为什么，这样讲是为了之后好写代码。还有人把 $fa[x]$ 的时间戳也加了进去，但是依旧能 AC，请想想为什么。）</p>\n</li>\n<li><p>$x$ 子树中的点通过一条<strong>不在搜索树上的边</strong>能够到达的节点时间戳的最小值。</p>\n</li>\n</ol>\n<p>把这些定义合并在一起，就是 $low[x]$ 真正的定义：不经过父亲，经过最多 $1$ 条<strong>不在搜索树上的边</strong>能够到达的点的时间戳的最小值。</p>\n<p>如何计算 $low[x]$ 呢？</p>\n<p>首先，$low[x] = dfn[x]$。</p>\n<p>显然，$x$ 通过 $x$ 的一个儿子到达的所有地方必然不用经过 $x$ 的父亲，所以 $low[x] = \\min(low[x],low[y])(fa[y] = x)$。</p>\n<p>最后，$x$ 通过<strong>一条</strong>不在搜索树上的边访问到的点的时间戳的最小值，$low[x] = \\min(low[x],dfn[y])(dfn[y]\\neq 0,fa[x]\\neq y)$。</p>\n<h2 id=\"割点和桥的判定\"><a href=\"#割点和桥的判定\" class=\"headerlink\" title=\"割点和桥的判定\"></a>割点和桥的判定</h2><h3 id=\"割点\"><a href=\"#割点\" class=\"headerlink\" title=\"割点\"></a>割点</h3><p>如果一个点 $x$ 满足 $dfn[x]\\leq low[y]$$(fa[y] = x)$，那么 $x$ 就是一个割点。</p>\n<p>可以这样理解：如果 $y$ 的 $low$ 比 $x$ 的时间戳大，那么 $y$ 能访问的点必然都在 $x$ 的子树内，因为 $x$ 的子树内的点的 $dfn$ 必然比 $x$ 的大。</p>\n<p>这时候，你可能会有疑问：那万一它访问的点不在 $x$ 的子树内，且 $dfn$ 还比 $x$ 大呢？</p>\n<p>当然不会了，因为根本不可能访问到在 $x$ 的子树外的点，其 $dfn$ 比 $x$ 要大。</p>\n<p>假设现在要求这个倒霉的 $y$ 的 $low$，我们的流程是先遍历和它相连的没有被访问过的点，用它的 $low$ 来更新 $y$ 的 $low$，那如果上面的结论成立，显然 $low[y]$ 仍然不可能比 $dfn[x]$ 大。</p>\n<p>现在，我们用已经被访问过的节点的 $dfn$ 来更新 $low[y]$，由于已经被访问过了，所以它的 $dfn$ 必然小于 $y$ 的 $dfn$。</p>\n<p>得证。</p>\n<p>再想想给出 $low$ 的定义时的一个问题：为什么用一个点的父亲的 $dfn$ 更新这个点后，结果不会出现问题？</p>\n<p>显然，一个点的 $low$ 会因此改变，当且仅当 $low[y]&gt;dfn[x]$，而此时它已经满足条件了，所以用父亲更新并不会改变父亲成为割点的事实。（不过最好还是不要这样写，因为有些算法中的 $low$ 是严格按照定义的，这样写会导致 $low$ 的改变，尽管它并不会影响求割点的正确性）。</p>\n<p>求割点时要注意：如果这个点是搜索树的根节点，那它至少要有两个儿子满足才行。（自己想想就明白了）</p>\n<h2 id=\"桥\"><a href=\"#桥\" class=\"headerlink\" title=\"桥\"></a>桥</h2><p>$dfn[x]&lt;low[y]$</p>\n<p>割点之所以能够取等，是因为如果一个点能访问到 $x$，那把 $x$ 删掉后，显然不能访问到 $x$ 的祖先了。</p>\n<p>但是，如果仅仅割掉 $x$ 和 $y$ 相连的边，那么 $y$ 还是能访问到 $x$，进而访问到 $x$ 的祖先，所以不能取等。</p>\n<p>常见结论：</p>\n<ol>\n<li><p>桥一定是搜索树中的边。</p>\n<p>证明：</p>\n<p>如果不在搜索树中，删掉这条边对搜索树的形态没有影响，所以搜索树上的各点依然连通。</p>\n</li>\n<li><p>桥一定不是环中的边。</p>\n<p>证明：</p>\n<p>如果是环中的边，那删去它后，它两边的节点是唯一受到影响的，且由于它们都在同一个环内，所以仍然连通。</p>\n</li>\n</ol>\n<p>求桥时要注意：虽然我们说一个节点的父亲不能用来更新它，但是如果它和父亲之间有多条边（重边），那么父亲就可以更新它了，所以不能用是否是父亲来判断是否能更新 $low$，而要通过是否是反向边来判断。</p>\n<h2 id=\"无向图连通分量\"><a href=\"#无向图连通分量\" class=\"headerlink\" title=\"无向图连通分量\"></a>无向图连通分量</h2><h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>双连通分量是对于无向图的称呼，一定要和强连通分量区分，因为无向连通图本质上就是一个极大强连通分量。</p>\n<p>简单环：和我们通常画出的环类似，学术一点说，就是把两点之间的无向边看成一条，能首位相接的一些点组成的环。</p>\n<p>点双连通分量：每个点都包含在一个简单环中，这样的点构成的集合。</p>\n<p>​    特例：只包含 $\\leq 2$ 个点的连通子图也叫点双连通分量。</p>\n<p>边双连通分量：每条边都包含在一个简单环中，所连接的点构成的集合。</p>\n<p>​    特例：只包含 $1$ 个点的孤立点也叫边双连通分量。</p>\n<p>这两个连通分量在图中可以找到很多，但是我们一般会求出所有的极大双连通分量，这样图可以被唯一划分，也会带来许多有用的性质。</p>\n<h3 id=\"边双连通分量\"><a href=\"#边双连通分量\" class=\"headerlink\" title=\"边双连通分量\"></a>边双连通分量</h3><p>求出所有桥，删掉桥之后，分成的各块各自组成极大边双连通分量。</p>\n<p>显然，分开之后，各块内部没有桥，也就满足了边双连通分量的定义。而如果内部有桥，显然桥不会包含在任何一个简单环内，否则会违背桥的定义。</p>\n<p>具体实现可以把桥边都 ban 掉，在 dfs 时不走，直接染色即可。</p>\n<h3 id=\"点双连通分量\"><a href=\"#点双连通分量\" class=\"headerlink\" title=\"点双连通分量\"></a>点双连通分量</h3><p>求点双连通分量时要注意一点：一个点可能同时属于多个点双连通分量。</p>\n<p>考虑维护一个栈，每次访问到一个点就入栈，如果 $dfn[u]\\leq low[v]$ 成立，就不断弹出栈中的节点，直到弹出 $v$。之后再把 $x$ 和它们放在一起，组成一个点双连通分量。</p>\n<p>证明我也不是很清楚，但是看上去就挺对的，需要注意的就是不能把 $x$ 给弹了，因为割点可能属于多个点双连通分量。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v,flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tdfn[u] = low[u] = ++cnt,sta[++top] = u;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (u == rt &amp;&amp; !head[u])&#123;</span><br><span class=\"line\">\t\t++dcc;</span><br><span class=\"line\">\t\tdts[dcc].<span class=\"built_in\">pb</span>(u);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!dfn[v])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(v,i);</span><br><span class=\"line\">\t\t\tlow[u] = <span class=\"built_in\">min</span>(low[u],low[v]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dfn[u]&lt;=low[v])&#123;</span><br><span class=\"line\">\t\t\t\tflag++;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (u!=rt || flag&gt;<span class=\"number\">1</span>) cut[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\tdcc++;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> z;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tz = sta[top],top--;</span><br><span class=\"line\">\t\t\t\t\tdts[dcc].<span class=\"built_in\">pb</span>(z);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (z == v) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tdts[dcc].<span class=\"built_in\">pb</span>(u);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i!=(fa^<span class=\"number\">1</span>)) low[u] = <span class=\"built_in\">min</span>(low[u],dfn[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"有向图连通分量\"><a href=\"#有向图连通分量\" class=\"headerlink\" title=\"有向图连通分量\"></a>有向图连通分量</h2><h3 id=\"定义-2\"><a href=\"#定义-2\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>有向图中的连通分量，又叫强连通分量，指一个能互相到达的点的集合。</p>\n<h3 id=\"求解\"><a href=\"#求解\" class=\"headerlink\" title=\"求解\"></a>求解</h3><p>显然，一个环中的点能够相互到达，所以我们的首要任务就是找环。</p>\n<p>什么是环？假设我们沿着搜索树走，突然走到了一个祖先节点，那么就形成了一个环。</p>\n<p>你可能已经想到了，我们需要 low 数组来判断环的存在。</p>\n<p>但是，由于现在是在有向图中，所以 low 数组的定义有所差别。</p>\n<p>我们想要 low 数组表示一个点的子树内最远能走到哪一个祖先节点。</p>\n<p>首先，由于是子树内最小的 low，所以还是有 $low[u] = \\min(low[u],low[v])(fa[v] = u)$。</p>\n<p>但是，如果只是经过一条不在搜索树上的边到达的点，有可能不是祖先，还可能是已经遍历过的兄弟节点，它们在有向图中并不能代表组成环，所以我们不能用它们的 dfn 更新 low。</p>\n<p>谁是祖先节点呢？我们再维护一个栈，表示所有还没有形成强连通分量的点的集合，那么这里面的点必然是它的祖先。因为在走不同分支时，前一个分支遍历完毕后，必然会组成多个强连通分量（因为它连不到外面去）。</p>\n<p>但是，有这样一些点，它们的 dfn 和 low 相等，也就是说，它们到达不了任何祖先，所以肯定要形成一个强连通分量，我们每次找到这样的点，就不断弹出，直到它被弹出。</p>\n","tags":["Knowledge","图论","强连通分量"]},{"title":"浅谈AC自动机","url":"/2022/08/07/%E6%B5%85%E8%B0%88AC%E8%87%AA%E5%8A%A8%E6%9C%BA/","content":"<h1 id=\"浅谈AC自动机\"><a href=\"#浅谈AC自动机\" class=\"headerlink\" title=\"浅谈AC自动机\"></a>浅谈AC自动机</h1><p>$\\color{lightblue}Status: OK$</p>\n<h2 id=\"前置内容\"><a href=\"#前置内容\" class=\"headerlink\" title=\"前置内容\"></a>前置内容</h2><p>AC自动机是用 Trie 树构建的，所以在学AC自动机之前，你需要先学会 <a href=\"https://bowenone580.github.io/2022/07/22/%E6%B5%85%E8%B0%88Trie%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/\">Trie</a>。</p>\n<h2 id=\"用来做什么\"><a href=\"#用来做什么\" class=\"headerlink\" title=\"用来做什么\"></a>用来做什么</h2><p>在一个串内匹配多个模式串，并对匹配结果进行若干操作。</p>\n<p>利用 fail 数组解决多种问题。</p>\n<p>在 AC自动机上 DP。</p>\n<span id=\"more\"></span>\n<h2 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h2><p>先上模板题链接：<a href=\"https://www.luogu.com.cn/problem/P3808\">P3808 AC自动机（简单版）</a>。</p>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><p>把所有的模式串插入 Trie 中，时间复杂度为 $O(\\sum_{i=1}^n |s_i|)$。</p>\n<h3 id=\"构建-fail-边\"><a href=\"#构建-fail-边\" class=\"headerlink\" title=\"构建 fail 边\"></a>构建 fail 边</h3><p>现在，我们要对 Trie 上的每个节点 $i$，计算出从根节点到它形成的这个字符串，能够在所有模式串的前缀中匹配的最长后缀，用 $fail[i]$ 存储这个后缀处在的节点。</p>\n<p>假设现在有一个节点 $x$，它的父亲是 $p$，且满足 $tr[p][c] = x$，我们已经求出了 $p$ 节点的 fail。</p>\n<p>显然，$fail[x] = tr[fail[p]][c]$，因为 $fail[p]$ 存储的是能和 $p$ 匹配的最长后缀，所以同时加上一个 $c$，必然还是后缀。</p>\n<p>至于为啥最长，如果有比它更长的，那么同时减去一个 $c$，它必然是 $p$ 的更长的后缀，和 fail 的定义冲突，所以最长。</p>\n<p>这时候，你可能会问：如果 $fail[p]$ 所在的节点没有 $c$ 这个儿子，怎么办呢？</p>\n<p>我们强行让它有这个儿子，即 $tr[p][c] = tr[fail[p]][c]$。</p>\n<p>仔细想想，这就相当于一个路径压缩的过程，没有就指向上一次有的，每次都指，不就是一个并查集吗？所以这样指是合法的。</p>\n<p>至此，fail 构建的方法已经出来了，正确性也有了保证。</p>\n<p>再想一想我们构建一个节点 fail 的前提：它的父亲的 fail 已经构建出来。</p>\n<p>这提示我们什么？要用 BFS 完成构建。</p>\n<p>先插入根节点所有存在的儿子（不直接插入根节点是因为，根据上面的规则，它的儿子会把 fail 都设成自己），之后每次取出一个儿子，把所有子节点的 fail 更新或创建子节点，原来已经有的子节点入队，更新它的儿子。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++) <span class=\"keyword\">if</span> (tr[<span class=\"number\">0</span>][i]) q.<span class=\"built_in\">push</span>(tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\"><span class=\"type\">int</span> now;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\tnow = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> fai = fail[now];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!tr[now][i]) tr[now][i] = tr[fai][i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tfail[tr[now][i]] = tr[fai][i];</span><br><span class=\"line\">\t\t\tq.<span class=\"built_in\">push</span>(tr[now][i]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完成这项操作的时间复杂度最大为 $O(26\\sum_{i=1}^n|s_i|)$。</p>\n<p>Bonus：fail 边构成的图为 fail 树，fail 边和 Trie 树组成的图叫 fail图。请你证明一下 fail 边构成的一定是个树。</p>\n<h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><p>以这道题中的查询为例，我们需要查询有多少个模式串在匹配串中出现。</p>\n<p>把匹配串放到 AC自动机上面跑（其实就是 Trie+fail 边组成的图），可以对每个前缀跑出来一个匹配的最长后缀，之后不断走 fail 边，即可遍历这个后缀的所有后缀，最后累加一下是串的结尾的后缀即可。注意已经访问过的后缀不用再访问，因为后面走的所有点都走过了，这样可以使每个点都只被访问一次，降低复杂度。</p>\n<h3 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,tr[N][<span class=\"number\">26</span>],tot,fail[N],ans,exi[N];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!tr[now][c]) tr[now][c] = ++tot;</span><br><span class=\"line\">\t\tnow = tr[now][c];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\texi[now]++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++) <span class=\"keyword\">if</span> (tr[<span class=\"number\">0</span>][i]) q.<span class=\"built_in\">push</span>(tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">\t<span class=\"type\">int</span> now;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\tnow = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> fai = fail[now];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!tr[now][i]) tr[now][i] = tr[fai][i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tfail[tr[now][i]] = tr[fai][i];</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(tr[now][i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\tnow = tr[now][c];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> tmp = now;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (tmp &amp;&amp; exi[tmp]!=<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\tans+=exi[tmp]; </span><br><span class=\"line\">\t\t\texi[tmp] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\ttmp = fail[tmp];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">insert</span>(s); </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>();</span><br><span class=\"line\">\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">query</span>(s);</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结一下，AC自动机可以完成多模式串匹配，fail 边指向的是和这个串的后缀匹配的模式串的最长前缀，构建一个AC自动机的时间复杂度和空间复杂度均为 $O(26\\sum|s_i|)$。</p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p><a href=\"https://www.luogu.com.cn/problem/P3796\">P3796 AC自动机（加强版）</a></p>\n<h2 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h2><p>不妨想想，AC自动机能拥有这样好的性能的原因是什么？不难发现，一切的奥秘都在 fail 边之中。正是因为添加了 fail 边，才能 $O(1)$ 找到最长公共后缀，这启发我们：还可以拿 fail 边干点啥别的事吗？</p>\n<h3 id=\"拓扑建图优化计数\"><a href=\"#拓扑建图优化计数\" class=\"headerlink\" title=\"拓扑建图优化计数\"></a>拓扑建图优化计数</h3><p><a href=\"https://www.luogu.com.cn/problem/P5357\">P5357 AC 自动机（二次加强版）</a></p>\n<p>先说一个朴素的做法。</p>\n<p>把AC自动机建出来，再把 $s$ 放上去匹配，每次匹配时，不断跳 fail 边，再把遇到的结束位置的计数器加 $1$。</p>\n<p>这样的时间复杂度是多少呢？每次跳 fail 边最少使长度减 $1$，最多要跳 $\\max(|t_i|)$ 次，总时间复杂度为 $O(|s||t|)$。</p>\n<p>但是，这样会带来大量重复的计算。</p>\n<p>比如，我们从 $a$ 跳到 $b$，再跳到 $c$，把 $b,c$ 的计数器都加 $1$，下一次我们又来到了 $b$，又要跳到 $c$。发现了什么，这个跳的过程是可以合并的。我们第一次从 $a\\rightarrow b$ 之后，不继续跳了，只是跟 $b$ 说你多跳一次，也就是把 $b$ 的计数器加 $1$。</p>\n<p>既然这样，每个节点跳 fail 之前就有一个限制：所有要跳到它的节点都已经被访问过了。</p>\n<p>学术一点说，就是它的入度要为 $0$，这就可以用拓扑排序解决了。</p>\n<h4 id=\"Code-1\"><a href=\"#Code-1\" class=\"headerlink\" title=\"Code\"></a>Code</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,M = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,tr[N][<span class=\"number\">26</span>],fail[N],tot,mp[N],indeg[N],ans[N];</span><br><span class=\"line\"><span class=\"type\">char</span> s[M];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">char</span> *s,<span class=\"type\">int</span> id)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!tr[now][c]) tr[now][c] = ++tot;</span><br><span class=\"line\">\t\tnow = tr[now][c];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmp[id] = now;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++) <span class=\"keyword\">if</span> (tr[<span class=\"number\">0</span>][i]) q.<span class=\"built_in\">push</span>(tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">\t<span class=\"type\">int</span> now;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\tnow = q.<span class=\"built_in\">front</span>(),q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> fa = fail[now];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!tr[now][i]) tr[now][i] = tr[fa][i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tfail[tr[now][i]] = tr[fa][i];</span><br><span class=\"line\">\t\t\t\tindeg[tr[fa][i]]++;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(tr[now][i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\tnow = tr[now][c];</span><br><span class=\"line\">\t\tans[now]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">topo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!indeg[i]) q.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\tnow = q.<span class=\"built_in\">front</span>(),q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\tans[fail[now]]+=ans[now];</span><br><span class=\"line\">\t\tindeg[fail[now]]--;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!indeg[fail[now]]) q.<span class=\"built_in\">push</span>(fail[now]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">insert</span>(s,i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>();</span><br><span class=\"line\">\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">query</span>(s);</span><br><span class=\"line\">\t<span class=\"built_in\">topo</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cout&lt;&lt;ans[mp[i]]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h4><p><a href=\"https://www.luogu.com.cn/problem/P3041\">P3041 [USACO12JAN]Video Game G</a></p>\n<p>（这题不用拓扑建图也能水过去，但是万一被加强了呢？）</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P3065\">P3065 [USACO12DEC]First! G</a></p>\n<p>（这题其实也是诈骗，因为虽然要拓扑排序，但是跟这里的拓扑建图没有任何关系，甚至不用AC自动机）</p>\n<h3 id=\"套上-DP\"><a href=\"#套上-DP\" class=\"headerlink\" title=\"套上 DP\"></a>套上 DP</h3><p><a href=\"https://www.luogu.com.cn/problem/P4052\">P4052 [JSOI2007]文本生成器</a></p>\n<p>先用一个容斥，把问题转化为求不可读文本的数量。</p>\n<p>假设我们匹配一个串，它什么时候不可读？</p>\n<p>显然，把它放在 AC 自动机上匹配，一直匹配不到末尾节点，就不可读。</p>\n<p>看到计数，自然想到 DP，而这个 DP 状态，根据某些大佬的说法，一般都是设 $f[i][j]$ 表示串的长度为 $i$，匹配到 AC自动机上的 $j$ 节点，转移也是非常套路的枚举 $i,j$ 和这次加入的字符。时间复杂度为 $O(26|s||\\sum t_i|)$。</p>\n<p>放个转移方程：</p>\n<p>$f[i+1][tr[j][p]]+=f[i][j]$</p>\n<p>条件是 $tr[j][p]$ 不为终止节点，且 $j$ 也不为终止节点（不要也行，因为前面的条件就限制了 $f[i][j]$ 必定为 $0$）。</p>\n<p>初始化时把 $f[0][0]$ 初始化为 $1$。</p>\n<h4 id=\"Code-2\"><a href=\"#Code-2\" class=\"headerlink\" title=\"Code\"></a>Code</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e4</span>+<span class=\"number\">10</span>,M = <span class=\"number\">1e2</span>+<span class=\"number\">10</span>,mod = <span class=\"number\">1e4</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,tr[N][<span class=\"number\">26</span>],ok[N],fail[N],tot,f[M][N];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!tr[now][c]) tr[now][c] = ++tot;</span><br><span class=\"line\">        now = tr[now][c];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ok[now] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++) <span class=\"keyword\">if</span> (tr[<span class=\"number\">0</span>][i]) q.<span class=\"built_in\">push</span>(tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">    <span class=\"type\">int</span> now;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        now = q.<span class=\"built_in\">front</span>(),q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> fa = fail[now];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!tr[now][i]) tr[now][i] = tr[fa][i];</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                fail[tr[now][i]] = tr[fa][i];</span><br><span class=\"line\">                ok[tr[now][i]]|=ok[tr[fa][i]];</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(tr[now][i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ksm</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">1</span>,bas = x;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ret = ret*bas%mod;</span><br><span class=\"line\">        bas = bas*bas%mod;</span><br><span class=\"line\">        y&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">insert</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">build</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"built_in\">ksm</span>(<span class=\"number\">26</span>,m);</span><br><span class=\"line\">    f[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;<span class=\"number\">26</span>;p++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!ok[tr[j][p]]) f[i+<span class=\"number\">1</span>][tr[j][p]] = (f[i+<span class=\"number\">1</span>][tr[j][p]]+f[i][j])%mod;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=tot;i++) ans = (ans-f[m+<span class=\"number\">1</span>][i])%mod;</span><br><span class=\"line\">    ans = (ans+mod)%mod;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 AC自动机上 DP 的题还有很多，最重要的就是状态转移方程，所以要好好理解 AC自动机的原理和各个细节的含义。</p>\n<h4 id=\"练习-2\"><a href=\"#练习-2\" class=\"headerlink\" title=\"练习\"></a>练习</h4><p><a href=\"https://www.luogu.com.cn/problem/P3311\">P3311 [SDOI2014] 数数</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P2292\">P2292 [HNOI2004] L 语言</a></p>\n<h3 id=\"在-fail-树上-dfs\"><a href=\"#在-fail-树上-dfs\" class=\"headerlink\" title=\"在 fail 树上 dfs\"></a>在 fail 树上 dfs</h3><p><a href=\"https://www.luogu.com.cn/problem/P2444\">P2444 POI2000 病毒</a></p>\n<p>所谓不包含病毒串，就是这个串在 Trie 上匹配时，不会走到病毒串的末尾。</p>\n<p>所谓无限长的串，就是 dfs 整个 Trie 时会形成环。</p>\n<p>一个节点会走到病毒串的末尾，条件是这个串一直跳 fail，会跳到病毒串末尾，于是我们只要知道它的 fail 是否跳到病毒串末尾，就可以知道它是否会跳到了。</p>\n<p>dfs 时对每个走过的点打上标记，如果走到了经过的点，就说明找到环了。</p>\n<p>代码就不放了，相信大家的能力！<del>实际上是我之前写了一个很慢的 dp，懒的再写一个了</del></p>\n<h3 id=\"在-fail-树上求-lca\"><a href=\"#在-fail-树上求-lca\" class=\"headerlink\" title=\"在 fail 树上求 lca\"></a>在 fail 树上求 lca</h3><p><a href=\"https://www.luogu.com.cn/problem/P4600\">P4600 HEOI2012 旅行问题</a></p>\n<p>神仙题。</p>\n<p>为啥这题神仙，因为你如果不想 AC（自动机），不想 fail（树），那就无法可想了。<del>不信你用其他的方法搞1h，能搞出来算我输；您再想1h，不看题解能想到lca上，那您就是神仙了</del></p>\n<p>废话不多说，我们直接分析如何做。（也别管是怎么想到的了）</p>\n<p>显然，AC自动机上的每一个点的 fail 边指向的都是最长后缀，且这个后缀必然是一个字符串的前缀（根据 Trie 的性质）。</p>\n<p>之后，我们求两个点在 fail 树上的 lca，思考其意义。</p>\n<p>显然，从根节点到 lca 的链是两个点对应的串的后缀（毕竟能跳 fail 到那里去），且是最长公共后缀（你想想啥是 lca），而且还是其中一个字符串的子串（它在 Trie 上）。</p>\n<p>这不就是我们要求的东西吗？</p>\n<p>温馨提示：此题卡空间，您如果用倍增求 lca 可能会挂掉 $2$ 个点，在此放上常数巨大无比的转 dfs 序后用线段树求 lca 的代码。<del>不会树剖锕</del></p>\n<h4 id=\"Code-3\"><a href=\"#Code-3\" class=\"headerlink\" title=\"Code\"></a>Code</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e6</span>+<span class=\"number\">5</span>,mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,val[N],head[N],tot,cnt,col,ori[N],beg[N],en[N],dfn[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; pre[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">SegT</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> Min[N*<span class=\"number\">8</span>];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">\t\tMin[node] = <span class=\"built_in\">min</span>(Min[node&lt;&lt;<span class=\"number\">1</span>],Min[node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">\t\t\tMin[node] = dfn[l];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>,lc = node&lt;&lt;<span class=\"number\">1</span>,rc = node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">build</span>(lc,l,mid);</span><br><span class=\"line\">\t\t<span class=\"built_in\">build</span>(rc,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushup</span>(node);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> beg,<span class=\"type\">int</span> en,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (beg&gt;=l &amp;&amp; en&lt;=r) <span class=\"keyword\">return</span> Min[node];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = (beg+en)&gt;&gt;<span class=\"number\">1</span>,ans = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l&lt;=mid) ans = <span class=\"built_in\">min</span>(ans,<span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>,beg,mid,l,r));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (r&gt;mid) ans = <span class=\"built_in\">min</span>(ans,<span class=\"built_in\">query</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,en,l,r));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ACAM</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tr[N][<span class=\"number\">26</span>],fail[N],tot;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> id)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!tr[now][c])&#123;</span><br><span class=\"line\">\t\t\t\ttr[now][c] = ++tot;</span><br><span class=\"line\">\t\t\t\tval[tot] = (<span class=\"number\">1ll</span>*val[now]*<span class=\"number\">26</span>+c)%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tnow = tr[now][c];</span><br><span class=\"line\">\t\t\tpre[id].<span class=\"built_in\">push_back</span>(now);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tr[<span class=\"number\">0</span>][i])&#123;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"number\">0</span>,tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t\tnow = q.<span class=\"built_in\">front</span>(),q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> fa = fail[now];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!tr[now][i]) tr[now][i] = tr[fa][i];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tfail[tr[now][i]] = tr[fa][i];</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">add</span>(tr[fa][i],tr[now][i]);</span><br><span class=\"line\">\t\t\t\t\tq.<span class=\"built_in\">push</span>(tr[now][i]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; ac;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\tcol++;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = col;</span><br><span class=\"line\">\tori[tmp] = u;</span><br><span class=\"line\">\tdfn[++cnt] = tmp;</span><br><span class=\"line\">\tbeg[u] = cnt;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t\tdfn[++cnt] = tmp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ten[u] = cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tac.<span class=\"built_in\">insert</span>(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tac.<span class=\"built_in\">build</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>,<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tt.<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,cnt);</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a,b,c,d,x,y,l,r;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class=\"line\">\t\tx = pre[a][b<span class=\"number\">-1</span>],y = pre[c][d<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\tl = <span class=\"built_in\">min</span>(beg[x],beg[y]),r = <span class=\"built_in\">max</span>(en[x],en[y]);</span><br><span class=\"line\">\t\tcout&lt;&lt;val[ori[t.<span class=\"built_in\">query</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,cnt,l,r)]]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在-fail-树上跑树状数组\"><a href=\"#在-fail-树上跑树状数组\" class=\"headerlink\" title=\"在 fail 树上跑树状数组\"></a>在 fail 树上跑树状数组</h3><p><a href=\"https://www.luogu.com.cn/problem/P2414\">P2414 NOI2011 阿狸的打字机</a></p>\n<p>题目有两个比较特殊的限制：一是每次只能添加或减少 $1$ 个字符，二是只有询问，而且询问是独立的。</p>\n<p>我们先想一想如何回答询问。</p>\n<p>比较暴力的方法是把 $y$ 放到 AC自动机上跑，每次跳 fail，看有多少次跳到了 $x$。</p>\n<p>更具体一点，对每一个 $y$ 的节点，统计在其到根节点的路径上出现了 $x$ 的末尾节点的次数。</p>\n<p>换一种表述，就是求 $x$ 节点的子树内，属于 $y$ 的节点的个数。</p>\n<p>对每一个询问都跑一遍不是很现实，但是询问是独立的，也就是说处理询问的顺序和答案一点关系都没有，不妨离线下来。</p>\n<p>而且，每次切换 $y$ 串的时候，需要修改很多不同的节点，相反，每次加一个字符，或删除一个字符，只需要修改一个节点。</p>\n<p>可以以 $y$ 为第一关键字排序，边处理整个操作串边修改，修改次数为 $O(n)$ 级别。到了有询问的串时，就变成了经典的查询子树和的问题，可以把树拍扁，在 dfs 序上修改，最后区间求和，树状数组显然可以胜任这个工作。</p>\n<p>总时间复杂度为 $O(n+m\\log n)$。</p>\n<h4 id=\"Code-4\"><a href=\"#Code-4\" class=\"headerlink\" title=\"Code\"></a>Code</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> mp make_pair</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,head[N],tot,dfn[N],cnt,l[N],r[N],ans[N],ori[N];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\">vector&lt;pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; &gt; a[N];</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; exi[N];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">52</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">BIT</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tr[N*<span class=\"number\">4</span>];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (;x&lt;=cnt;x+=(x&amp;(-x))) tr[x]+=v;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (;x;x-=(x&amp;(-x))) ans+=tr[x];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; tr1;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ACAM</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tr[N][<span class=\"number\">26</span>],tot = <span class=\"number\">0</span>,fa[N],fail[N];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;P&#x27;</span>) exi[now].<span class=\"built_in\">pb</span>(++cnt),ori[cnt] = now;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;B&#x27;</span>) now = fa[now];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!tr[now][c])&#123;</span><br><span class=\"line\">\t\t\t\t\ttr[now][c] = ++tot;</span><br><span class=\"line\">\t\t\t\t\tfa[tot] = now;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tnow = tr[now][c];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tr[<span class=\"number\">0</span>][i])&#123;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">add</span>(<span class=\"number\">0</span>,tr[<span class=\"number\">0</span>][i]);</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">add</span>(tr[<span class=\"number\">0</span>][i],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t\tnow = q.<span class=\"built_in\">front</span>(),q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> fai = fail[now];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">26</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!tr[now][i]) tr[now][i] = tr[fai][i];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\tfail[tr[now][i]] = tr[fai][i];</span><br><span class=\"line\">\t\t\t\t\tq.<span class=\"built_in\">push</span>(tr[now][i]);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">add</span>(tr[now][i],fail[tr[now][i]]);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">add</span>(fail[tr[now][i]],tr[now][i]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">query</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;P&#x27;</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> tmp1,tmp2;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> x:exi[now])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> y:a[x])&#123;</span><br><span class=\"line\">\t\t\t\t\t\ttmp1 = ori[y.first];</span><br><span class=\"line\">\t\t\t\t\t\ttmp2 = y.second;</span><br><span class=\"line\">\t\t\t\t\t\tans[tmp2] = tr1.<span class=\"built_in\">query</span>(r[tmp1])-tr1.<span class=\"built_in\">query</span>(l[tmp1]<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s[i] == <span class=\"string\">&#x27;B&#x27;</span>)&#123;</span><br><span class=\"line\">\t\t\t\ttr1.<span class=\"built_in\">update</span>(l[now],<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t\t\tnow = fa[now];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t\t\tnow = tr[now][c];</span><br><span class=\"line\">\t\t\t\ttr1.<span class=\"built_in\">update</span>(l[now],<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tdfn[++cnt] = u;</span><br><span class=\"line\">\tl[u] = cnt;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdfn[++cnt] = u;</span><br><span class=\"line\">\tr[u] = cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;(s+<span class=\"number\">1</span>)&gt;&gt;m;</span><br><span class=\"line\">\tn = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\ta[y].<span class=\"built_in\">pb</span>(<span class=\"built_in\">mp</span>(x,i));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tt.<span class=\"built_in\">insert</span>();</span><br><span class=\"line\">\tt.<span class=\"built_in\">build</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>,<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tt.<span class=\"built_in\">query</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","字符串","AC自动机"]},{"title":"浅谈Hash","url":"/2022/07/19/%E6%B5%85%E8%B0%88Hash/","content":"<h1 id=\"浅谈Hash\"><a href=\"#浅谈Hash\" class=\"headerlink\" title=\"浅谈Hash\"></a>浅谈Hash</h1><p>$\\color{lightblue}Status: OK$</p>\n<h2 id=\"什么是Hash\"><a href=\"#什么是Hash\" class=\"headerlink\" title=\"什么是Hash\"></a>什么是Hash</h2><p>由于每个字母对应的 ASCII 码都一样，所以可以把一个字符串看成一个 $p$ 进制数，每一位上就是字母对应的 ASCII 码，这样一来，一个字符串生成的数字（也叫Hash值）就是唯一的了。</p>\n<p>但是，在实际应用中，没有办法存储这样大的一个数字，所以要对它进行取模。但是，一旦取模了，就有可能造成两个字符串在取模后，对应的数字相同的情况，为了尽可能避免这种情况，我们一般对一个大质数取模。有时，可能还需要对不同的数取模，计算两个Hash值，以尽量确保答案的正确性（当然，会有性能损失）。</p>\n<span id=\"more\"></span>\n<h2 id=\"例题1\"><a href=\"#例题1\" class=\"headerlink\" title=\"例题1\"></a>例题1</h2><p><a href=\"https://www.luogu.com.cn/problem/CF955D\">CF955D Scissors</a></p>\n<p>思考一下 $t$ 在新合成的串中出现的情况：</p>\n<ol>\n<li>在两个串之间的任意一个中出现</li>\n<li>左半边是其中一个串的后缀，右半边是其中一个串的前缀。</li>\n</ol>\n<p>第一种情况相当于枚举起点，判断两个串是否相等，可以通过Hash $O(1)$ 解决。</p>\n<p>现在考虑第二种情况。</p>\n<p>由于我们只需要找到一组合法的解，根据贪心，要使串能尽可能不重叠，需要让后缀串（左边的）靠前，前缀串（右边的）靠后。所以，只需要找到每个后缀最先出现的位置，和每个前缀最后出现的位置就行了。</p>\n<p>但是，要注意前缀串出现的位置的结尾要 $\\geq k$，后缀串出现的结尾要 $\\leq n-k+1$。</p>\n<p>以前缀为例，暴力维护它：从 $k$ 开始枚举结尾位置，每次暴力判断是否合法，找到第一个合法的位置就退出。</p>\n<p>这样做的时间复杂度最坏是 $O(n^2)$，考虑优化。</p>\n<p>枚举前缀的长度，先判断以 $k$ 结尾的串是否匹配，找到最大的能匹配的长度 $d$。显然，前缀长度在 $d$ 以内的串都不优，因为如果放弃长度为 $d$ 的以 $k$ 结尾的串，使用长度 $\\leq d$ 的以 $\\geq k$ 的位置结尾的串，能匹配上后面一个后缀串，那用长度为 $d$ 的前缀，只用把</p>\n<p>请忽略上面说的话，这题 Hash 我不知道怎么做到线性！</p>\n<p>由于数据较水，各种玄学代码都能通过，这里给一个能卡掉部分代码的样例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">12 4 3</span><br><span class=\"line\">abcddabddcef</span><br><span class=\"line\">abce</span><br></pre></td></tr></table></figure>\n<p>如果您不能分析代码的时间复杂度，那么您写的大概率能被这个卡掉：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">500000 400000 200000</span><br><span class=\"line\">ababab...abccc...ccc (前250000是ab，后250000是c)</span><br><span class=\"line\">ababab...ab</span><br></pre></td></tr></table></figure>\n<p>但如果您实力超群，发现了行之有效的线性 Hash 代码，请 Luogu 私信教教我 qwq。</p>\n<p>练习：<a href=\"https://www.luogu.com.cn/problem/CF1200E\">CF1200E Compress Words</a></p>\n<h2 id=\"例题2\"><a href=\"#例题2\" class=\"headerlink\" title=\"例题2\"></a>例题2</h2><p><a href=\"https://www.luogu.com.cn/problem/UVA11019\">UVA11019 Matrix Matcher</a></p>\n<p>二维 Hash模板题。</p>\n<p>思想其实和一维的差不多，只是 $(i,j)$ 上维护的是 $(1,1)$ 到 $(i,j)$ 的矩阵的 Hash 值，我们可以先对横向都求一遍 Hash，之后对求出来的 Hash 再到纵向上求一遍，两次最好用不同的进制，以避免冲突（反正 Hash 过不了大半都是模数和进制的选择问题，双 Hash 还是最稳的）。</p>\n<h3 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> x1 xx1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> y1 yy1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> x2 xx2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> y2 yy2</span></span><br><span class=\"line\"><span class=\"comment\">//这里define这么多是因为其中有些是C++的内置函数</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e3</span>+<span class=\"number\">10</span>,p1 = <span class=\"number\">131</span>,p2 = <span class=\"number\">233</span>,mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,m,x,y;</span><br><span class=\"line\">ll has[N][N][<span class=\"number\">3</span>],pw1[N],pw2[N];</span><br><span class=\"line\"><span class=\"type\">char</span> s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tpw1[<span class=\"number\">0</span>] = pw2[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">1000</span>;i++)&#123;</span><br><span class=\"line\">\t\tpw1[i] = (pw1[i<span class=\"number\">-1</span>]*p1)%mod;</span><br><span class=\"line\">\t\tpw2[i] = (pw2[i<span class=\"number\">-1</span>]*p2)%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"type\">int</span> x1,<span class=\"type\">int</span> y1,<span class=\"type\">int</span> x2,<span class=\"type\">int</span> y2)</span></span>&#123;</span><br><span class=\"line\">\tx1--,y1--;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ((has[x2][y2][<span class=\"number\">0</span>]+has[x1][y1][<span class=\"number\">0</span>]*pw1[x2-x1]%mod*pw2[y2-y1]%mod-has[x1][y2][<span class=\"number\">0</span>]*pw1[x2-x1]-has[x2][y1][<span class=\"number\">0</span>]*pw2[y2-y1])%mod+mod)%mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"built_in\">init</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\tll h = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\t\t\tcin&gt;&gt;s;</span><br><span class=\"line\">\t\t\t\th = (h*p2+s)%mod;</span><br><span class=\"line\">\t\t\t\thas[i][j][<span class=\"number\">0</span>] = (has[i<span class=\"number\">-1</span>][j][<span class=\"number\">0</span>]*p1+h)%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=x;i++)&#123;</span><br><span class=\"line\">\t\t\tll h = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=y;j++)&#123;</span><br><span class=\"line\">\t\t\t\tcin&gt;&gt;s;</span><br><span class=\"line\">\t\t\t\th = (h*p2+s)%mod;</span><br><span class=\"line\">\t\t\t\thas[i][j][<span class=\"number\">1</span>] = (has[i<span class=\"number\">-1</span>][j][<span class=\"number\">1</span>]*p1+h)%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=x;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=y;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">chk</span>(i-x+<span class=\"number\">1</span>,j-y+<span class=\"number\">1</span>,i,j) == has[x][y][<span class=\"number\">1</span>]) ans++;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><p><a href=\"https://www.luogu.com.cn/problem/P4503\">P4503 [CTSC2014] 企鹅 QQ</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P3538\">P3538 [POI2012]OKR-A Horrible Poem</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P3498\">P3498 [POI2010]KOR-Beads</a></p>\n","tags":["Knowledge","字符串","Hash"]},{"title":"浅谈Trie及其应用","url":"/2022/07/22/%E6%B5%85%E8%B0%88Trie%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/","content":"<h1 id=\"浅谈-Trie-及其应用\"><a href=\"#浅谈-Trie-及其应用\" class=\"headerlink\" title=\"浅谈 Trie 及其应用\"></a>浅谈 Trie 及其应用</h1><p>$\\color{lightblue}Status: OK$</p>\n<h2 id=\"什么是-Trie-树\"><a href=\"#什么是-Trie-树\" class=\"headerlink\" title=\"什么是 Trie 树\"></a>什么是 Trie 树</h2><p>想象一下翻英文字典的过程，是不是从首字母开始，一位一位的找找下去，最后找到你想要的词？Trie 树完成的就是这个工作。</p>\n<span id=\"more\"></span>\n<p><img src=\"https://s2.loli.net/2022/07/22/ojrqhKUJyQpWeXA.png\" alt=\"Trie_1\"></p>\n<p>比如我要插入一个 boy，先定位第一个字母，发现是 b，于是来到 0 的儿子 b，之后定位第二个字母 o，来到b 的儿子 o，最后定位第三个字母 y，发现 o 还没有y 这个儿子，就新建一个 y。Trie 树的每一个节点理论上都有 $|字符集大小|$ 个儿子，这里就是 $26$ 个，如果要查询一个串是否存在，顺着儿子往下走即可。</p>\n<h2 id=\"模板题\"><a href=\"#模板题\" class=\"headerlink\" title=\"模板题\"></a>模板题</h2><p><a href=\"https://www.luogu.com.cn/problem/P2580\">P2580 于是他错误的点名开始了</a></p>\n<p>给你一些串组成的集合，每次询问一个串是否出现在这个集合里和之前是否询问过这个串。</p>\n<p>先把集合插入 Trie 中，询问时顺着 Trie 往下走，直到走不了（没有儿子）或走完为止。</p>\n<p>如何判断询问串究竟是串本身还是串的前缀呢？我们可以对插入的每个串的结尾做一个标记，则在标记处停止的询问串出现在了集合中，是否重复出现在标记处记录是否访问过即可。</p>\n<p>在实现的过程中，需要对 Trie 树的空间格外注意，一般开 $n\\cdot|s|$ 个，其中 $n$ 是字符串个数， $|s|$ 是字符串的最大长度，这是因为每次插入一个串，最多可能多开 $|s|$ 个节点（和之前的任何一个串都没有共同前缀）。这也就意味着一棵 Trie 树耗费的空间可能多达 $n\\cdot |s|\\cdot 26$ 个 int，MLE 的风险很高，要尽量节省一些空间。</p>\n<h3 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,tr[N][<span class=\"number\">26</span>],tot;</span><br><span class=\"line\"><span class=\"type\">bool</span> exi[N],vis[N];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!tr[now][c]) tr[now][c] = ++tot;</span><br><span class=\"line\">\t\tnow = tr[now][c];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\texi[now] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!tr[now][c])&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"string\">&quot;WRONG&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnow = tr[now][c];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!exi[now]) cout&lt;&lt;<span class=\"string\">&quot;WRONG&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (vis[now]) cout&lt;&lt;<span class=\"string\">&quot;REPEAT&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tvis[now] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;OK&quot;</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">insert</span>(s);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcin&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">query</span>(s);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 Trie 上每次插入或查询一个字符串的复杂度都为 $O(|s|)$。</p>\n<p>Trie 树有很多有用的性质，比如一个串的前缀表示，一些串的最长公共前缀等，这使它能处理一些特殊问题。</p>\n<h2 id=\"例题1\"><a href=\"#例题1\" class=\"headerlink\" title=\"例题1\"></a>例题1</h2><p><a href=\"https://www.luogu.com.cn/problem/UVA1401\">UVA1401 Remember the Word</a></p>\n<p>给你一些小字符串和一个大串，求用这些小串拼成大串的方案数。</p>\n<p>一般求方案数的就是 DP，可以设计这样的 DP 状态：</p>\n<p>设 $f[i]$ 表示拼成前缀 $i$ 的方案数，每次枚举 $j$，看 $s[j$~$i]$ 这个串是否是一个小串，如果是，就加上 $f[j-1]$ 。</p>\n<p>但是，这样枚举 $j$ 的复杂度很高（Hash 另说），我们不妨换一种枚举顺序：固定一个 $i$，枚举结尾 $j$，每次判断 $s[i+1$~$j]$ 是否为一个小串，这样巧妙地利用了 Trie 存前缀的性质，每次扩展一个字符的时间复杂度为 $O(1)$，由于小串的长度最大为 $50$，所以时间复杂度为 $O(50n)$。</p>\n<p>每次向右扩展一个字符可以往 Trie 上面想。</p>\n<h3 id=\"Code：-1\"><a href=\"#Code：-1\" class=\"headerlink\" title=\"Code：\"></a>Code：</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">4e5</span>+<span class=\"number\">10</span>,mod = <span class=\"number\">20071027</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,tr[N][<span class=\"number\">27</span>],tot,vis[N][<span class=\"number\">27</span>],tim;</span><br><span class=\"line\">ll f[N];</span><br><span class=\"line\"><span class=\"type\">bool</span> exi[N];</span><br><span class=\"line\"><span class=\"type\">char</span> s[N],t[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> len = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>),now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=len;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = s[i]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (vis[now][c]!=tim)&#123;</span><br><span class=\"line\">\t\t\tvis[now][c] = tim;</span><br><span class=\"line\">\t\t\ttr[now][c] = ++tot;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tnow = tr[now][c];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\texi[now] = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cin&gt;&gt;(s+<span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">\t\ttim++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(exi,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">bool</span>)*(tot+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t\ttot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tn = <span class=\"built_in\">strlen</span>(s+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(ll)*(n+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t\tcin&gt;&gt;m;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;(t+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">insert</span>(t);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tf[n+<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=n;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> c = s[j]-<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (vis[now][c]!=tim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\tnow = tr[now][c];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (exi[now]) f[i] = (f[i]+f[j+<span class=\"number\">1</span>])%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;Case &quot;</span>&lt;&lt;tim&lt;&lt;<span class=\"string\">&quot;: &quot;</span>&lt;&lt;f[<span class=\"number\">1</span>]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例题2\"><a href=\"#例题2\" class=\"headerlink\" title=\"例题2\"></a>例题2</h2><p><a href=\"https://www.luogu.com.cn/problem/P4551\">P4551 最长异或路径</a></p>\n<p>先转化一下题意：</p>\n<p>算出每个点到根的异或值，则要求的最大异或路径等于两个点到根的异或的最大值，因为根到两点 LCA 的路径异或值抵消了。</p>\n<p>转化为求 $n$ 个数里面两个数异或的最大值。</p>\n<p>把异或值拆成二进制，按位从高到低贪心，有和这一位的值相反的就取（因为后面的所有低位即使都是 $1$，也比这一位小）。</p>\n<p>如何高效的完成这个算法呢？发现所有数的高位组成的数就是它的前缀，而我们就是在前缀上比较，这类问题可以放到 Trie 上做，达到 $O(32n)$ 的复杂度。</p>\n<h3 id=\"Code：-2\"><a href=\"#Code：-2\" class=\"headerlink\" title=\"Code：\"></a>Code：</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,head[N],tot,ans;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Trie</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tr[N*<span class=\"number\">26</span>][<span class=\"number\">3</span>],tot;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">31</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> c = (x&gt;&gt;i)&amp;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!tr[now][c]) tr[now][c] = ++tot;</span><br><span class=\"line\">\t\t\tnow = tr[now][c];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">31</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> c = (x&gt;&gt;i)&amp;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tr[now][c^<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">\t\t\t\tnow = tr[now][c^<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t\tans+=(<span class=\"number\">1</span>&lt;&lt;i);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> now = tr[now][c];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa,<span class=\"type\">int</span> sum)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tt.<span class=\"built_in\">update</span>(sum);</span><br><span class=\"line\">\tans = <span class=\"built_in\">max</span>(ans,t.<span class=\"built_in\">query</span>(sum));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u,sum^edge[i].w);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,z);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,z);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种把数拆成二进制之后放到 Trie 上的叫做 01Trie，这道题只是理清了 01Trie 的基本架构，它还有一些非常好的性质和衍生的操作。</p>\n<h2 id=\"01Trie\"><a href=\"#01Trie\" class=\"headerlink\" title=\"01Trie\"></a>01Trie</h2><p>支持的操作：</p>\n<ul>\n<li>插入一个数。</li>\n<li>删除一个数。</li>\n<li>查询所有数的异或和。</li>\n<li>所有数 $+1$。</li>\n</ul>\n<p>我们一步步实现。</p>\n<p>插入和删除都是从低位到高位（其实算习惯吧，为了之后写代码方便）。</p>\n<p>在每一个 Trie 的节点 now 上记录以下几个值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ch[now][0/1] 指向它的儿子</span><br><span class=\"line\">w[now] 表示有多少个数在插入时经过了它</span><br><span class=\"line\">sum[now] 表示 now 这棵子树的异或和（但是是把 now 所在的层当作最低位，并不是真正的子树异或和）</span><br></pre></td></tr></table></figure>\n<p>怎么维护呢？先看代码吧（感觉代码可能比文字更好懂，反正文字也在代码里面）。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> &amp;now,<span class=\"type\">int</span> x,<span class=\"type\">int</span> dep)</span></span>&#123; <span class=\"comment\">//引用方便修改ch[now][0/1]</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!now) now = <span class=\"built_in\">push</span>(); <span class=\"comment\">//新建节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dep&gt;H)&#123; <span class=\"comment\">//H为最大深度，一般要保证答案在2^H以内</span></span><br><span class=\"line\">\t\tw[now]++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">insert</span>(ch[now][x&amp;<span class=\"number\">1</span>],x&gt;&gt;<span class=\"number\">1</span>,dep+<span class=\"number\">1</span>); <span class=\"comment\">//从低位到高位插入</span></span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(now); <span class=\"comment\">//维护 sum 和 w</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再看看 pushup 操作。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> now)</span></span>&#123;</span><br><span class=\"line\">\tw[now] = sum[now] = <span class=\"number\">0</span>; <span class=\"comment\">//初始化为0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ch[now][<span class=\"number\">0</span>])&#123; <span class=\"comment\">//如果把now-&gt;ch[now][0]看作一条边，那么0就相当于边权，代表第dep+1位为0</span></span><br><span class=\"line\">\t\tw[now]+=w[ch[now][<span class=\"number\">0</span>]]; <span class=\"comment\">//经过儿子的数插入时都会经过父亲</span></span><br><span class=\"line\">\t\tsum[now]^=(sum[ch[now][<span class=\"number\">0</span>]]&lt;&lt;<span class=\"number\">1</span>); <span class=\"comment\">//第dep+1位为0，对这一位的异或和没有影响</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ch[now][<span class=\"number\">1</span>])&#123; <span class=\"comment\">//同上</span></span><br><span class=\"line\">\t\tw[now]+=w[ch[now][<span class=\"number\">1</span>]]; <span class=\"comment\">//经过儿子的数插入时都会经过父亲</span></span><br><span class=\"line\">\t\tsum[now]^=((sum[ch[now][<span class=\"number\">1</span>]]&lt;&lt;<span class=\"number\">1</span>)|(w[ch[now][<span class=\"number\">1</span>]]&amp;<span class=\"number\">1</span>)); <span class=\"comment\">//第dep+1位为1，异或和只和1的奇偶性相关</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tw[now]&amp;=<span class=\"number\">1</span>; <span class=\"comment\">//因为只和奇偶性相关，所以不用存具体值（要存也没关系，维护的信息会更具体，取决于题目）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>erase 操作如法炮制。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">erase</span><span class=\"params\">(<span class=\"type\">int</span> now,<span class=\"type\">int</span> x,<span class=\"type\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dep&gt;H)&#123;</span><br><span class=\"line\">\t\tw[now]--; <span class=\"comment\">//如果不要求求具体数量的话，这里改成+1也行，或者直接不要erase，再insert一遍（异或两次等于没异或）</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">erase</span>(ch[now][x&amp;<span class=\"number\">1</span>],x&gt;&gt;<span class=\"number\">1</span>,dep+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(now);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更短的 addall（全局 $+1$）操作。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addall</span><span class=\"params\">(<span class=\"type\">int</span> now)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(ch[now][<span class=\"number\">0</span>],ch[now][<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ch[now][<span class=\"number\">0</span>]) <span class=\"built_in\">addall</span>(ch[now][<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t<span class=\"built_in\">pushup</span>(now);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个操作具体解释一下：</p>\n<p>每个数 $+1$，在二进制下表现为从最低位开始的为 $1$ 的位都变成 $0$，第一个为 $0$ 的位变成 $1$。</p>\n<p>再次思考父亲和儿子之间唯一的联系：边权。这一位是啥，边权就是啥，我们交换左右儿子就相当于交换边权。</p>\n<p>最后，因为要修改的是为 $1$ 的位，交换后变成了为 $0$ 的位，只要还有，就继续往下修改。</p>\n<p>查询所有数的异或和更简单了，直接输出 Trie 树的根的异或和即可。</p>\n<h2 id=\"例题3\"><a href=\"#例题3\" class=\"headerlink\" title=\"例题3\"></a>例题3</h2><p><a href=\"https://www.luogu.com.cn/problem/P6018\">P6018 Ynoi2010 Fusion tree</a></p>\n<p>这种树上的维护，一般分成维护一个点的所有儿子，父亲单独维护。</p>\n<p>操作 $1$ 相当于所有儿子 $+1$，父亲 $+1$。儿子的 $+1$ 直接 addall，父亲的 $+1$ 单独维护，顺便把父亲的父亲的树一起维护掉，保证正确性。</p>\n<p>操作 $2$ 相当于自己 $-v$，先在父亲的 Trie 中把自己删除，再插入更新后的自己即可。</p>\n<p>操作 $3$ 直接输出对应 Trie 树根节点的异或和异或上父亲的值即可。</p>\n<h3 id=\"Code：-3\"><a href=\"#Code：-3\" class=\"headerlink\" title=\"Code：\"></a>Code：</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e5</span>+<span class=\"number\">10</span>,H = <span class=\"number\">21</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,head[N],tot,val[N],rt,fa[N],lazy[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Trie</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> rt[N],w[N*H],ch[N*H][<span class=\"number\">2</span>],sum[N*H],tot;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">push</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\ttot++;</span><br><span class=\"line\">\t\tch[tot][<span class=\"number\">0</span>] = ch[tot][<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tw[tot] = sum[tot] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> node)</span></span>&#123;</span><br><span class=\"line\">\t\tw[node] = sum[node] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ch[node][<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">\t\t\tw[node]+=w[ch[node][<span class=\"number\">0</span>]];</span><br><span class=\"line\">\t\t\tsum[node]^=(sum[ch[node][<span class=\"number\">0</span>]]&lt;&lt;<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ch[node][<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">\t\t\tw[node]+=w[ch[node][<span class=\"number\">1</span>]];</span><br><span class=\"line\">\t\t\tsum[node]^=((sum[ch[node][<span class=\"number\">1</span>]]&lt;&lt;<span class=\"number\">1</span>)|(w[ch[node][<span class=\"number\">1</span>]]&amp;<span class=\"number\">1</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tw[node]&amp;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> &amp;now,<span class=\"type\">int</span> x,<span class=\"type\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!now) now = <span class=\"built_in\">push</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dep&gt;H)&#123;</span><br><span class=\"line\">\t\t\tw[now]++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">insert</span>(ch[now][x&amp;<span class=\"number\">1</span>],x&gt;&gt;<span class=\"number\">1</span>,dep+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushup</span>(now);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">erase</span><span class=\"params\">(<span class=\"type\">int</span> now,<span class=\"type\">int</span> x,<span class=\"type\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dep&gt;H)&#123;</span><br><span class=\"line\">\t\t\tw[now]--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">erase</span>(ch[now][x&amp;<span class=\"number\">1</span>],x&gt;&gt;<span class=\"number\">1</span>,dep+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushup</span>(now);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addall</span><span class=\"params\">(<span class=\"type\">int</span> now)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(ch[now][<span class=\"number\">0</span>],ch[now][<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ch[now][<span class=\"number\">0</span>]) <span class=\"built_in\">addall</span>(ch[now][<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushup</span>(now);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> f)</span></span>&#123;</span><br><span class=\"line\">\tfa[u] = f;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == f) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> val[x]+(fa[x]?lazy[fa[x]]:<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(rt = y,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;val[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fa[i]) t.<span class=\"built_in\">insert</span>(t.rt[fa[i]],val[i],<span class=\"number\">0</span>); <span class=\"comment\">//这里不用担心rt初始为0的问题，因为是引用，如果没有rt会自动创建一个 </span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> op;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op&gt;&gt;x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tlazy[x]++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (fa[x])&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (fa[fa[x]]) t.<span class=\"built_in\">erase</span>(t.rt[fa[fa[x]]],<span class=\"built_in\">get</span>(fa[x]),<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t\tval[fa[x]]++;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (fa[fa[x]]) t.<span class=\"built_in\">insert</span>(t.rt[fa[fa[x]]],<span class=\"built_in\">get</span>(fa[x]),<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tt.<span class=\"built_in\">addall</span>(t.rt[x]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (op == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;y;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (fa[x]) t.<span class=\"built_in\">erase</span>(t.rt[fa[x]],<span class=\"built_in\">get</span>(x),<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\tval[x]-=y;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (fa[x]) t.<span class=\"built_in\">insert</span>(t.rt[fa[x]],<span class=\"built_in\">get</span>(x),<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;(t.sum[t.rt[x]]^(fa[x]?<span class=\"built_in\">get</span>(fa[x]):<span class=\"number\">0</span>))&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"01Trie-合并\"><a href=\"#01Trie-合并\" class=\"headerlink\" title=\"01Trie 合并\"></a>01Trie 合并</h2><p>先看代码。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span>&#123; <span class=\"comment\">//a和b为两个树上位置相同的节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!a) <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!b) <span class=\"keyword\">return</span> a; <span class=\"comment\">//如果其中一个不存在，那它的子树也不存在，所以不用修改子树</span></span><br><span class=\"line\">\tw[a]+=w[b];</span><br><span class=\"line\">\tsum[a]^=sum[b]; <span class=\"comment\">//直接修改</span></span><br><span class=\"line\">\tch[a][<span class=\"number\">0</span>] = <span class=\"built_in\">merge</span>(ch[a][<span class=\"number\">0</span>],ch[b][<span class=\"number\">0</span>]);</span><br><span class=\"line\">\tch[a][<span class=\"number\">1</span>] = <span class=\"built_in\">merge</span>(ch[a][<span class=\"number\">1</span>],ch[b][<span class=\"number\">1</span>]); <span class=\"comment\">//更新两个儿子</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次合并两个 01Trie 时，看成小的 Trie 往大的 Trie 里面合并，那么小的 Trie 中的元素所在集合大小就会翻倍，每次合并至少让一个 Trie 中的元素大小翻倍，最后所有元素的大小都到了 $n$（属于同一个大集合），所以一个元素被合并的次数为 $\\log n$ 次，时间复杂度为 $O(n\\log n)$。</p>\n<h2 id=\"例题4\"><a href=\"#例题4\" class=\"headerlink\" title=\"例题4\"></a>例题4</h2><p><a href=\"https://www.luogu.com.cn/problem/P6623\">P6623 省选联考 2020 A 卷 树</a></p>\n<p>容易想到合并子树的 Trie，之后全局 $+1$，再加上自己，dfs 一遍，加上每个点的异或和就是答案。</p>\n<h3 id=\"Code：-4\"><a href=\"#Code：-4\" class=\"headerlink\" title=\"Code：\"></a>Code：</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">6e5</span>+<span class=\"number\">10</span>,H = <span class=\"number\">23</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,val[N],head[N],tot;</span><br><span class=\"line\">ll ans;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Trie</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ch[N*H][<span class=\"number\">2</span>],w[N*H],rt[N],tot;</span><br><span class=\"line\">\tll sum[N*H];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">push</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\ttot++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tot;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pushup</span><span class=\"params\">(<span class=\"type\">int</span> now)</span></span>&#123;</span><br><span class=\"line\">\t\tw[now] = sum[now] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ch[now][<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">\t\t\tw[now]+=w[ch[now][<span class=\"number\">0</span>]];</span><br><span class=\"line\">\t\t\tsum[now]^=(sum[ch[now][<span class=\"number\">0</span>]]&lt;&lt;<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ch[now][<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">\t\t\tw[now]+=w[ch[now][<span class=\"number\">1</span>]];</span><br><span class=\"line\">\t\t\tsum[now]^=((sum[ch[now][<span class=\"number\">1</span>]]&lt;&lt;<span class=\"number\">1</span>)|(w[ch[now][<span class=\"number\">1</span>]]&amp;<span class=\"number\">1</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tw[now]&amp;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> &amp;now,<span class=\"type\">int</span> x,<span class=\"type\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!now) now = <span class=\"built_in\">push</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dep&gt;H)&#123;</span><br><span class=\"line\">\t\t\tw[now]++;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">insert</span>(ch[now][x&amp;<span class=\"number\">1</span>],x&gt;&gt;<span class=\"number\">1</span>,dep+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushup</span>(now);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addall</span><span class=\"params\">(<span class=\"type\">int</span> now)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(ch[now][<span class=\"number\">0</span>],ch[now][<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ch[now][<span class=\"number\">0</span>]) <span class=\"built_in\">addall</span>(ch[now][<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">pushup</span>(now);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!a) <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!b) <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t\tw[a]+=w[b];</span><br><span class=\"line\">\t\tsum[a]^=sum[b];</span><br><span class=\"line\">\t\tch[a][<span class=\"number\">0</span>] = <span class=\"built_in\">merge</span>(ch[a][<span class=\"number\">0</span>],ch[b][<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\tch[a][<span class=\"number\">1</span>] = <span class=\"built_in\">merge</span>(ch[a][<span class=\"number\">1</span>],ch[b][<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t\tt.rt[u] = t.<span class=\"built_in\">merge</span>(t.rt[u],t.rt[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tt.<span class=\"built_in\">addall</span>(t.rt[u]);</span><br><span class=\"line\">\tt.<span class=\"built_in\">insert</span>(t.rt[u],val[u],<span class=\"number\">0</span>);</span><br><span class=\"line\">\tans+=t.sum[t.rt[u]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;val[i];</span><br><span class=\"line\">\t<span class=\"type\">int</span> y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(i,y);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"可持久化-Trie\"><a href=\"#可持久化-Trie\" class=\"headerlink\" title=\"可持久化 Trie\"></a>可持久化 Trie</h2><p>一般来说，一种数据结构，只要在修改的过程中，之前的结构没有变化，那么它就能可持久化，即可以以原空间规模访问任意一个历史版本。</p>\n<p>于是，有了可持久化 Trie。</p>\n<p>我们要实现的功能如下：能够从一个节点开始，访问到插入第 $i$ 个串前的 Trie 树。由于之前插入的子串是不会动的，我们可以利用之前的信息来完成可持久化。</p>\n<p><img src=\"https://s2.loli.net/2022/07/24/xe2h1yksIvaLcSN.png\" alt=\"Trie_2\"></p>\n<p>以插入串 $cab$ 为例（图 $3$）。</p>\n<p>最开始 $p$ 处于 $1$，$q$ 处于 $8$，我们先把 $1-&gt;2$ 的边连上，因为 $r\\neq s[1]$，所以连了不会影响之后的插入。但是，我们不能把 $9$ 那个点也一起连了，因为这样的话，之后的插入就要在那个点的子树中进行了，破坏了历史版本的信息，所以我们另开一个点 $3$。</p>\n<p>之后，像一般 Trie 的插入一样，$p$ 走到 $3$，$q$ 也走到 $9$，发现 $a = s[2]$，所以不能连到 $10$，而是另开一个点 $5$。</p>\n<p>$p$ 走到 $5$，$q$ 走到 $10$，发现 $t\\neq s[3]$，所以可以连到 $11$ 上。由于 $q$ 没有 $b$ 这个子节点，所以直接新建。</p>\n<p>最后 $p$ 走到 $7$，插入完成。</p>\n<p>插入的过程可以概括为：维护这一个历史版本和上一个历史版本走到的位置，除了插入串的节点要新建之外，剩下的都指向原来的版本，直到串插入完毕。</p>\n<h2 id=\"例题5\"><a href=\"#例题5\" class=\"headerlink\" title=\"例题5\"></a>例题5</h2><p><a href=\"https://www.luogu.com.cn/problem/P4735\">P4735 最大异或和</a></p>\n<p>给你一个序列，有两个操作：</p>\n<ol>\n<li>加入一个数。</li>\n<li>询问左端点在 $[l,r]$ 之间，右端点为序列终点的数异或起来，再异或一个 $x$ 的最大值。</li>\n</ol>\n<p>假设没有 $l,r$ 的限制，可以维护一个异或前缀和 $s$，之后就是求 $s[n]\\oplus s[i-1]\\oplus x$ 的最大值。把 $s[n]\\oplus x$ 看作一个整体，就是在 $n$ 个数里面找两个数异或的最大值，这不就是例题2吗？</p>\n<p>现在，我们加入一个限制 $r$，于是只能在 $1$~$r-1$ 中选一个 $s[i]$，发现这不就是只插入 $1$~$r-1$ 的 Trie 吗？查询 $r-1$ 的历史版本就能解决。</p>\n<p>最后，加入一个限制 $l$，于是只能在 $l-1$~$r-1$ 中选一个 $s[i]$，我们需要对每个节点打上一个标记，代表它的子树中出现时间最晚的数的出现时间，在贪心的基础上只递归出现时间 $\\geq l-1$ 的就行了。</p>\n<h3 id=\"Code：-5\"><a href=\"#Code：-5\" class=\"headerlink\" title=\"Code：\"></a>Code：</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">6e5</span>+<span class=\"number\">10</span>,H = <span class=\"number\">24</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,s[N],tot;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Trie</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tr[N*<span class=\"number\">22</span>][<span class=\"number\">2</span>],tot,rt[N],lat[N*<span class=\"number\">24</span>];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">int</span> now,<span class=\"type\">int</span> las,<span class=\"type\">int</span> i,<span class=\"type\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dep&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tlat[now] = i;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = (s[i]&gt;&gt;dep)&amp;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (las) tr[now][c^<span class=\"number\">1</span>] = tr[las][c^<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\ttr[now][c] = ++tot;</span><br><span class=\"line\">\t\t<span class=\"built_in\">insert</span>(tr[now][c],tr[las][c],i,dep<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\tlat[now] = <span class=\"built_in\">max</span>(lat[tr[now][<span class=\"number\">0</span>]],lat[tr[now][<span class=\"number\">1</span>]]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> now,<span class=\"type\">int</span> lim,<span class=\"type\">int</span> x,<span class=\"type\">int</span> dep)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dep&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> s[lat[now]]^x;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> c = (x&gt;&gt;dep)&amp;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (lat[tr[now][c^<span class=\"number\">1</span>]]&gt;=lim) <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(tr[now][c^<span class=\"number\">1</span>],lim,x,dep<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(tr[now][c],lim,x,dep<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\tt.lat[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\tt.rt[tot] = ++t.tot;</span><br><span class=\"line\">\tt.<span class=\"built_in\">insert</span>(t.rt[tot],<span class=\"number\">0</span>,<span class=\"number\">0</span>,H);</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\ttot++;</span><br><span class=\"line\">\t\ts[tot] = s[tot<span class=\"number\">-1</span>]^x;</span><br><span class=\"line\">\t\tt.rt[i] = ++t.tot;</span><br><span class=\"line\">\t\tt.<span class=\"built_in\">insert</span>(t.rt[i],t.rt[i<span class=\"number\">-1</span>],tot,H);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">char</span> op;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"string\">&#x27;A&#x27;</span>)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\t\ttot++;</span><br><span class=\"line\">\t\t\ts[tot] = s[tot<span class=\"number\">-1</span>]^x;</span><br><span class=\"line\">\t\t\tt.rt[tot] = ++t.tot;</span><br><span class=\"line\">\t\t\tt.<span class=\"built_in\">insert</span>(t.rt[tot],t.rt[tot<span class=\"number\">-1</span>],tot,H);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;l&gt;&gt;r&gt;&gt;x;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;t.<span class=\"built_in\">query</span>(t.rt[r<span class=\"number\">-1</span>],l<span class=\"number\">-1</span>,s[tot]^x,H)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","字符串","Trie"]},{"title":"点分治初步","url":"/2023/02/07/%E7%82%B9%E5%88%86%E6%B2%BB%E5%88%9D%E6%AD%A5/","content":"<h1 id=\"点分治初步\"><a href=\"#点分治初步\" class=\"headerlink\" title=\"点分治初步\"></a>点分治初步</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>大概一年半之前学过，然而彻底忘了，现在重新学一遍。</p>\n<h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>在处理路径相关的问题时，我们可以对所有路径分类，以达到简化计算的目的。</p>\n<p>假设现在树的根为 $rt$，那么可以分成经过 $rt$ 的和不经过的。</p>\n<p>不经过的显然直接递归到子树中就行，我们主要看经过的。</p>\n<span id=\"more\"></span>\n<p>经过 $rt$ 的路径又可以分成两类：以 $rt$ 为端点的，和 $rt$ 在两个端点之间的。</p>\n<p>而显然，后者可以转化为两个以 $rt$ 为端点的路径合并起来。</p>\n<p>所以我们遍历整棵树，就可以知道到 $rt$ 的所有路径啦。</p>\n<p>我们还要对不经过 $rt$ 的路径递归处理，显然，这是一个子问题，可以用上面的方法一模一样的搞。</p>\n<p>但是，递归的层数对时间复杂度有很大的影响，因为我们每次实际上都要遍历整棵子树。</p>\n<p>所以，我们希望这个层数越少越好。</p>\n<p>点分治通过每次寻找子树的重心解决了这个问题。</p>\n<p>重心，就是所有儿子的子树大小中最大的一个最小，如果是初次接触也没关系，这实际上是一个非常简单的树形 DP。</p>\n<p>树最多只有两个重心。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">gtr</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//找树的重心，简单的树形dp </span></span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tsz[u] = <span class=\"number\">1</span>,Max[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">gtr</span>(v,u);</span><br><span class=\"line\">\t\tsz[u]+=sz[v];</span><br><span class=\"line\">\t\tMax[u] = <span class=\"built_in\">max</span>(Max[u],sz[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tMax[u] = <span class=\"built_in\">max</span>(Max[u],sum-sz[u]); <span class=\"comment\">//sum代表子树的大小</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Max[u]&lt;Max[rt]) rt = u;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><del>可以证明，</del>只要每次都遍历子树的重心，总递归层数是 $\\log n$ 级别的。</p>\n<p>于是算法的时间复杂度大概是 $O(n\\log n)$。</p>\n<p><strong>请注意，这个时间复杂度并没有计入我们为了回答询问而对路径操作的时间，实际的时间复杂度根据要求的不同而变化。</strong></p>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><h3 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h3><p><a href=\"https://www.luogu.com.cn/problem/P3806\">P3806 【模板】点分治1</a></p>\n<h4 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>求距离为 $k$ 的点对，实际上就是求长度为 $k$ 的路径。</p>\n<p>我们可以用 $dis$ 数组记录所有点到 $rt$ 的距离，于是变成了树上背包问题。简单来说，枚举当前子树中的所有可能长度，看之前的子树是否有能和它一起达到 $k$ 的长度，用一个 $bool$ 数组记录是否存在即可，不就是背包吗。</p>\n<p>需要注意，这里的 $bool$ 数组是不好直接 memset 清空的，需要搞一个删除队列，记录一下要删的元素。</p>\n<h4 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e4</span>+<span class=\"number\">10</span>,M = <span class=\"number\">1e7</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,head[N],tot,qry[N],sum,rt,sz[N],Max[N],dis[N],dd[N],cnt;</span><br><span class=\"line\"><span class=\"type\">bool</span> ok[M],ans[N],vis[N];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; del;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">gtr</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tsz[u] = <span class=\"number\">1</span>,Max[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">gtr</span>(v,u);</span><br><span class=\"line\">\t\tsz[u]+=sz[v];</span><br><span class=\"line\">\t\tMax[u] = <span class=\"built_in\">max</span>(Max[u],sz[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tMax[u] = <span class=\"built_in\">max</span>(Max[u],sum-sz[u]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Max[u]&lt;Max[rt]) rt = u;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getdis</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dis[u]&gt;<span class=\"number\">1e7</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\tdd[++cnt] = dis[u];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tdis[v] = dis[u]+edge[i].w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">getdis</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tvis[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tdis[v] = edge[i].w;</span><br><span class=\"line\">\t\tcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">getdis</span>(v,u);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">1</span>;k&lt;=m;k++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (qry[k]&gt;=dd[j])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (ok[qry[k]-dd[j]]) ans[k] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class=\"line\">\t\t\tdel.<span class=\"built_in\">push</span>(dd[j]);</span><br><span class=\"line\">\t\t\tok[dd[j]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!del.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = del.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\t\tdel.<span class=\"built_in\">pop</span>(),ok[x] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tsum = sz[v],rt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">gtr</span>(v,u);</span><br><span class=\"line\">\t\t<span class=\"built_in\">gtr</span>(rt,u);</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(rt,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,z);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,z);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;qry[i];</span><br><span class=\"line\">\tsum = n;</span><br><span class=\"line\">\tMax[rt] = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">gtr</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">gtr</span>(rt,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tok[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(rt,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cout&lt;&lt;(ans[i]?<span class=\"string\">&quot;AYE&quot;</span>:<span class=\"string\">&quot;NAY&quot;</span>)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h3><p><a href=\"https://www.luogu.com.cn/problem/P2664\">P2664 树上游戏</a></p>\n<h4 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h4><p>不好直接计算点对点的贡献，转化为计算颜色对点的贡献。</p>\n<ol>\n<li><p>算对根的贡献。</p>\n<p>显然，根的颜色在所有根的子树中的路径都有贡献，加上 $size[n]$。</p>\n<p>再算子树中其他颜色对根的贡献。</p>\n<p>找到每一个颜色第一次出现的点 $u$，加入贡献 $size[u]$。</p>\n</li>\n<li><p>算对其他点的贡献。</p>\n<p>假设我们要算端点为 $x,y$ 的路径对 $x$ 答案的贡献。</p>\n<p>拆成 $x\\rightarrow root$ 和 $root\\rightarrow y$。</p>\n<p>所有在 $x\\rightarrow root$ 上出现过的颜色，都会产生其他子树大小之和的贡献。</p>\n<p>所有没有在 $x\\rightarrow root$ 上出现过的颜色，都会产生其他子树中第一次出现的子树大小之和的贡献。</p>\n</li>\n</ol>\n<p>综上，我们要维护的信息有：</p>\n<p>每个点的 $size$。</p>\n<p>每个颜色的 $size$ 之和。</p>\n<p>码量略微有点大。</p>\n<h4 id=\"Code-1\"><a href=\"#Code-1\" class=\"headerlink\" title=\"Code\"></a>Code</h4><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,c[N],head[N],tot,sz[N],Max[N],rt,vis[N],sum,cnt[N],s[N],tmpsz,coun;</span><br><span class=\"line\">ll ans[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getrt</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tsz[u] = <span class=\"number\">1</span>,Max[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">getrt</span>(v,u);</span><br><span class=\"line\">\t\tsz[u]+=sz[v];</span><br><span class=\"line\">\t\tMax[u] = <span class=\"built_in\">max</span>(Max[u],sz[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tMax[u] = <span class=\"built_in\">max</span>(Max[u],sum-sz[u]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Max[u]&lt;Max[rt]) rt = u;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get1</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tcnt[c[u]]++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt[c[u]] == <span class=\"number\">1</span>) ans[rt]+=sz[u],s[c[u]]+=sz[u],coun+=sz[u]; <span class=\"comment\">//根的贡献2</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">get1</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcnt[c[u]]--;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">del</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tcnt[c[u]]++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt[c[u]] == <span class=\"number\">1</span>) s[c[u]]-=sz[u],coun-=sz[u];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">del</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcnt[c[u]]--;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add1</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tcnt[c[u]]++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt[c[u]] == <span class=\"number\">1</span>) s[c[u]]+=sz[u],coun+=sz[u];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add1</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcnt[c[u]]--;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get2</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa,<span class=\"type\">int</span> num)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tcnt[c[u]]++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt[c[u]] == <span class=\"number\">1</span>) num++,coun-=s[c[u]]; <span class=\"comment\">//总共出现过多少种不同的颜色</span></span><br><span class=\"line\">\tans[u]+=<span class=\"number\">1ll</span>*num*tmpsz; <span class=\"comment\">//子孙节点的贡献1 </span></span><br><span class=\"line\">\tans[u]+=coun; <span class=\"comment\">//子孙节点的贡献2</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">get2</span>(v,u,num);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcnt[c[u]]--;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!cnt[c[u]]) coun+=s[c[u]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tvis[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tans[u]+=sz[u]; <span class=\"comment\">//根的贡献1</span></span><br><span class=\"line\">\tcnt[c[u]]++;</span><br><span class=\"line\">\tcoun = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">get1</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">del</span>(v,u);</span><br><span class=\"line\">\t\ttmpsz = sz[u]-sz[v];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> tmp = coun;</span><br><span class=\"line\">\t\t<span class=\"built_in\">get2</span>(v,u,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\tcoun = tmp;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add1</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">del</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcnt[c[u]]--;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\trt = <span class=\"number\">0</span>,sum = sz[v];</span><br><span class=\"line\">\t\t<span class=\"built_in\">getrt</span>(v,u);</span><br><span class=\"line\">\t\t<span class=\"built_in\">getrt</span>(rt,u);</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(rt,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;c[i];</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y),<span class=\"built_in\">add</span>(y,x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tMax[<span class=\"number\">0</span>] = <span class=\"number\">0x3f3f3f3f</span>,sum = n;</span><br><span class=\"line\">\t<span class=\"built_in\">getrt</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">getrt</span>(rt,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">dfs</span>(rt,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"点分树\"><a href=\"#点分树\" class=\"headerlink\" title=\"点分树\"></a>点分树</h2><p>有时会存在多组询问，甚至存在修改操作，这时候点分治的时间复杂度就不足以应对了。</p>\n<p>但是，如果树的形态没有改变，那么点分治中划分重心递归的过程就都是相同的，考虑建出一棵虚树，存储这个递归的过程。</p>\n<p>需要注意的是，这个虚树会丢失很多信息，只能维护不依赖形态的操作。</p>\n<p>由于点分治最多递归 $\\log n$ 层，所以这个树的高度也是 $\\log n$ 级别的。</p>\n<p><a href=\"https://www.luogu.com.cn/problem/P6329\">P6329 【模板】点分树 | 震波</a></p>\n<p>操作 $0$：求所有距离某点不超过 $k$ 的点权和。</p>\n<p>操作 $1$：修改点权。</p>\n<p>因为树的形态没有变化，我们不妨先把虚树建出来。</p>\n<p>现在，先想一个简单的问题：如何求出虚树上两个点 $x,y$ 在原树上的距离？</p>\n<p>我们找到 $x,y$ 在虚树上的 LCA $z$ 点，之后求出原树上 $x\\rightarrow z$，$y\\rightarrow z$ 的距离即可。</p>\n<p>这样做有什么好处呢？</p>\n<p>因为 $z$ 只有 $\\log n$ 个，所以我们只需要固定 $x,z$，求满足条件的 $y$ 即可。</p>\n<p>$dis(y,z) = k-dis(x,z)$</p>\n<p>于是，我们对每一个点维护一棵线段树，存储它的子树中所有点到它的距离，这样就变成了一个区间求和问题。</p>\n<p>但是，注意到 $y$ 不能在 $x$ 的子树中，所以要把 $x$ 子树中到 $z$ 的距离 $\\leq$ 它的删掉，这就需要再维护一个线段树，存储子树中的点，到子树的根的父亲的距离。</p>\n<p>这个距离显然可以 LCA $O(\\log n)$ 求出。</p>\n<p>修改就是对点到虚树的根上的所有线段树单点修改。</p>\n<p>于是，我们花 $O(n\\log^2 n)$ 的时间建线段树和虚树，每次询问花 $O(\\log^2n)$，修改花 $O(\\log^2n)$。总时间复杂度为 $O(n\\log^2n)$。</p>\n<p>至于空间复杂度，由于每个点内部至多需要插入的点数为其子树大小，所以总共最多插入 $n\\log n$ 个点，用树状数组就是 $O(n\\log n)$。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,val[N],head[N],tot,sz[N],Max[N],rt,vis[N],sum,f[N],son[N],faa[N],dep[N],top[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">tre</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,v;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">SegT</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> rt[N],tot;</span><br><span class=\"line\">\ttre tr[N*<span class=\"number\">35</span>];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> pos,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!node) node = ++tot;</span><br><span class=\"line\">\t\ttr[node].v+=v;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (mid&gt;=pos) tr[node].l = <span class=\"built_in\">update</span>(tr[node].l,l,mid,pos,v);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> tr[node].r = <span class=\"built_in\">update</span>(tr[node].r,mid+<span class=\"number\">1</span>,r,pos,v);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> node;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> beg,<span class=\"type\">int</span> en)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!node) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l&gt;en || r&lt;beg) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l&gt;=beg &amp;&amp; r&lt;=en) <span class=\"keyword\">return</span> tr[node].v;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">query</span>(tr[node].l,l,mid,beg,en)+<span class=\"built_in\">query</span>(tr[node].r,mid+<span class=\"number\">1</span>,r,beg,en);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; t1,t2;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getrt</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tsz[u] = <span class=\"number\">1</span>,Max[u] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">getrt</span>(v,u);</span><br><span class=\"line\">\t\tsz[u]+=sz[v];</span><br><span class=\"line\">\t\tMax[u] = <span class=\"built_in\">max</span>(Max[u],sz[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tMax[u] = <span class=\"built_in\">max</span>(Max[u],sum-sz[u]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Max[u]&lt;Max[rt]) rt = u;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs1</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tvis[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa || vis[v]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\trt = <span class=\"number\">0</span>,sum = sz[v];</span><br><span class=\"line\">\t\t<span class=\"built_in\">getrt</span>(v,u);</span><br><span class=\"line\">\t\t<span class=\"built_in\">getrt</span>(rt,u);</span><br><span class=\"line\">\t\tf[rt] = u; </span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs1</span>(rt,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tMax[rt] = <span class=\"number\">0x3f3f3f3f</span>,sum = n;</span><br><span class=\"line\">\t<span class=\"built_in\">getrt</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">getrt</span>(rt,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">dfs1</span>(rt,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs2</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tsz[u] = <span class=\"number\">1</span>,faa[u] = fa,dep[u] = dep[fa]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs2</span>(v,u);</span><br><span class=\"line\">\t\tsz[u]+=sz[v];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (sz[v]&gt;sz[son[u]]) son[u] = v;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs3</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\ttop[u] = fa;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (son[u]) <span class=\"built_in\">dfs3</span>(son[u],fa);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == faa[u] || v == son[u]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs3</span>(v,v);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">dfs2</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">dfs3</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (top[x]!=top[y])&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dep[top[x]]&gt;dep[top[y]]) <span class=\"built_in\">swap</span>(x,y);</span><br><span class=\"line\">\t\ty = faa[top[y]];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dep[x]&lt;dep[y]) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dis</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> z = <span class=\"built_in\">lca</span>(x,y);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dep[x]+dep[y]<span class=\"number\">-2</span>*dep[z];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">modify</span><span class=\"params\">(<span class=\"type\">int</span> i,<span class=\"type\">int</span> val)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = i;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (now)&#123;</span><br><span class=\"line\">\t\tt1.rt[now] = t1.<span class=\"built_in\">update</span>(t1.rt[now],<span class=\"number\">0</span>,n,<span class=\"built_in\">dis</span>(i,now),val);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (f[now]) t2.rt[now] = t2.<span class=\"built_in\">update</span>(t2.rt[now],<span class=\"number\">0</span>,n,<span class=\"built_in\">dis</span>(i,f[now]),val);</span><br><span class=\"line\">\t\tnow = f[now];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"built_in\">modify</span>(i,val[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">calc1</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> z = x,ans = <span class=\"number\">0</span>,prev = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (z)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> tmp = k-<span class=\"built_in\">dis</span>(x,z);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tprev = z,z = f[z];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans+=t1.<span class=\"built_in\">query</span>(t1.rt[z],<span class=\"number\">0</span>,n,<span class=\"number\">0</span>,tmp);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (prev) ans-=t2.<span class=\"built_in\">query</span>(t2.rt[prev],<span class=\"number\">0</span>,n,<span class=\"number\">0</span>,tmp);</span><br><span class=\"line\">\t\tprev = z,z = f[z];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">calc2</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">modify</span>(x,-val[x]),<span class=\"built_in\">modify</span>(x,y);</span><br><span class=\"line\">\tval[x] = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;val[i];</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y),<span class=\"built_in\">add</span>(y,x);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">build1</span>(); <span class=\"comment\">//建虚树</span></span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>(); <span class=\"comment\">//树剖</span></span><br><span class=\"line\">\t<span class=\"built_in\">build2</span>(); <span class=\"comment\">//建线段树</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> op,las = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">\t\tx^=las,y^=las;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!op) cout&lt;&lt;(las = <span class=\"built_in\">calc1</span>(x,y))&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">calc2</span>(x,y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","分治","点分治","点分树"]},{"title":"浅谈随机数据生成与对拍","url":"/2021/10/12/%E6%B5%85%E8%B0%88%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E4%B8%8E%E5%AF%B9%E6%8B%8D/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>最近写了一个对拍器，自认为对于对拍有一定见解，但今天$cjf$说如果用$srand(time(0))$，在卑微的Windows系统下一秒钟实际上只对了一组数据，因为$time(0)$在一秒钟内不会变化，写了个程序<br>试了一下，确实如此<br><span id=\"more\"></span><br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;test.in&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,stdout);</span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">0</span>,las = <span class=\"number\">0</span>,cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (a==las)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">\t\ta = <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!las) las = a;</span><br><span class=\"line\">\t\tcnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>cnt统计的是和最先一次rand出来的数相同的数的个数</p>\n<p>cnt大概有1e7-2e7，可见数据生成器生成数据的不随机性（除非你的程序用时太久，不能在1s内跑完生成的数据）</p>\n<p><strong>显然，这会对对拍的效率产生严重影响，那么应该如何生成完全随机的数据呢？</strong>  </p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>先用$srand$生成10个左右的随机数，然后就可以得到10个随机种子，再用它们生成随机数，同时运行程序，就可以得到真正的随机数了。</p>\n<p>但这样有一个问题：生成的随机数都是5位数，所以在对拍几万个数据后，种子就是重复的了，那样就没有意义了，所以考虑生成更大的种子。</p>\n<p>在这里给出一种方法：用两个$for$把种子乘起来当作种子，这样种子大概率就不同了。</p>\n<p>具体传种子的方法读者可以自己实现，在这里给出一种方式：$freopen$<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> sed;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;seed.in&quot;</span>,<span class=\"string\">&quot;r&quot;</span>,stdin);</span><br><span class=\"line\">    cin&gt;&gt;sed;</span><br><span class=\"line\">    <span class=\"built_in\">srand</span>((<span class=\"type\">unsigned</span>)sed);</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    your code here</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>具体生成随机数的方法：<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> rs[<span class=\"number\">15</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">srand</span>(<span class=\"built_in\">time</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">             rs[i] = <span class=\"built_in\">rand</span>();</span><br><span class=\"line\">       \t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=i+<span class=\"number\">1</span>;j&lt;=<span class=\"number\">10</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"function\">ofstream <span class=\"title\">output</span><span class=\"params\">(<span class=\"string\">&quot;seed.in&quot;</span>)</span></span>;</span><br><span class=\"line\">\t\t\t\toutput&lt;&lt;rs[i]*rs[j]&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">system</span>(<span class=\"string\">&quot;1.exe&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>其实一般只随机10个数也可以，重复周期较长</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p>貌似不生成数据，单独使用$fc$比较文件很慢？（请读者自行测试100000行以上数据，本机测得$fc$比字符比较慢很多）<br><img src=\"https://z3.ax1x.com/2021/10/12/5nzKv8.md.png\" alt=\"实测结果\"></p>\n","tags":["Knowledge","Misc"]},{"title":"物质的分类","url":"/2022/02/11/%E7%89%A9%E8%B4%A8%E7%9A%84%E5%88%86%E7%B1%BB/","content":"<h2 id=\"物质的分类（-分散系-氧化物分类）\"><a href=\"#物质的分类（-分散系-氧化物分类）\" class=\"headerlink\" title=\"物质的分类（ 分散系 氧化物分类）\"></a>物质的分类（ 分散系 氧化物分类）</h2><span id=\"more\"></span>\n<h3 id=\"制备-Fe-OH-3-胶体的实验\"><a href=\"#制备-Fe-OH-3-胶体的实验\" class=\"headerlink\" title=\"制备$Fe(OH)_3$胶体的实验\"></a>制备$Fe(OH)_3$胶体的实验</h3><p>  $FeCl_3+3H_2O \\frac{\\Delta}{=} Fe(OH)_3（胶体）+3HCl$<br>  （原谅这丑陋的方程式）</p>\n<h5 id=\"要点：\"><a href=\"#要点：\" class=\"headerlink\" title=\"要点：\"></a>要点：</h5><p>  <strong>反应条件</strong>：加热<br>  要在$Fe(OH)_3$后面<strong>加上胶体 </strong><br>  不要和$NaOH$反应去了，这样会直接生成沉淀<br>  要用<strong>煮沸</strong>的<strong>蒸馏水</strong>，而且是将$FeCl_3$加入蒸馏水中，颜色变成<strong>红褐色</strong>时<strong>立即</strong>停止加热<br>  不能用<strong>玻璃棒搅拌</strong>，要<strong>振荡烧杯</strong><br>  淀粉溶液是<strong>胶体</strong>！  </p>\n<h5 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h5><p>  虽然反应是这样进行的，但是如果再加入适量$HCl$，会发生以下反应：$Fe(OH)_3+3HCl = FeCl_3+3H_2O$<br>  我的理解是因为胶体微粒带电，似乎从某种程度上阻止了反应的进行，但是加入$HCl$到一定程度后，两边的电荷逐渐失衡，反应才开始进行，为了电荷的再次平衡   </p>\n<h4 id=\"胶体的性质\"><a href=\"#胶体的性质\" class=\"headerlink\" title=\"胶体的性质\"></a>胶体的性质</h4><ul>\n<li>粒子大小介于$1nm$~$100nm$之间，不能透过半透膜  </li>\n<li>光学性质：丁达尔效应。实际上就是拿个激光笔照射之后有通路，就一定是胶体  </li>\n<li>运动学性质：布朗运动。解释是做无规则运动，好像也是因为这个性质具有介稳性  </li>\n<li>电学性质：电泳现象。通俗点说就是往哪边跑，极性就与哪边相反，异性相吸嘛  <ul>\n<li>应用：工厂静电除尘（尘是胶体）</li>\n<li>注意：胶体是电中性的，只有胶粒才带电</li>\n</ul>\n</li>\n<li>热力学性质：胶体的聚沉。貌似并不知道原理是什么<ul>\n<li>方法1：加入[[电解质]]（之后会讲）</li>\n<li>方法2：加入与胶粒带相反电荷的胶体（见$\\downarrow$的扩展）</li>\n<li>方法3：加热（实验中可能会考加热过度，现象是有红褐色固体生成）</li>\n<li>应用：三角洲形成，明矾净水，盐卤制豆腐</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"扩展：-1\"><a href=\"#扩展：-1\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h5><ol>\n<li>胶体的正负电荷<br>正电荷：金属氢氧化物（$Fe(OH)_3$），金属氧化物（$Fe_2O_3$）<br>负电荷：非金属氧化物（$As_2O_3$），金属硫化物（好像没看见？），但看见了金属（$Au$）  </li>\n<li>不同物态的胶体<br>气溶胶：烟、雾<br>液溶胶：$Fe(OH)_3$胶体、豆浆、淀粉<strong>溶液</strong><br>固溶胶：有色玻璃，烟水晶（?）</li>\n</ol>\n<h4 id=\"氧化物的分类\"><a href=\"#氧化物的分类\" class=\"headerlink\" title=\"氧化物的分类\"></a>氧化物的分类</h4><p>碱性氧化物：能和酸反应生成盐和水的氧化物，如$CuO$<br>酸性氧化物：能和碱反应生成盐和水的氧化物，如$CO_2, SO_3$<br>两性氧化物：酸碱特性皆具备，称为两性氧化物，如$Al_2O_3$<br>不成盐氧化物：两个特性都不具备的氧化物，如$NO,CO$<br><strong>特殊氧化物</strong>：好像只提到了$Fe_3O_4$和$Na_2O_2$这两个  </p>\n<h5 id=\"大体观点：\"><a href=\"#大体观点：\" class=\"headerlink\" title=\"大体观点：\"></a>大体观点：</h5><p><strong>碱性氧化物</strong> <strong>一定</strong>是 <strong>金属氧化物</strong>    <strong>没有反例！ </strong><br><strong>酸性氧化物</strong> 大部分是 <strong>非金属氧化物</strong>    反例：$Mn_2O_7$<br><strong>金属氧化物</strong> 不一定是 <strong>碱性氧化物</strong>    反例：$Mn_2O_7$（这个好像真的很好用），$Al_2O_3$（两性氧化物）<br><strong>非金属氧化物</strong> 不一定是 <strong>酸性氧化物</strong>    反例：$CO$（不成盐氧化物）<br><strong>酸性氧化物</strong> 大多可以和水反应生成相应的酸    反例：$SiO_2$<br><strong>碱性氧化物</strong> 大多不能和水反应生成相应的碱    反例：$Na_2O$，$CaO$  </p>\n<h4 id=\"补充错题：\"><a href=\"#补充错题：\" class=\"headerlink\" title=\"补充错题：\"></a>补充错题：</h4>","tags":["Knowledge","WHK"]},{"title":"状压DP入门","url":"/2023/02/18/%E7%8A%B6%E5%8E%8BDP%E5%85%A5%E9%97%A8/","content":"<h1 id=\"状压-DP入门\"><a href=\"#状压-DP入门\" class=\"headerlink\" title=\"状压 DP入门\"></a>状压 DP入门</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>如果有一个数列，每个位置上只能放 $0,1$，且顺序不同对应的数列不同，这时候就需要精确的表示每个位置上究竟放了什么。但是，当 $n$ 比较小时（通常在 $20$ 以内），我们可以把每个位置都看成二进制位，于是一个数列就可以被一个二进制数唯一表示，如果数列的长度在 $32$ 以内，就可以直接用 int 存储。大家都知道位运算是很快的，在接近 $O(1)$ 的时间内就可以解决原来 $O(n)$ 的问题，对时间复杂度优化巨大，这就是状态压缩。</p>\n<p>需要注意的是，状态压缩由于需要表示所有 $2^n$ 种可能性，在开数组时所需空间也从 $O(n)$ 变成了 $O(2^n)$，不要开大了。</p>\n<span id=\"more\"></span>\n<h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><p>模板题：<a href=\"https://www.luogu.com.cn/problem/P2704\">P2704 [NOI2001] 炮兵阵地</a></p>\n<p>因为每一行上的位置不超过 $10$ 个，考虑把一行压成二进制数。</p>\n<p>最朴素的想法是，既然炮兵在当前行和前两行都有冲突，我们就需要枚举前两行填了什么，才能知道是否发生了冲突。</p>\n<p>于是设 $f[i][j][k]$ 表示填了前 $i$ 行，第 $i$ 行的状态为 $j$，第 $i-1$ 行的状态为 $k$ 的最大数量。</p>\n<p>转移时枚举上一行的状态和上上一行的状态，判断是否合法，转移。</p>\n<p>假设当前行的状态为 $i$，上一行的状态为 $j$，上上一行的状态为 $k$。</p>\n<ol>\n<li><p>当前行内没有冲突。</p>\n<p>就是说一个数向两边延伸的两个位置都没有冲突。</p>\n<p>在第 $i$ 位上的数和第 $i-2$ 位上的数冲突，等价于 $i-2$ 位和 $i$ 位冲突，也就是说，我们只用判断第 $i$ 位的数和第 $i+1,i+2$ 位的数有没有冲突就行了。</p>\n<p>我们知道，一个二进制数右移一位，代表它上面所有的 $1$ 都向右移了一位，这时我们再将它和原来的数与一下，就知道能判断第 $i$ 位和第 $i+1$ 位上的数有没有冲突了。</p>\n<p>建议还是自己画图理解一下，应该很好懂。</p>\n</li>\n<li><p>和上面两行没有冲突。</p>\n<p>只有位置相同的位上，两行都是 $1$ 才有冲突，所以直接与，看结果是不是 $0$ 即可。</p>\n</li>\n</ol>\n<p>这时候就可以写代码了吗？No！</p>\n<p>这样子做，时间复杂度是很可怕的 $O(N\\cdot 2^{2M})$，虽然以现在计算机的性能，可以在 $0.25s$ 左右通过，但是这是 $2001$ 年的题啊，要知道，当时还是奔腾处理器的时代，肯定是过不了的！</p>\n<p>那么，能怎么优化呢？</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;n;i++)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> L=<span class=\"number\">0</span>;L&lt;(<span class=\"number\">1</span>&lt;&lt;m);L++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L&amp;a[i<span class=\"number\">-1</span>] || (L&amp;(L&lt;&lt;<span class=\"number\">1</span>)) || (L&amp;(L&lt;&lt;<span class=\"number\">2</span>))) <span class=\"keyword\">continue</span>;\t<span class=\"comment\">//特判</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> S=<span class=\"number\">0</span>;S&lt;(<span class=\"number\">1</span>&lt;&lt;m);S++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(S&amp;a[i] || L&amp;S || (S&amp;(S&lt;&lt;<span class=\"number\">1</span>)) || (S&amp;(S&lt;&lt;<span class=\"number\">2</span>))) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> FL=<span class=\"number\">0</span>;FL&lt;(<span class=\"number\">1</span>&lt;&lt;m);FL++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(FL&amp;L || FL&amp;S || FL&amp;a[i<span class=\"number\">-2</span>] || (FL&amp;(FL&lt;&lt;<span class=\"number\">1</span>)) || (FL&amp;(FL&lt;&lt;<span class=\"number\">2</span>)))\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                dp[L][S][i%<span class=\"number\">3</span>]=<span class=\"built_in\">max</span>(dp[L][S][i%<span class=\"number\">3</span>],dp[FL][L][(i<span class=\"number\">-1</span>)%<span class=\"number\">3</span>]+Sum[S]);\t\t<span class=\"comment\">//滚动数组的实现方法</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>（随便拉了一个题解区的代码，懒的写qwq）</p>\n<p>注意到每次枚举的时候，里面的内容和 $i$ 没有任何关系，我们的 $i$ 就是一个凑数的，在判断合法的时候，$i$ 可是完全没有出现！</p>\n<p>其实可以做一个预处理，先找出所有合法的数对，用一个 map 之类的东西存起来，之后直接枚举这些数对就行了。</p>\n<p>由于合法的很少，所以时间复杂度变为 $O(N+2^{2M})$。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e2</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,f[N][N][N],mp[N],val[N],cnt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">calc</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = val[pos],cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((<span class=\"number\">1</span>&lt;&lt;i)&amp;x) cnt++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"type\">char</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;s;</span><br><span class=\"line\">\t\t\tsum&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (s == <span class=\"string\">&#x27;P&#x27;</span>) sum++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmp[i] = sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;m);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> las = <span class=\"number\">-1</span>,flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;m;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((<span class=\"number\">1</span>&lt;&lt;j)&amp;i)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (las!=<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (j-las&lt;<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\t\tflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tlas = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (flag) val[++cnt] = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++) <span class=\"keyword\">if</span> ((mp[<span class=\"number\">1</span>]&amp;val[i]) == val[i]) f[<span class=\"number\">1</span>][i][<span class=\"number\">0</span>] = <span class=\"built_in\">calc</span>(i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (f[<span class=\"number\">1</span>][j][<span class=\"number\">0</span>] &amp;&amp; (mp[<span class=\"number\">2</span>]&amp;val[i]) == val[i] &amp;&amp; !(val[i]&amp;val[j]))&#123;</span><br><span class=\"line\">\t\t\t\tf[<span class=\"number\">2</span>][i][j] = <span class=\"built_in\">max</span>(f[<span class=\"number\">2</span>][i][j],f[<span class=\"number\">1</span>][j][<span class=\"number\">0</span>]+<span class=\"built_in\">calc</span>(i));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">3</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">1</span>;p&lt;=cnt;p++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> q=<span class=\"number\">1</span>;q&lt;=cnt;q++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (f[i<span class=\"number\">-1</span>][p][q] &amp;&amp; (mp[i]&amp;val[j]) == val[j] &amp;&amp; !(val[j]&amp;val[p]) &amp;&amp; !(val[j]&amp;val[q]))&#123;</span><br><span class=\"line\">\t\t\t\t\t\tf[i][j][p] = <span class=\"built_in\">max</span>(f[i][j][p],f[i<span class=\"number\">-1</span>][p][q]+<span class=\"built_in\">calc</span>(j));</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> Max = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=cnt;j++)&#123;</span><br><span class=\"line\">\t\t\tMax = <span class=\"built_in\">max</span>(Max,f[n][i][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;Max&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h2><p><a href=\"https://www.luogu.com.cn/problem/P5005\">P5005 中国象棋 - 摆上马</a></p>\n<p>尽管上面的代码是作为典型的反面教材，但是它本身还是有一定可取之处的（不过，大家还是不要学习它的写法，谁告诉你滚动数组要开 $3$ 个的啊！！！）。</p>\n<p>这道题看上去和例 $1$ 一模一样，但是你有没有注意到它的空间限制…</p>\n<p>只有 1MB 该怎么办？</p>\n<p>我们假设已经掌握了判断合法的方法，现在就要请出滚动数组了！</p>\n<p>不妨想一下，对于某一行，我们只需要知道前两行的信息，而 DP 数组中又保留了上上一行的信息，所以我们只需要通过上一行转移即可。</p>\n<p>那上上行和之前的数组，我们还需要吗？不需要！</p>\n<p>于是只用开两个数组，存储当前行和上一行的信息即可。</p>\n<p>判断合法其实是考位运算功底，建议先自己想一下。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123; <span class=\"comment\">//x表示当前行，y表示上一行，这里判断当前行和上一行是否冲突</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = (x&lt;&lt;<span class=\"number\">1</span>)^(x&amp;(x&lt;&lt;<span class=\"number\">1</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tmp&lt;&lt;<span class=\"number\">1</span>)&amp;y) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\ttmp = (x&gt;&gt;<span class=\"number\">1</span>)^(x&amp;(x&gt;&gt;<span class=\"number\">1</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tmp&gt;&gt;<span class=\"number\">1</span>)&amp;y) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">chk2</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> z)</span></span>&#123; <span class=\"comment\">//x表示当前行，y表示上一行，z表示上上一行，这里判断当前行和上上一行是否冲突</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = x&amp;(x^y);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tmp&lt;&lt;<span class=\"number\">1</span>)&amp;z) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tmp&gt;&gt;<span class=\"number\">1</span>)&amp;z) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完整代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">6</span>),mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,f[<span class=\"number\">2</span>][N][N],ans;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = (x&lt;&lt;<span class=\"number\">1</span>)^(x&amp;(x&lt;&lt;<span class=\"number\">1</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tmp&lt;&lt;<span class=\"number\">1</span>)&amp;y) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\ttmp = (x&gt;&gt;<span class=\"number\">1</span>)^(x&amp;(x&gt;&gt;<span class=\"number\">1</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tmp&gt;&gt;<span class=\"number\">1</span>)&amp;y) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">chk2</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> z)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = x&amp;(x^y);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tmp&lt;&lt;<span class=\"number\">1</span>)&amp;z) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((tmp&gt;&gt;<span class=\"number\">1</span>)&amp;z) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;m);j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;(<span class=\"number\">1</span>&lt;&lt;m);k++)&#123;</span><br><span class=\"line\">\t\t\t\tf[i&amp;<span class=\"number\">1</span>][j][k] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!<span class=\"built_in\">chk</span>(j,k) || !<span class=\"built_in\">chk</span>(k,j) || (i == <span class=\"number\">1</span> &amp;&amp; k)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;(<span class=\"number\">1</span>&lt;&lt;m);p++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">chk2</span>(j,k,p) &amp;&amp; <span class=\"built_in\">chk2</span>(p,k,j) &amp;&amp; <span class=\"built_in\">chk</span>(k,p) &amp;&amp; <span class=\"built_in\">chk</span>(p,k) &amp;&amp; (i&gt;<span class=\"number\">2</span> || !p))&#123;</span><br><span class=\"line\">\t\t\t\t\t\tf[i&amp;<span class=\"number\">1</span>][j][k] = (f[i&amp;<span class=\"number\">1</span>][j][k]+f[(i<span class=\"number\">-1</span>)&amp;<span class=\"number\">1</span>][k][p])%mod;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (i == n) ans = (ans+f[i&amp;<span class=\"number\">1</span>][j][k])%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例3\"><a href=\"#例3\" class=\"headerlink\" title=\"例3\"></a>例3</h2><p><a href=\"https://www.luogu.com.cn/problem/P2157\">P2157 [SDOI2009] 学校食堂</a></p>\n<p>基本上看到人数就想到状压 DP 了。</p>\n<p>设 $f[i][j][k]$ 表示前 $i-1$ 个人都吃了，第 $i$ 个人开始后面 $b_i$ 个人吃的情况为 $j$，最后一个吃的人是 $i+k$ 的最小时间。</p>\n<p>注意这里的 $k$ 可能 $&lt; 0$，所以需要把所有 $k$ 加上 $8$。</p>\n<ol>\n<li>$j\\&amp;1 = 1$，表示第 $i$ 个人已经吃了，可以直接转移到 $f[i+1][j&gt;&gt;1][k-1]$。</li>\n<li>$j\\&amp; 1 = 0$，需要我们确定谁吃，枚举还没有吃的人 $i+p$，转移到 $f[i][j\\oplus (1&lt;&lt;p)][p]$，注意这里要边枚举边确定能吃的人的边界，因为有些人前面的人忍耐度有限。</li>\n</ol>\n<p>但是，枚举顺序是什么呢？从 $0$ 开始枚举 $j$。</p>\n<p>为什么？因为我们要保证 $f[i][j][k]$ 的正确，需要让所有能对它产生贡献的 $f[i][p][k’]$ 都更新它，而这里的 $p&lt;j$，所以只要从小往大枚举即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e3</span>+<span class=\"number\">10</span>,M = (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,a[N],b[N],f[N][M][<span class=\"number\">16</span>],ans;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=<span class=\"number\">7</span>;i++) f[<span class=\"number\">1</span>][<span class=\"number\">0</span>][i+<span class=\"number\">8</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">8</span>);j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">-8</span>;k&lt;=<span class=\"number\">7</span>;k++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (f[i][j][k+<span class=\"number\">8</span>] == <span class=\"number\">0x3f3f3f3f</span> || i+k&gt;n || i+k&lt;<span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (j&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tf[i+<span class=\"number\">1</span>][j&gt;&gt;<span class=\"number\">1</span>][k+<span class=\"number\">8</span><span class=\"number\">-1</span>] = <span class=\"built_in\">min</span>(f[i+<span class=\"number\">1</span>][j&gt;&gt;<span class=\"number\">1</span>][k+<span class=\"number\">8</span><span class=\"number\">-1</span>],f[i][j][k+<span class=\"number\">8</span>]);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (i == n) ans = <span class=\"built_in\">min</span>(ans,f[i+<span class=\"number\">1</span>][j&gt;&gt;<span class=\"number\">1</span>][k+<span class=\"number\">8</span><span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"type\">int</span> r = b[i];</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;=<span class=\"number\">7</span>;p++)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (p&gt;r || i+p&gt;n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> (!((<span class=\"number\">1</span>&lt;&lt;p)&amp;j))&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tf[i][j|(<span class=\"number\">1</span>&lt;&lt;p)][p+<span class=\"number\">8</span>] = <span class=\"built_in\">min</span>(f[i][j|(<span class=\"number\">1</span>&lt;&lt;p)][p+<span class=\"number\">8</span>],f[i][j][k+<span class=\"number\">8</span>]+(a[i+p]^a[i+k]));</span><br><span class=\"line\">\t\t\t\t\t\t\tr = <span class=\"built_in\">min</span>(r,p+b[i+p]);</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tans = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">\t\tcin&gt;&gt;n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class=\"line\">\t\t<span class=\"built_in\">solve</span>();</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例4\"><a href=\"#例4\" class=\"headerlink\" title=\"例4\"></a>例4</h2><p><a href=\"https://www.luogu.com.cn/problem/P3977\">P3977 [TJOI2015]棋盘</a></p>\n<p>这个 $m$ 为什么这么小？这个 $n$ 为什么这么大？</p>\n<p>肯定暗藏玄机！</p>\n<p>一个位置能攻击的范围只有上下两行，所以只需要知道上一行填了啥就行了。</p>\n<p>预处理出所有合法的填法。</p>\n<p>之后如果直接 DP，由于 $n$ 太大，肯定会超时，要优化 DP，拿什么？</p>\n<p>这里的 DP 实际上是从上一行递推到下一行，矩阵优化递推貌似就可以做了。</p>\n<p>由于 $m$ 很小，导致矩阵的行数和列数都是 $2^m$，时间复杂度也就 $O(2^{3m})$，带个 $\\log$ 之后稳过。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> ui;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">6</span>)+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,p,k,a[<span class=\"number\">10</span>][<span class=\"number\">10</span>],tot,dx[N],dy[N];</span><br><span class=\"line\">map&lt;pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;,<span class=\"type\">int</span>&gt; pos;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">mat</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> r,c;</span><br><span class=\"line\">\tui a[N][N];</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t\tr = x,c = y;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=r;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=c;j++) a[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmat <span class=\"keyword\">operator</span> *(<span class=\"type\">const</span> mat &amp;b) <span class=\"type\">const</span>&#123;</span><br><span class=\"line\">\t\tmat c;</span><br><span class=\"line\">\t\tc.<span class=\"built_in\">init</span>(r,b.c);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=r;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;=b.c;k++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=b.c;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\tc.a[i][j]+=a[i][k]*b.a[k][j];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; tmp;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tpos.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((<span class=\"number\">1</span>&lt;&lt;i)&amp;x)&#123;</span><br><span class=\"line\">\t\t\tpos[<span class=\"built_in\">make_pair</span>(<span class=\"number\">2</span>,i+<span class=\"number\">1</span>)] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((<span class=\"number\">1</span>&lt;&lt;i)&amp;y)&#123;</span><br><span class=\"line\">\t\t\tpos[<span class=\"built_in\">make_pair</span>(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>)] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> tmp:pos)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = tmp.first.first,y = tmp.first.second;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> nx = x+dx[i],ny = y+dy[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (nx&gt;=<span class=\"number\">1</span> &amp;&amp; nx&lt;=<span class=\"number\">2</span> &amp;&amp; ny&gt;=<span class=\"number\">1</span> &amp;&amp; ny&lt;=m &amp;&amp; pos.<span class=\"built_in\">count</span>(<span class=\"built_in\">make_pair</span>(nx,ny))) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\ttmp.<span class=\"built_in\">init</span>((<span class=\"number\">1</span>&lt;&lt;m)<span class=\"number\">-1</span>,(<span class=\"number\">1</span>&lt;&lt;m)<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;m);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;m);j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">chk</span>(i,j)) tmp.a[j][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">mat <span class=\"title\">ksm</span><span class=\"params\">(mat x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tmat ret,bas = x;</span><br><span class=\"line\">\tret.<span class=\"built_in\">init</span>(x.r,x.c);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=x.r;i++) ret.a[i][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ret = ret*bas;</span><br><span class=\"line\">\t\tbas = bas*bas;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;k;</span><br><span class=\"line\">\tk++;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">3</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=p;j++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;a[i][j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[i][j] &amp;&amp; !(i == <span class=\"number\">2</span> &amp;&amp; j == k)) dx[++tot] = i<span class=\"number\">-2</span>,dy[tot] = j-k;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tmat ans;</span><br><span class=\"line\">\tans.<span class=\"built_in\">init</span>(<span class=\"number\">1</span>,(<span class=\"number\">1</span>&lt;&lt;m)<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;m);i++) ans.a[<span class=\"number\">0</span>][i] = tmp.a[<span class=\"number\">0</span>][i];</span><br><span class=\"line\">\tans = ans*<span class=\"built_in\">ksm</span>(tmp,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tui out = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;m);i++) out+=ans.a[<span class=\"number\">0</span>][i];</span><br><span class=\"line\">\tcout&lt;&lt;out&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例5\"><a href=\"#例5\" class=\"headerlink\" title=\"例5\"></a>例5</h2><p><a href=\"https://www.luogu.com.cn/problem/P3943\">P3943 星空</a></p>\n<p>思维难度陡然上升，建议自己先想想，看了题解就没啥意思了。</p>\n<p>这里的区间取反操作，涉及的数太多，对状态的改变非常大，考虑转化它。</p>\n<p>一个区间取反，实际上相当于区间 $+1$ 在模 $2$ 下的结果，可以用差分 $O(1)$ 处理，但好处不在 $O(1)$，而在改变的值只有两个！</p>\n<p>算出原数组的差分数组 $b_i = a_i\\oplus a_{i-1}$（$a_0 = a_{n+1} = 0$，把没有开的看成 $1$），每一次操作相当于选择一个起点，选择一个长度，把起点和终点的值取反。</p>\n<p>显然选的点中一定要有一个值为 $1$，否则还不如不选。而且这里的起点和终点互换不影响结果，所以相当于起点必须是 $1$。</p>\n<p>一次操作的结果是起点变成 $0$，而终点如果是 $0$，就变成 $1$，否则变成 $0$。在终点不为 $1$ 的时候也就相当于把 $1$ 移动了一个长度。</p>\n<p>可以 BFS 算出每个 $1$ 出发到其他 $1$ 的最小距离。（别扯最短路，这里的边权都是 $1$，BFS 足够了）</p>\n<p>还可以发现，初始的差分数组中，$1$ 最多有 $2k$ 个，每次操作要么减少两个 $1$，要么不变，所以 $1$ 的个数不超过 $2k = 16$ 个，直接状压，每一位代表这个 $1$ 现在还是不是 $1$。</p>\n<p>设 $f[i]$ 表示到达状态为 $i$ 需要的最小步数。</p>\n<p>每次转移时，枚举 $i$ 中还是 $1$ 的位置，任意拿出两个位置，将它们变成 $0$，枚举所有这样的数对即可获得一个 $O(nmk+k^22^{2k})$ 的算法。</p>\n<p>但是，真的需要枚举所有选出两个位置的方式吗？我们发现，只要数都两两配对，其实谁先配对谁后配对并不重要，所以只需要让第一个是 $1$ 的数和剩下所有的 $1$ 依次配对就行了。</p>\n<p>代码中注释的 sol1 和 sol2 分别对应上下两种处理方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e4</span>+<span class=\"number\">10</span>,M = <span class=\"number\">105</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,m,a[M],b[M],dis[N],cost[M][M],c[N],pre[N],pos[N],tot,tmp[N],cnt,f[(<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">21</span>)+<span class=\"number\">10</span>];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> id)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dis,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(dis));</span><br><span class=\"line\">\tq.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">\tdis[x] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> nx = x+b[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (nx&lt;=n+<span class=\"number\">1</span> &amp;&amp; dis[nx] == <span class=\"number\">0x3f3f3f3f</span>) q.<span class=\"built_in\">push</span>(nx),dis[nx] = dis[x]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tnx = x-b[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (nx&gt;=<span class=\"number\">1</span> &amp;&amp; dis[nx] == <span class=\"number\">0x3f3f3f3f</span>) q.<span class=\"built_in\">push</span>(nx),dis[nx] = dis[x]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++) cost[id][i] = dis[pos[i]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++) cin&gt;&gt;a[i],c[a[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;b[i];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n+<span class=\"number\">1</span>;i++)&#123;</span><br><span class=\"line\">\t\tpre[i] = c[i]^c[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pre[i]) pos[++tot] = i;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(cost,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(cost));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++) <span class=\"built_in\">bfs</span>(pos[i],i);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\tf[(<span class=\"number\">1</span>&lt;&lt;tot)<span class=\"number\">-1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=(<span class=\"number\">1</span>&lt;&lt;tot)<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\tcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((<span class=\"number\">1</span>&lt;&lt;j)&amp;i)&#123;</span><br><span class=\"line\">\t\t\t\ttmp[++cnt] = j;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"comment\">//\t\tfor (int j=1;j&lt;=cnt;j++)&#123; //sol1</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\tfor (int k=j+1;k&lt;=cnt;k++)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\tif (cost[tmp[j]+1][tmp[k]+1] == 0x3f3f3f3f) continue;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t\tf[i^(1&lt;&lt;tmp[j])^(1&lt;&lt;tmp[k])] = min(f[i^(1&lt;&lt;tmp[j])^(1&lt;&lt;tmp[k])],f[i]+cost[tmp[j]+1][tmp[k]+1]);</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t&#125;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">2</span>;j&lt;=cnt;j++)&#123; <span class=\"comment\">//sol2</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (cost[tmp[<span class=\"number\">1</span>]+<span class=\"number\">1</span>][tmp[j]+<span class=\"number\">1</span>] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tf[i^(<span class=\"number\">1</span>&lt;&lt;tmp[<span class=\"number\">1</span>])^(<span class=\"number\">1</span>&lt;&lt;tmp[j])] = <span class=\"built_in\">min</span>(f[i^(<span class=\"number\">1</span>&lt;&lt;tmp[<span class=\"number\">1</span>])^(<span class=\"number\">1</span>&lt;&lt;tmp[j])],f[i]+cost[tmp[<span class=\"number\">1</span>]+<span class=\"number\">1</span>][tmp[j]+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;(f[<span class=\"number\">0</span>] == <span class=\"number\">0x3f3f3f3f</span>?<span class=\"number\">-1</span>:f[<span class=\"number\">0</span>])&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例6\"><a href=\"#例6\" class=\"headerlink\" title=\"例6\"></a>例6</h2><p><a href=\"https://www.luogu.com.cn/problem/P2150\">P2150 [NOI2015] 寿司晚宴</a></p>\n<p>简化的题意就是选出两个集合，使得集合的交集为空，集合内的数都是质因数。</p>\n<p>考虑暴力，枚举每一个数是否选择，设 $f[i][j]$ 表示质因数状压后的状态是否选择，最终的方案数，每次或上当前数的质因子集合，直接转移。</p>\n<p>可以根号分治一波，发现一个数大于它开根的质因子最多只有一个，显然这种质因子只会在个别数中出现，并且一旦加入某个集合，包含这个质因子的数都不能再加入另一个集合。</p>\n<p>我们考虑把这些数合并起来，质因子较小的暴力搞，含有大于 $\\sqrt{500}$ 的质因子的放一起，用两个数组 $f1,f2$ 分别表示全都分配给 $1$ 或 $2$ 的方案数。</p>\n<p>每次转移时，这些数放一起单独转移，剩下的按照暴力转移。</p>\n<p>这种方法的巧妙之处就在于利用了含有 $\\geq \\sqrt{500}$ 的数的特殊性，从而能保证在不知道质因数包含的情况下，状态是合法的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e2</span>+<span class=\"number\">10</span>,M = (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> n,mod,vis[N],pri[N],tot,to[N];</span><br><span class=\"line\">ll f1[M+<span class=\"number\">10</span>][M],f2[M+<span class=\"number\">10</span>][M],f[M+<span class=\"number\">10</span>][M];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">aa</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,s,pri;</span><br><span class=\"line\">&#125; a[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tto[<span class=\"number\">2</span>] = <span class=\"number\">0</span>,to[<span class=\"number\">3</span>] = <span class=\"number\">1</span>,to[<span class=\"number\">5</span>] = <span class=\"number\">2</span>,to[<span class=\"number\">7</span>] = <span class=\"number\">3</span>,to[<span class=\"number\">11</span>] = <span class=\"number\">4</span>,to[<span class=\"number\">13</span>] = <span class=\"number\">5</span>,to[<span class=\"number\">17</span>] = <span class=\"number\">6</span>,to[<span class=\"number\">19</span>] = <span class=\"number\">7</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">calc</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = a[x].x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=<span class=\"number\">19</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (tmp%i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\ta[x].s|=(<span class=\"number\">1</span>&lt;&lt;to[i]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (tmp%i == <span class=\"number\">0</span>) tmp/=i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ta[x].pri = tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(aa a,aa b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a.pri&gt;b.pri;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;mod;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\ta[i].x = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">calc</span>(i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a+<span class=\"number\">1</span>,a+n,cmp);</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[i].pri!=a[i<span class=\"number\">-1</span>].pri || a[i].pri == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memcpy</span>(f1,f,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">memcpy</span>(f2,f,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=M<span class=\"number\">-1</span>;j&gt;=<span class=\"number\">0</span>;j--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=M<span class=\"number\">-1</span>;p&gt;=<span class=\"number\">0</span>;p--)&#123;</span><br><span class=\"line\">\t\t\t\tf1[j|a[i].s][p] = (f1[j|a[i].s][p]+f1[j][p])%mod;</span><br><span class=\"line\">\t\t\t\tf2[j][p|a[i].s] = (f2[j][p|a[i].s]+f2[j][p])%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[i].pri!=a[i+<span class=\"number\">1</span>].pri || a[i].pri == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=M<span class=\"number\">-1</span>;j&gt;=<span class=\"number\">0</span>;j--)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=M<span class=\"number\">-1</span>;p&gt;=<span class=\"number\">0</span>;p--)&#123;</span><br><span class=\"line\">\t\t\t\t\tf[j][p] = (f1[j][p]+f2[j][p]-f[j][p])%mod;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=M<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=M<span class=\"number\">-1</span>;j&gt;=<span class=\"number\">0</span>;j--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i&amp;j) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tans = (ans+f[i][j])%mod;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;(ans+mod)%mod&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例7\"><a href=\"#例7\" class=\"headerlink\" title=\"例7\"></a>例7</h2><p><a href=\"https://www.luogu.com.cn/problem/P5933\">P5933 [清华集训2012]串珠子</a></p>\n<p>先考虑正着做。</p>\n<p>枚举集合 $i$，选择一个未加入的点，和已经连通的点中的任意一个连接，贡献到新的连通块中。</p>\n<p>但是，这样做会算重。</p>\n<p>因为连边顺序虽然有先后，但是最终的结果是一样的，所以会重复。</p>\n<p>正难则反，考虑容斥，算出不连通的方案。</p>\n<p>设 $f[i]$ 表示答案，$g[i]$ 表示所有连边的方案数，$t[i]$ 表示所有不连通的方案数。</p>\n<p>$g[i]$ 是很好算的，因为每个边都可以选或不选，所以 $g[i]$ 就是 $\\prod_{(u,v)\\in E,u\\in i,v\\in i}(c[u][v]+1)$</p>\n<p>一个不连通的方案，必然存在至少两个连通块，所以可以任意选择一个点，那么所有点就只有两种状态：和它连通与和它不连通。</p>\n<p>我们枚举和它连通的子集就可以不重不漏地遍历所有情况了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">20</span>,M = (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">16</span>)+<span class=\"number\">10</span>,mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,a[N][N];</span><br><span class=\"line\">ll f[M],g[M],t[M];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++) cin&gt;&gt;a[i][j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123;</span><br><span class=\"line\">\t\tg[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!((<span class=\"number\">1</span>&lt;&lt;(j<span class=\"number\">-1</span>))&amp;i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=j+<span class=\"number\">1</span>;k&lt;=n;k++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!((<span class=\"number\">1</span>&lt;&lt;(k<span class=\"number\">-1</span>))&amp;i)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\tg[i] = g[i]*(a[j][k]+<span class=\"number\">1</span>)%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pos = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((<span class=\"number\">1</span>&lt;&lt;j)&amp;i)&#123;</span><br><span class=\"line\">\t\t\t\tpos = j;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pos == <span class=\"number\">-1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> tmp = i^(<span class=\"number\">1</span>&lt;&lt;pos);</span><br><span class=\"line\">\t\tt[i] = f[<span class=\"number\">1</span>&lt;&lt;pos]*g[tmp]%mod;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=tmp;j;j = (j<span class=\"number\">-1</span>)&amp;tmp) t[i] = (t[i]+f[j^(<span class=\"number\">1</span>&lt;&lt;pos)]*g[tmp^j]%mod)%mod;</span><br><span class=\"line\">\t\tf[i] = (g[i]-t[i])%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;(f[(<span class=\"number\">1</span>&lt;&lt;n)<span class=\"number\">-1</span>]+mod)%mod&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例8\"><a href=\"#例8\" class=\"headerlink\" title=\"例8\"></a>例8</h2><p><a href=\"https://www.luogu.com.cn/problem/CF1523F\">Favorite Game</a></p>\n<p>这道题的状态表示很要点功夫。</p>\n<p>可以发现，所有状态都离不开三个信息：当前的位置，做完的任务，需要的时间。</p>\n<p>但是，虽然我们能身处的位置很多，重要的位置其实只有两个：传送点和任务地点。因为其他的所有位置只不过是在这两种位置之间互相移动时经过的罢了。</p>\n<p>更具体一点，假设我们刚刚做完一个任务，这就隐含了当前的时间和位置，所以可以设 $f[i][j]$ 表示考虑到第 $i$ 个任务，传送点开启状态为 $j$ 时的最大任务数量。</p>\n<p>如果在一个传送点，其实也隐含了位置，于是可以设 $g[i][j]$ 表示做完了 $i$ 个任务，传送点开启状态为 $j$ 时需要的最小时间。</p>\n<p>最后思考一下如何转移。</p>\n<p>转移的方式有 $4$ 种：</p>\n<ol>\n<li>任务地点到任务地点：枚举下一个任务，看直接走是否超时。</li>\n<li>任务地点到传送点：有两种情况，到开过的和没开过的，依次更新即可。</li>\n<li>传送点到传送点：在传送点之间移动没有意义，肯定是开新的传送点，枚举还没有开的，算出当前的传送点集合到它需要的最小时间，更新即可。</li>\n<li>传送点到任务地点：枚举任务，算出传送点集合到任务的时间，加上传送点自己的时间，看是否超时。</li>\n</ol>\n<p>如果按当前任务的顺序遍历，$g$ 数组很可能还没有更新完毕就拿来用了。</p>\n<p>考虑到所有转移，一个传送点集合只会被它的子集更新，所以从小到大枚举传送点集合更好。</p>\n<p>但是，这里存在交叉更新，怎样才能保证每次访问的都是更新完毕的呢？</p>\n<p> 一个任务地点，如果不开新的传送点，只能通过现有的到达，所以它对传送点数组没有影响，开了新传送点，这个影响也只会在后面的集合中处理，所以没有影响。</p>\n<p>但是，一个传送点集合，可以在不扩展的情况下，到达任务地点，从而更新当前的任务地点数组，所以有影响。</p>\n<p>于是就应该把有影响的放前面。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1.3e2</span>+<span class=\"number\">10</span>,M = (<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">14</span>)+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,t[N],dis[M][N],tmp[N],f[N][M],g[N][M];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">poss</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125; a[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">bb</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,t;</span><br><span class=\"line\">&#125; b[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(bb a,bb b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a.t&lt;b.t;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dist</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">abs</span>(a[x].x-a[y].x)+<span class=\"built_in\">abs</span>(a[x].y-a[y].y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dis,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(dis));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> tot = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> ((<span class=\"number\">1</span>&lt;&lt;j)&amp;i) tmp[++tot] = j+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">1</span>;p&lt;=n+m;p++)&#123;</span><br><span class=\"line\">\t\t\t\tdis[i][p] = <span class=\"built_in\">min</span>(dis[i][p],<span class=\"built_in\">dist</span>(tmp[j],p));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cin&gt;&gt;b[i].x&gt;&gt;b[i].y&gt;&gt;b[i].t;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(b+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>+m,cmp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\ta[i+n].x = b[i].x,a[i+n].y = b[i].y;</span><br><span class=\"line\">\t\tt[i] = b[i].t;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(g,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(g));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) f[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) g[<span class=\"number\">0</span>][(<span class=\"number\">1</span>&lt;&lt;i)] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;n);i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (g[j][i] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">1</span>;k&lt;=m;k++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (g[j][i]+dis[i][k+n]&lt;=t[k]) f[k][i] = <span class=\"built_in\">max</span>(f[k][i],j+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;n;k++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!((<span class=\"number\">1</span>&lt;&lt;k)&amp;i)) g[j][i^(<span class=\"number\">1</span>&lt;&lt;k)] = <span class=\"built_in\">min</span>(g[j][i^(<span class=\"number\">1</span>&lt;&lt;k)],g[j][i]+dis[i][k+<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (f[j][i] == <span class=\"number\">-1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=j+<span class=\"number\">1</span>;k&lt;=m;k++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">min</span>(<span class=\"built_in\">dist</span>(j+n,k+n),dis[i][k+n])+t[j]&lt;=t[k]) f[k][i] = <span class=\"built_in\">max</span>(f[k][i],f[j][i]+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tg[f[j][i]][i] = <span class=\"built_in\">min</span>(g[f[j][i]][i],t[j]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;n;k++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!((<span class=\"number\">1</span>&lt;&lt;k)&amp;i))&#123;</span><br><span class=\"line\">\t\t\t\t\tg[f[j][i]][i^(<span class=\"number\">1</span>&lt;&lt;k)] = <span class=\"built_in\">min</span>(g[f[j][i]][i^(<span class=\"number\">1</span>&lt;&lt;k)],t[j]+<span class=\"built_in\">min</span>(<span class=\"built_in\">dist</span>(j+n,k+<span class=\"number\">1</span>),dis[i][k+<span class=\"number\">1</span>]));</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;n);j++) ans = <span class=\"built_in\">max</span>(ans,f[i][j]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","DP","状压DP"]},{"title":"番剧相关汇总","url":"/2023/08/08/%E7%95%AA%E5%89%A7%E7%9B%B8%E5%85%B3%E6%B1%87%E6%80%BB/","content":"<h1 id=\"番剧相关汇总\"><a href=\"#番剧相关汇总\" class=\"headerlink\" title=\"番剧相关汇总\"></a>番剧相关汇总</h1><h2 id=\"追番列表\"><a href=\"#追番列表\" class=\"headerlink\" title=\"追番列表\"></a>追番列表</h2><span id=\"more\"></span>\n<h3 id=\"正在追\"><a href=\"#正在追\" class=\"headerlink\" title=\"正在追\"></a>正在追</h3><p>「悠哉日常大王」</p>\n<p>「ATRI -My Dear Moments-」</p>\n<h3 id=\"准备看\"><a href=\"#准备看\" class=\"headerlink\" title=\"准备看\"></a>准备看</h3><h2 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h2><p>2023.3 「命运石之门」</p>\n<p>梦开始的地方。</p>\n<p>2023.6 「新世纪福音战士」</p>\n<p>哲学探讨有意思，人物塑造非常丰满。</p>\n<p>2023.7 「白色相簿」</p>\n<p>恋爱，果然是白色的啊。</p>\n<p>2023.7 「天使的心跳」</p>\n<p>催泪番，墙裂推荐，音乐很好听。</p>\n<p>2023.7 「紫罗兰永恒花园」</p>\n<p>画风优美，制作精良，剧情还行。</p>\n<p>2023.8 「少女终末旅行」</p>\n<p>俩声优声音真好听啊，萌翻了。</p>\n<p>2023.9 「Odd Taxi」</p>\n<p>多线并行，最后汇聚、爆发、归于平静的感觉很棒。</p>\n<p>2023.9 「日常」</p>\n<p>26 集看下来，似乎已经习惯于这些少女之间的趣事，这种逐渐自然的行为，这种慢慢产生的感情，也许就是日常吧。</p>\n<p>2023.9 「魔法少女小圆」</p>\n<p>大概是看的第一部战斗番，设定有意思，人物有个性，鹿目圆很可爱。</p>\n<p>2023.9 「末日时在做什么？有没有空？可以来拯救吗？」</p>\n<p>故事吸引人，珂朵莉更吸引人，没有什么特别出彩的地方，但是观感出乎意料的还不错。</p>\n<p>2023.10「龙与虎」</p>\n<p>梦寐以求的学生时代，真真切切的爱。不是成长，而是蜕变。激发态的我们，在变为基态时，一定会散发最耀眼的光芒。</p>\n<p>2023.11 「白圣女和黑牧师」</p>\n<p>甜甜恋爱番，剧情上没啥亮点，也没啥雷点，平平淡淡的挺好，记得女主很可爱。</p>\n<p>2024.1 「钢之炼金术师」</p>\n<p>看的 FA 版，剧情衔接紧凑，但打斗稍显拖沓，64 集的动画中水分巨大（不过也挺调胃口的）；设定不复杂，但足以支撑起无数精彩的桥段，人物塑造堪称顶级，Mustang 的抉择与忍让，Edward 的愤怒到理解，Greed 的贪婪与奉献，一个个立体丰满的人物，让人心绪万千。</p>\n<p>2024.1 「重启咲良田」</p>\n<p>轮回系的剧情一般很乱，这一部算伏笔回收做的较好的，许多看似没有关联的单元剧，都在最后有所体现，画风简陋，但隐隐约约又有文艺的感觉，不过我还是更喜欢相麻堇学姐。</p>\n<p>2024.4 「想要成为影之实力者！」</p>\n<p>主角基本无双速通，打斗虽然全是一边倒，但看的格外爽快，总之很吸引人，但是也的确没啥审美价值。</p>\n<p>2024.6 「浪客剑心」</p>\n<p>内涵精炼而深刻，很多场景意境十足，完全置身与那个刀光剑影，高手过招的时代，除了画风稍有年代感，其余都称得上顶尖水平，可以感受到制作组的用心。追忆篇更加文艺，每一幅画面都别出心裁，贯穿四集的，是那个时代独有的悲情与哀怨。</p>\n<p>2024.7「请问您今天要来点兔子吗？」</p>\n<p>断断续续看了一年，把两季和剧场版看了，没看 BLOOM，这种剧适合平时累了看一集，温馨治愈的感觉，但看多了会腻，画风极大加分，大家都可可爱爱的。</p>\n","tags":["Life","动漫"]},{"title":"科技普及 第一辑","url":"/2022/11/01/%E7%A7%91%E6%8A%80%E6%99%AE%E5%8F%8A-%E7%AC%AC%E4%B8%80%E8%BE%91/","content":"<h1 id=\"科技普及-第一辑\"><a href=\"#科技普及-第一辑\" class=\"headerlink\" title=\"科技普及 第一辑\"></a>科技普及 第一辑</h1><h2 id=\"循环数\"><a href=\"#循环数\" class=\"headerlink\" title=\"循环数\"></a>循环数</h2><h3 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h3><p>142857</p>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>质数 $p$，$\\frac{1}{p}$ 有循环节，且最小循环节的长度等于 $p-1$，则称 $p$ 为循环数。</p>\n<p>前 $3$ 个：$7,17,19$。可以用计算器验证一下，加深印象。</p>\n<span id=\"more\"></span>\n<h3 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h3><ol>\n<li><p>把循环节拿出来，变成一个整数，它的 $1$ 到 $p-1$ 倍正好是它右移某些位数的结果：</p>\n<p>$\\frac{1}{7} = 0.142857…$</p>\n<p>$142857\\times 1 = 142857$</p>\n<p>$142857\\times 2 = 285714$</p>\n<p>$142857\\times 3 = 428571$</p>\n<p>$142857\\times 4 = 571428$</p>\n<p>$142857\\times 5 = 714285$</p>\n<p>$142857\\times 6 = 857142$</p>\n</li>\n<li><p>$\\frac{10^{p-1}-1}{p}=$ 循环节。</p>\n</li>\n<li><p>所有位的值之和为 $\\frac{9\\cdot (p-1)}{2}$。</p>\n</li>\n</ol>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>用处不大，但是其本身还是十分美妙的，体现了数学的美感。</p>\n<p><a href=\"https://projecteuler.net/problem=358\">#358 Cyclic numbers</a></p>\n","tags":["Knowledge","数学"]},{"title":"矩阵乘法初步","url":"/2022/10/28/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%88%9D%E6%AD%A5/","content":"<h1 id=\"矩阵乘法初步\"><a href=\"#矩阵乘法初步\" class=\"headerlink\" title=\"矩阵乘法初步\"></a>矩阵乘法初步</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>能够进行矩阵乘法的两个矩阵，第一个矩阵的列数和第二个矩阵的行数一定相等。乘出来的矩阵的行数为第一个矩阵的行数，列数为第二个矩阵的列数。</p>\n<p>看一下代码就明白了：</p>\n<span id=\"more\"></span>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">mat <span class=\"keyword\">operator</span> * (<span class=\"type\">const</span> mat &amp;a,<span class=\"type\">const</span> mat &amp;b)&#123;</span><br><span class=\"line\">\tmat c;</span><br><span class=\"line\">\tc.<span class=\"built_in\">init</span>(a.r,b.c); <span class=\"comment\">//初始化 r 行 c 列的矩阵</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=a.r;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=b.c;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;=a.c;k++)&#123;</span><br><span class=\"line\">\t\t\t\tc.a[i][j] = (c.a[i][j]+a.a[i][k]*b.a[k][j])%mod; <span class=\"comment\">//a[][] 为存储矩阵的二维数组</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mat;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有两个要点：</p>\n<p>下标从哪里开始取决于你的矩阵中有意义的位置，不一定从 $0$ 开始。</p>\n<p>由于是乘法，所以尽量用 long long 存储，注意取模。</p>\n<p>写矩阵乘法的时候，由于会用到许多局部变量，它们是没有赋初始值的，所以要写一个 init 函数初始化矩阵。</p>\n<h2 id=\"性质\"><a href=\"#性质\" class=\"headerlink\" title=\"性质\"></a>性质</h2><p>矩阵乘法满足分配律，即 $a<em>(b+c) = a</em>b+a*c$。</p>\n<p>矩阵乘法满足结合律，即 $(a<em>b)</em>c = a<em>(b</em>c)$。</p>\n<p>矩阵乘法<strong>不满足</strong>交换律！！！写的时候一定要注意乘的顺序！！！</p>\n<h2 id=\"卡常\"><a href=\"#卡常\" class=\"headerlink\" title=\"卡常\"></a>卡常</h2><ol>\n<li>把上面的三层循环的顺序改为 $i,k,j$，可以得到巨大的卡常效果。</li>\n<li>次数优化，可以通过结合律，改变矩阵运算的顺序，达到减少运算次数的效果。</li>\n<li>取模优化，矩阵乘法一般都要取模，这时我们可以先判断其是否超过一个大数，超过就相减，最后再一次性取模，可以优化一些常数。</li>\n</ol>\n<h2 id=\"矩阵快速幂\"><a href=\"#矩阵快速幂\" class=\"headerlink\" title=\"矩阵快速幂\"></a>矩阵快速幂</h2><p>就是把快速幂中的乘法改为矩阵乘法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">mat <span class=\"title\">ksm</span><span class=\"params\">(mat bas,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tmat ret;</span><br><span class=\"line\">\tret.<span class=\"built_in\">init</span>(bas.r,bas.c);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"built_in\">min</span>(ret.r,ret.c);i++) ret.a[i][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ret = ret*bas;</span><br><span class=\"line\">\t\tbas = bas*bas;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意一开始的答案矩阵要设成 $I$，即主对角线上都是 $1$ 的矩阵，它的意义和整数中的 $1$ 相似。</p>\n<p>讲完了这些基本的概念，来看几个应用吧。</p>\n<h2 id=\"例题1\"><a href=\"#例题1\" class=\"headerlink\" title=\"例题1\"></a>例题1</h2><h3 id=\"题意\"><a href=\"#题意\" class=\"headerlink\" title=\"题意\"></a>题意</h3><p><a href=\"https://www.luogu.com.cn/problem/P1962\">P1962 斐波那契数列</a></p>\n<p>快速计算 $Fib_n$ 的值，$n \\leq 2^{63}$。</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>矩阵快速幂最适合处理的就是线性递推了。</p>\n<p>考虑把 $Fib_i = Fib_{i-1}+Fib_{i-2}$ 看成一个矩阵 $[Fib_{i-1},Fib_{i-2}]$。</p>\n<p>现在，我们要求出它递推出的下一个矩阵：$[Fib_{i},Fib_{i-1}]$。</p>\n<p>考虑拿这个东西和它乘：</p>\n<script type=\"math/tex; mode=display\">\n\\left(\n    \\begin{array}{cc}\n    1 & 1\\\\\n    1 & 0\\\\\n    \\end{array}\n\\right)</script><h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p><a href=\"https://www.luogu.com.cn/problem/P1349\">P1349 广义斐波那契数列</a></p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p><a href=\"https://www.luogu.com.cn/problem/P1306\">P1306 斐波那契公约数</a></p>\n<p>$\\gcd(Fib_n,Fib_m) = Fib_{\\gcd(n,m)}$</p>\n<p>这个结论可以背下来。</p>\n<h2 id=\"例题2\"><a href=\"#例题2\" class=\"headerlink\" title=\"例题2\"></a>例题2</h2><p><a href=\"https://www.luogu.com.cn/problem/P2129\">P2129 L 国的战斗续之多路出击</a></p>\n<p>首先，要转化思路，不要盯着原始坐标看，我们只要知道对于泛指的 $(x,y)$，它最后移动到的位置就行了。</p>\n<p>考虑一个小的矩阵：</p>\n<p>$[x,y,1]$</p>\n<p>$x$ 变为 $-x$：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left(\n    \\begin{array}{ccc}\n    -1 & 0 & 0\\\\\n    0 & 1 & 0\\\\\n    0 & 0 & 1\\\\\n    \\end{array}\n\\right)\n\\end{equation}</script><p>$y$ 变为 $-y$：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left(\n    \\begin{array}{ccc}\n    1 & 0 & 0\\\\\n    0 & -1 & 0\\\\\n    0 & 0 & 1\\\\\n    \\end{array}\n\\right)\n\\end{equation}</script><p>$x+p,y+q$：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left(\n    \\begin{array}{ccc}\n    1 & 0 & 0\\\\\n    0 & 1 & 0\\\\\n    p & q & 1\\\\\n    \\end{array}\n\\right)\n\\end{equation}</script><p>把后面的都结合掉，最后再分别和每一个坐标构成的矩阵相乘即可。</p>\n<h2 id=\"例题3\"><a href=\"#例题3\" class=\"headerlink\" title=\"例题3\"></a>例题3</h2><p><a href=\"http://poj.org/problem?id=3233\">3233 — Matrix Power Series</a></p>\n<p>发现，当 $n$ 为偶数时，可以分成 $(I+A^{\\frac{n}{2}})\\cdot (A+A^2+\\cdots +A^{\\frac{n}{2}})$，如果是奇数，就把最后一项拎出来单独计算。</p>\n<p>每次分治成更小的子问题，在分治过程中求矩阵快速幂的复杂度为 $O(\\log n)$，于是总复杂度为 $O(\\log ^2 n)$。</p>\n<h2 id=\"例题4\"><a href=\"#例题4\" class=\"headerlink\" title=\"例题4\"></a>例题4</h2><p><a href=\"http://acm.hdu.edu.cn/showproblem.php?pid=2157\">Problem - 2157</a></p>\n<p>现在应该知道为啥叫邻接矩阵了吧，因为这就是个矩阵！</p>\n<p>考虑用邻接矩阵存图，$A[i][j] = 1$ 表示有一条从 $i$ 到 $j$ 的边。</p>\n<p>思考一下 $A*A$ 的意义：$\\sum_{k=1}^mA[i][k]\\cdot A[k][j]$，不就是从 $i$ 到 $j$ 经过两条边的方案数吗？</p>\n<p>于是问题转化为求 $A^k$。</p>\n","tags":["Knowledge","数学","矩阵乘法"]},{"title":"第一章：直线运动","url":"/2023/05/21/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%9B%B4%E7%BA%BF%E8%BF%90%E5%8A%A8/","content":"<h1 id=\"第一章：直线运动\"><a href=\"#第一章：直线运动\" class=\"headerlink\" title=\"第一章：直线运动\"></a>第一章：直线运动</h1><p>主要方法是画 v-t 图。</p>\n<h2 id=\"公式总结\"><a href=\"#公式总结\" class=\"headerlink\" title=\"公式总结\"></a>公式总结</h2><p>最基本的公式：</p>\n<p>$x = v_0t+\\frac{1}{2}at^2$</p>\n<p>虽然慢一些，但是肯定能算出来，而且在解决位移相关的讨论问题时非常方便，比如追及，最后解一个二次方程就完了。</p>\n<span id=\"more\"></span>\n<p>推论：</p>\n<p>$v_1^2-v_o^2=2ax$</p>\n<p>这个公式和 $t$ 没关系，所以在不需要求 $t$ 的时候很好用，而且常用于各种图像的转化。</p>\n<p>$\\Delta x = aT^2$</p>\n<p>这里的 $\\Delta x$ 是相邻两端相等时间内的位移之差，所以也可以扩展到相差 $k$ 段的情况，但是 $T$ 一定要相等。</p>\n<h2 id=\"经典问题\"><a href=\"#经典问题\" class=\"headerlink\" title=\"经典问题\"></a>经典问题</h2><h3 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h3><p>一个从静止开始作匀加速直线运动的物体，经过两段相邻的段，知道分别用的时间和距离，求出发点的位置。</p>\n<p>可以求出两段的中点时刻的速度，即平均速度，之后又知道这之间差的时间，于是可以求出加速度，再算出起点到某一个中点时刻花费的时间，即可求出距离。</p>\n<h3 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h3><p>从横截面积为 $S$ 的水龙头中喷出速度为 $v$ 的水，求在某个高度上的水柱面积。（这里假设喷的方向向上）</p>\n<p>喷出来的水可以看成作加速度为 $g$ 的匀减速运动，所以可以算出在这个高度上水的速度，又因为上下段的水柱之间不能有作用力，所以在某一段时间内经过某个横截面的水的体积和喷出的水的体积应该是一样的，推出 $v\\cdot S$ 是一个定值，求出 $v$ 后即可直接算出 $S$。</p>\n","tags":["物理","运动学"]},{"title":"第二章：相互作用","url":"/2023/05/21/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E7%9B%B8%E4%BA%92%E4%BD%9C%E7%94%A8/","content":"<h1 id=\"第二章：相互作用\"><a href=\"#第二章：相互作用\" class=\"headerlink\" title=\"第二章：相互作用\"></a>第二章：相互作用</h1><p>这一章涉及的主要是静力学问题，所以常使用整体法辅助分析。</p>\n<h2 id=\"基本方法\"><a href=\"#基本方法\" class=\"headerlink\" title=\"基本方法\"></a>基本方法</h2><p>正交分解：最简单也是最容易想到的，但是在处理复杂问题时不方便。</p>\n<p>矢量三角形：在一个力不变，一个力方向不变的时候，可以很好的解决变化的问题。</p>\n<span id=\"more\"></span>\n<p>正弦定理：</p>\n<p><img src=\"https://s2.loli.net/2023/05/21/Ck82pa65wPsvMnJ.png\" alt=\"2-1\"></p>\n<p>$\\frac{F1}{\\alpha} = \\frac{F2}{\\theta} = \\frac{F3}{\\beta}$</p>\n<p>常用于两个力夹角一定，但是方向改变的情况，分析起来较方便。</p>\n<p>相似三角形：有时，一个物理所受的三个力可能可以在一个三角形中找到，这时可以把力的变化转化为三角形的变化。</p>\n<h2 id=\"经典题型\"><a href=\"#经典题型\" class=\"headerlink\" title=\"经典题型\"></a>经典题型</h2><h3 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h3><p>分析受力：</p>\n<p><img src=\"https://s2.loli.net/2023/05/21/VyuYFLDfUO71gMo.png\" alt=\"2-2\"></p>\n<p><img src=\"https://s2.loli.net/2023/05/21/GUNZzThoBMiqrcR.png\" alt=\"2-3\"></p>\n<p>在上面的图中，由于是轻质弹簧，所以 $F1=F2$。那弹簧中某一点受到的力是多少呢？</p>\n<p>答案是 $F1(F2)$，而不是 $F1+F2$，因为弹簧上所有点受到的力相等（不然会运动），所以每一个点都受到 $F1(F2)$ 的力，弹簧的伸长量就是 $\\frac{F1}{k}$。</p>\n<p>在下面的图中，一个轻质滑轮固定，由于是静止的绳，所以 $F1=F2$，那滑轮的受力是什么样的呢？</p>\n<p>答案是 $F1+F2$，这里的 $+$ 是<strong>矢量求和</strong>，我们可以用极限的思想考虑，当滑轮足够小的时候，受到的力就是 $F1+F2$，所以和上面的一小段绳子没关系。</p>\n<p>这两个东西可以当模型记住，方便分析受力。</p>\n<h3 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h3><p><img src=\"https://s2.loli.net/2023/05/21/1JeSRrFiKktzqNd.png\" alt=\"2-6\"></p>\n<p>一个物体受到重力和两个互相垂直的力 $F1,F2$ 作用，处于平衡状态，求 $F1,F2$ 的大小。</p>\n<p>如果把 $F1,F2$ 分解到重力方向，就要列两个含三角函数的方程，是可以解，但是麻烦了。</p>\n<p>更好的是把重力分解到 $F1,F2$ 方向上，这样可以直接写出 $F1,F2$。</p>\n<p>所以要注意看到直角时下意识想分解方向。</p>\n<h3 id=\"例3\"><a href=\"#例3\" class=\"headerlink\" title=\"例3\"></a>例3</h3><p><img src=\"https://s2.loli.net/2023/05/21/pMwZaxsNHl85oCR.jpg\" alt=\"2-4\"></p>\n<p>难点在于球之间互相的支持力方向不好确定。</p>\n<p>考虑先用整体法，忽略掉这里面的力，分析出 $F_{Na},F_{Nb}$ 之间的关系。</p>\n<p><img src=\"https://s2.loli.net/2023/05/21/SIcOusyl3YGeNzx.png\" alt=\"2-5\"></p>\n<p>由 $F_{Na},F_{Nb}$ 在水平方向上的分力相等，可得 $F_{Na}\\cos\\alpha = F_{Nb}\\cos\\beta$，于是 $D$ 正确。</p>\n<p>之后，注意到虽然相互作用力的夹角不好求，但是实际上是有上图中红色的相似三角形，分析一下就出来了。</p>\n<p>从这题我们可以得到两点：</p>\n<ol>\n<li>遇到不好分析的相互作用力时，可以用整体法忽略掉，先分析出别的有用信息。</li>\n<li>遇到具有几何特征的图形（圆，等边/等腰/直角三角形）时，可以考虑在图中找到和力的矢量三角形相似的三角形。</li>\n</ol>\n<h3 id=\"例4\"><a href=\"#例4\" class=\"headerlink\" title=\"例4\"></a>例4</h3><p><img src=\"https://s2.loli.net/2023/05/21/Jsb7Ci5OQtZUTEV.jpg\" alt=\"2-8\"></p>\n<p>一般相似三角形的题目，都会有特征，比如这里有实体的绳，而力又恰好是沿绳方向的，还有在正上方，正好对应竖直向下的重力，还有球的支持力，只能是沿圆心的，这么多几何关系，大概率就是相似三角形了。</p>\n<h3 id=\"例5\"><a href=\"#例5\" class=\"headerlink\" title=\"例5\"></a>例5</h3><p><img src=\"https://s2.loli.net/2023/05/21/QrzF4qBkM7Ilynm.jpg\" alt=\"2-7\"></p>\n<p>这里面最不好分析的就是弹簧的力，因为方向和大小都在变，遇到这种不好分析的内力（相互作用力），先想整体法。</p>\n<p>这两个小球构成的整体只受绳的拉力和 $F$，可以由正弦定理得到 $F$ 的变化。</p>\n<p>之后，我们对 $A$ 进行分析，因为它上面一个力不变，一个力只有大小变，想到矢量三角形，画一下就知道弹簧的力的变化情况了。</p>\n<h3 id=\"例6\"><a href=\"#例6\" class=\"headerlink\" title=\"例6\"></a>例6</h3><p><img src=\"https://s2.loli.net/2023/05/21/PX54KJEhAOyFZVk.jpg\" alt=\"2-9\"></p>\n<p>这是一类很常见的模型，结论要记牢。</p>\n<p>首先，对物体进行分析，受到重力和两个大小相同的拉力 $F$，可以推出这两个力和竖直方向的夹角相同（否则在竖直方向上不平衡）</p>\n<p><img src=\"https://s2.loli.net/2023/05/21/piEQRImnX9G4VlD.png\" alt=\"2-10\"></p>\n<p>我们再分析这里面的几何关系，把 $\\theta$ 的变化规律找出来：</p>\n<p>$x\\sin\\theta+(L-x)\\sin\\theta = h$</p>\n<p>即 $\\sin\\theta = \\frac{h}{L}$。</p>\n<p>而在两个杆之间的距离不变时，$\\theta$ 就不会变化。</p>\n<p>在杆之间的距离增大时，$\\theta$ 便增大。</p>\n<p>对于 $D$ 选项，我们可以找一个等效 $g$，将这个图翻转一个角度，之后就可以知道 $h$ 的变化情况了。</p>\n<p>。</p>\n","tags":["物理","力学","静力学"]},{"title":"科技普及 第二辑","url":"/2022/11/04/%E7%A7%91%E6%8A%80%E6%99%AE%E5%8F%8A-%E7%AC%AC%E4%BA%8C%E8%BE%91/","content":"<h1 id=\"科技普及-第二辑\"><a href=\"#科技普及-第二辑\" class=\"headerlink\" title=\"科技普及 第二辑\"></a>科技普及 第二辑</h1><h2 id=\"再谈线性筛\"><a href=\"#再谈线性筛\" class=\"headerlink\" title=\"再谈线性筛\"></a>再谈线性筛</h2><h2 id=\"筛质数\"><a href=\"#筛质数\" class=\"headerlink\" title=\"筛质数\"></a>筛质数</h2><p><a href=\"https://www.luogu.com.cn/problem/P3383\">P3383 【模板】线性筛素数</a></p>\n<p>线性筛之所以快，是因为它遵循一条重要的原则：每个合数都被它<strong>最小的质因子</strong>乘上一个数筛掉。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>先看循环中的第一个 $if$，$vis$ 数组判断 $i$ 是否被筛过，如果被筛，就记录着筛掉它的最小质因子，$pri$ 数组是存储所有筛出来的质数的。</p>\n<p>之后，看到下面的 $for$，里面枚举了所有的质数 $pri[j]$，第一个 $if$ 里面判断的分别是是否被最小的质数筛和是否超出了筛的范围，如果是，就 $break$ 掉。</p>\n<p>后面的一行，相当于现在 $pri[j]$ 比 $i$ 中的最小质因子都要小，所以乘起来，乘积的最小质因子就是 $pri[j]$ 了。</p>\n<p>很好理解是吗？我们来看一些拓展。</p>\n<h2 id=\"筛欧拉函数\"><a href=\"#筛欧拉函数\" class=\"headerlink\" title=\"筛欧拉函数\"></a>筛欧拉函数</h2><p>欧拉函数的计算式是 $\\varphi(x) = x\\prod_{i=1}^{k}(1-\\frac{1}{p_i})$，其中 $p_i$ 是 $x$ 的质因子，$k$ 是质因子的个数。</p>\n<p>怎么得到的可以看<a href=\"https://bowenone580.github.io/2022/04/02/约数/\">约数</a>，这里不再赘述。</p>\n<p>现在，我们在线性筛的框架内做这个事。</p>\n<p>显然，$\\varphi(p) = p-1$，因为 $p$ 是质数，所以质因子只有它一个，代入上式可得。</p>\n<p>考虑两个互质的数相乘，由于它们的质因子都不共享，所以后面的 $\\prod$ 里面的东西不重叠，它们的乘积正好就是前面的相乘，所以当 $p,q$ 互质时，$\\varphi(p\\cdot q) = \\varphi(p)\\cdot \\varphi(q)$。</p>\n<p>如果它们不互质，情况就有点复杂了，但是，在线性筛中，只会是一个质数和一个整数相乘，我们只用判断这个整数中是否含有这个质数即可，这可以通过取模操作实现。</p>\n<ol>\n<li>不含有，则这两个数互质，按照上面的结论，$\\varphi(pq) = \\varphi(p)\\cdot \\varphi(q)$。</li>\n<li>含有，我们写出乘积的欧拉函数计算式，发现它 $\\prod$ 后面的东西和 $\\varphi(q)$ 完全相同，只是前面多了一个 $p$，于是 $\\varphi(pq) = p\\cdot \\varphi(q)$。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tphi[i] = i<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\tphi[i*pri[j]] = phi[i]*(i%pri[j]?pri[j]<span class=\"number\">-1</span>:pri[j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"筛莫比乌斯函数\"><a href=\"#筛莫比乌斯函数\" class=\"headerlink\" title=\"筛莫比乌斯函数\"></a>筛莫比乌斯函数</h2><p>莫比乌斯函数的形式化定义：</p>\n<p>$n = \\prod_{i=1}^k p_i^{c_i}$，其中 $p_i$ 是质因子，$c_i$ 是该质因子的指数，如果 $c_i$ 全部 $\\leq 1$，则 $\\mu(n) = (-1)^k$，否则 $\\mu(n) = 0$。</p>\n<p>考虑线性筛中 $p$ 和 $q$ 相乘，其中 $p$ 是质数。</p>\n<p>如果 $p,q$ 互质，那么显然 $p$ 这个质因子没有在 $q$ 中出现，所以 $p\\cdot q$ 中它的指数一定是 $1$，相当于让 $k$ 增加了 $1$，分讨一下，可以发现 $\\mu(pq) = -\\mu(q)$。</p>\n<p>如果 $q$ 是 $p$ 的倍数，那么显然 $pq$ 中 $p$ 的指数大于 $1$，应该赋值为 $0$。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>; <span class=\"comment\">//1要特别初始化，因为它是特殊定义的</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> lim = <span class=\"number\">5e4</span>+<span class=\"number\">10</span>; <span class=\"comment\">//筛到的数的上限</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">            vis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>; <span class=\"comment\">//质数的mu为-1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i]; <span class=\"comment\">//在vis[i] = pri[j]时要赋值为0</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"筛约数个数\"><a href=\"#筛约数个数\" class=\"headerlink\" title=\"筛约数个数\"></a>筛约数个数</h2><p>根据唯一分解定理，$n = \\prod_{i=1}^kp_i^{c_i}$，则约数个数为 $\\prod_{i=1}^k(c_i+1)$。</p>\n<p>设 $d[i]$ 表示 $i$ 的约数个数，$cnt[i]$ 表示 $i$ 的最小质因数出现次数。</p>\n<p>显然，对于所有质数 $i$，$d[i] = 2,cnt[i] = 1$。</p>\n<p>再次考虑线性筛中的 $p,q$。</p>\n<ol>\n<li>$p,q$ 互质，则 $p$ 这个质因数在 $pq$ 中出现的次数一定是 $1$，所以 $d[pq] = 2\\cdot d[q],num[pq] = 1$。</li>\n<li>$q$ 是 $p$ 的倍数，则 $pq$ 中，$p$ 出现的次数为 $num[q]+1$，所以 $d[pq] = d[q]/(num[q]+1)\\cdot (num[q]+2),num[pq] = num[q]+1$。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\td[i] = <span class=\"number\">2</span>,cnt[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i%pri[j]) d[i*pri[j]] = d[i]*<span class=\"number\">2</span>,cnt[i*pri[j]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> d[i*pri[j]] = d[i]/(cnt[i]+<span class=\"number\">1</span>)*(cnt[i]+<span class=\"number\">2</span>),cnt[i*pri[j]] = cnt[i]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"筛约数和\"><a href=\"#筛约数和\" class=\"headerlink\" title=\"筛约数和\"></a>筛约数和</h2><p>先给出约数和的计算式：</p>\n<p>$d[x] = \\sum_{i=1}^k(1+p_i+p_i^2+\\cdots +p_i^{c_i})$</p>\n<p>维护一个 $num[x]$ 表示 $x$ 的最小质因数和它的指数组成的 $d$。</p>\n<p>还是考虑 $p,q$。</p>\n<ol>\n<li>$p,q$ 互质，则 $d[pq] = d[p]\\cdot d[q]$，因为上面的质因数没有重叠，都对答案产生了贡献，又由于 $p$ 变成了 $pq$ 的最小质因数，所以 $num[pq] = p+1$。</li>\n<li>$q$ 是 $p$ 的倍数，则 $d[pq] = d[q]/num[q]\\cdot (num[q]\\cdot p+1),num[pq] = num[q]\\cdot p+1$。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\td[i] = num[i] = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i%pri[j]) d[i*pri[j]] = d[i]*d[pri[j]],num[i*pri[j]] = num[pri[j]];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> d[i*pri[j]] = d[i]/num[i]*(num[i]*pri[j]+<span class=\"number\">1</span>),num[i*pri[j]] = num[i]*pri[j]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>快去学杜教筛！上面的东西都能筛，复杂度还低，杜教筛，值得你拥有！</p>\n","tags":["Knowledge","数学","质数","筛法"]},{"title":"简单的数学题 题解","url":"/2022/05/26/%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E5%AD%A6%E9%A2%98-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"简单的数学题-题解\"><a href=\"#简单的数学题-题解\" class=\"headerlink\" title=\"简单的数学题 题解\"></a>简单的数学题 题解</h1><h2 id=\"60分思路\"><a href=\"#60分思路\" class=\"headerlink\" title=\"60分思路\"></a>60分思路</h2><p>$\\sum_{i=1}^n\\sum_{j=1}^nij\\gcd(i,j)$</p>\n<p>枚举$\\gcd$：</p>\n<p>$\\sum_{d=1}^nd\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{n}{d}}ij[\\gcd(i,j)= 1]\\cdot d^2 \\iff \\sum_{d=1}^nd^3\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{n}{d}}ij[\\gcd(i,j)= 1]$</p>\n<p>把$\\gcd$化成$\\mu$：</p>\n<p>$\\sum_{d=1}^nd^3\\sum_{i=1}^{n/d}\\sum_{j=1}^{n/d}ij\\sum_{k|\\gcd(i,j)}\\mu(k)$<br><span id=\"more\"></span></p>\n<p>枚举$k$：</p>\n<p>$\\sum_{d=1}^nd^3\\sum_{k=1}^{n/d}\\mu(k)\\sum_{i’=1}^{n/kd}\\sum_{j’=1}^{n/kd}i’j’$</p>\n<p>后面的东西可以变化一下：</p>\n<p>$\\sum_{d=1}^nd^3\\sum_{k=1}^{n/d}\\mu(k)\\sum_{i’=1}^{n/kd}i’\\sum_{j’=1}^{n/kd}j’$</p>\n<p>用等差数列求和简化：</p>\n<p>$\\sum_{d=1}^nd^3\\sum_{k=1}^{n/d}\\mu(k)(\\frac{(1+\\frac{n}{kd})\\cdot \\frac{n}{kd}}{2})^2$</p>\n<p>这样就可以$O(\\sqrt n)$求解后面的式子了。</p>\n<p>前面的式子求解是$O(n)$的，总时间复杂度为$O(n\\sqrt n)$。</p>\n<h2 id=\"100分思路\"><a href=\"#100分思路\" class=\"headerlink\" title=\"100分思路\"></a>100分思路</h2><p>需要用到杜教筛，但是现在还没学，所以先放一下吧。</p>\n","tags":["Editorial","数论","莫比乌斯反演"]},{"title":"糖果传递 题解","url":"/2022/04/12/%E7%B3%96%E6%9E%9C%E4%BC%A0%E9%80%92-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"糖果传递-题解\"><a href=\"#糖果传递-题解\" class=\"headerlink\" title=\"糖果传递 题解\"></a>糖果传递 题解</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>一切都是推式子。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>每个人都要补前面人的差值，补自己的差值。</p>\n<p>设$x_i$表示第$i$个人从第$i+1$个人那里拿了多少张牌，为正则是拿，为负则是送。</p>\n<p>于是，设第$i$个人的牌数是$s_i$，则一定满足式子$s_i+x_i-x_{i-1} = avg$。</p>\n<span id=\"more\"></span>\n<p>把所有人的式子都列出来：</p>\n<p>$s_1+x_1-x_n = avg\\\\s_2+x_2-x_1 = avg\\\\\\cdots\\\\s_n+x_n-x_{n-1} = avg$</p>\n<p>我们花费的代价是$|x_1|+|x_2|+\\cdots+|x_n|$，现在要使这个东西最小。</p>\n<p>这个东西直接凑不太好凑，我们考虑把它们都化为$x_1$的形式。</p>\n<p>$x_2 = avg-s_2+x_1\\\\x_3 = avg-s_3+avg-s_2+x_1 = 2avg-s_2-s_3+x_1\\\\x_4 = avg-s_4+2avg-s_2-s_3+x_1 = 3avg-s_2-s_3-s_4+x_1$</p>\n<p>于是，这个式子就变成了$|x_1|+|x_1+avg-s_2|+|x_1+2avg-s_2-s_3|+\\cdots +|x_1+(n-1)avg-(s_2+s_3+\\cdots +s_n)|$。</p>\n<p>显然，每个绝对值后面的数都是定值，这个可以直接预处理出来，我们不妨设每个绝对值后面的数为$f_i$。</p>\n<p>则，式子可以化为$|x_1+f_1|+|x_1+f_2|+\\cdots+|x_1+f_n|$。</p>\n<p>当$n$为偶数时，根据初中学习的绝对值相关知识，画个数轴出来，可以发现，当$x_1$在排序后的$f$数组中的$-f_{n/2}$和$-f_{n/2+1}$之间时，值最小。</p>\n<p>当$n$为奇数时，$x_1$在$-f_{(n+1)/2}$时，值最小。</p>\n<p>于是，我们先把$f_i$的值都算出来，再取$-f_{(n+1)/2}$，就是$x_1$的取值，把结果算一下就行了。</p>\n<h2 id=\"Code-：\"><a href=\"#Code-：\" class=\"headerlink\" title=\"$Code$：\"></a>$Code$：</h2><p>注意long long</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,a[N],f[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> avg = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i];</span><br><span class=\"line\">\t\tavg+=a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tavg/=n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tsum+=a[i];</span><br><span class=\"line\">\t\tf[i] = avg*(i<span class=\"number\">-1</span>)-sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(f+<span class=\"number\">1</span>,f+<span class=\"number\">1</span>+n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = f[(n+<span class=\"number\">1</span>)/<span class=\"number\">2</span>],ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans+=<span class=\"built_in\">abs</span>(x-f[i]);</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","贪心"]},{"title":"约数","url":"/2022/04/02/%E7%BA%A6%E6%95%B0/","content":"<h1 id=\"约数\"><a href=\"#约数\" class=\"headerlink\" title=\"约数\"></a>约数</h1><h2 id=\"算数基本定理的推论\"><a href=\"#算数基本定理的推论\" class=\"headerlink\" title=\"算数基本定理的推论\"></a>算数基本定理的推论</h2><p>一个正整数$n$被唯一分解为$n = p_1^{c_1}p_2^{c_2}\\cdot \\cdot \\cdot p_m^{c_m}$，其中$c_i$都是正整数，$p_i$都是质数，且满足$p_1&lt;p_2&lt;\\cdot \\cdot \\cdot p_m$。</p>\n<p>则$n$的正约数个数为$(c_1+1)(c_2+1)\\cdot\\cdot\\cdot (c_m+1)$，可以看作每个质因子上面的幂都有$c_i+1$种选择。</p>\n<p>$n$的约数和为$(1+p_1+p_1^2+\\cdot\\cdot\\cdot+p_1^{c_1})\\cdot\\cdot\\cdot(1+p_m+p_m^2+\\cdot\\cdot\\cdot+p_m^{c_m})$，这可以看作每一个质因子不同幂次的不同结果相加，再乘起来就涵盖了每一种可能，也就是约数和。</p>\n<span id=\"more\"></span>\n<p>如果学了等比数列的可以快速计算这个式子：</p>\n<p>$1+p_i+p_i^2+\\cdot\\cdot\\cdot+p_i^{c_i} = \\frac{p_i^{c_i+1}-1}{p_i-1}$</p>\n<p>这样只需要$O(\\log n)$的时间就能计算约数和。</p>\n<h2 id=\"求一个数的约数集合\"><a href=\"#求一个数的约数集合\" class=\"headerlink\" title=\"求一个数的约数集合\"></a>求一个数的约数集合</h2><p>我们采用试除法，如前面所说，$n$如果能表示为$n = a*b$，那么$a$和$b$中必然有一个数小于等于$\\sqrt{n}$。</p>\n<p>所以我们只用找到所有小于等于$\\sqrt{n}$的约数，就能得到$n$所有的约数。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> k = <span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (n%i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\ta.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (n/i!=i) a.<span class=\"built_in\">push_back</span>(n/i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">sort</span>(a.<span class=\"built_in\">begin</span>(),a.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"type\">int</span> sz = a.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;sz;i++) cout&lt;&lt;a[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此算法的时间复杂度为$O(\\sqrt{n})$</p>\n<h2 id=\"求1-n中所有数的约数集合\"><a href=\"#求1-n中所有数的约数集合\" class=\"headerlink\" title=\"求1~n中所有数的约数集合\"></a>求1~n中所有数的约数集合</h2><p>这时，如果使用简单的试除法，就太慢了，时间复杂度为$O(n\\sqrt{n})$。</p>\n<p>我们发现，对于一个数$d$，它的所有倍数都一定有$d$这一个约数，所以我们只要枚举约数，标记这个约数的所有倍数就可以在$O(n\\log n)$的时间内完成。</p>\n<p>推论：1~n中每个数约数的总和为$O(n\\log n)$个，每个数平均有$\\log n$个约数。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; a[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n/i;j++)&#123;</span><br><span class=\"line\">\t\t\ta[i*j].<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(a[i].<span class=\"built_in\">begin</span>(),a[i].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sz = a[i].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;sz;j++) cout&lt;&lt;a[i][j]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>练习：</p>\n<p><a href=\"https://www.luogu.com.cn/problem/U198025\">U198025</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P1463\">P1463</a></p>\n<h2 id=\"最大公约数\"><a href=\"#最大公约数\" class=\"headerlink\" title=\"最大公约数\"></a>最大公约数</h2><p>两个数的约数中，最大的公共的约数叫做最大公约数。</p>\n<p>结论1：$gcd(a,b)\\cdot lcm(a,b) = a\\cdot b$。</p>\n<p>证明：$lcm(a,b)$中，$a,b$不共同拥有的质因数一定存在，$a,b$共同拥有的质因数只要达到最大的一个即可，所以除掉公共的因数，就是$lcm(a,b)$。</p>\n<h3 id=\"求最大公约数\"><a href=\"#求最大公约数\" class=\"headerlink\" title=\"求最大公约数\"></a>求最大公约数</h3><p>$gcd(a,b) = gcd(b,a\\ mod \\ b)$。</p>\n<p>证明：</p>\n<ol>\n<li>$a\\leq b$，$gcd(a,b) = gcd(b,a \\ mod \\ b) = gcd(b,a)$。</li>\n<li>$a&gt;b$，$gcd(a,b) = gcd(b,a \\ mod \\ b) = gcd(b,a-k\\cdot b)$，如果最大公约数$d|a$，$d|b$，那么$d|k\\cdot b$，则$d|a-k\\cdot b$。</li>\n</ol>\n<h2 id=\"互质\"><a href=\"#互质\" class=\"headerlink\" title=\"互质\"></a>互质</h2><p>如果$gcd(a,b) = 1$，那么$a$和$b$就互质。</p>\n<p>对于3个数或更多数的情况，我们把$gcd(a,b,c) = 1$称为$a$、$b$和$c$这3个数互质。</p>\n<h2 id=\"欧拉函数\"><a href=\"#欧拉函数\" class=\"headerlink\" title=\"欧拉函数\"></a>欧拉函数</h2><p>1~n中和n互质的数的个数叫做欧拉函数，记为$\\varphi(n)$</p>\n<p>怎么计算这个东西呢？</p>\n<p>我们考虑哪些数和n互质，所有n的质因子的倍数都和n互质，而且仅有这些数和n互质，所以我们需要把这些数都找出来。</p>\n<p>对于n的一个质因子p，有$n/p$个p的倍数，对于n的另一个质因子q，有$n/q$个q的倍数，把这些都减掉之后，还要加上既是p的倍数，又是q的倍数的数，于是要加上$n/pq$，这样，对于只含有两个质因子p、q的n来说，$\\varphi(n) = n-n/p-n/q+n/pq =(n-n/p)-1/q(n-n/p) = n(1-1/q)(1-1/p)$。</p>\n<p>把这个性质推广到$n = p_1^{c_1}p_2^{c_2}\\cdot \\cdot \\cdot p_m^{c_m}$，可以得到：</p>\n<p>性质1：$\\varphi(n) = n(1-\\frac{1}{p_1})\\cdot\\cdot\\cdot (1-\\frac{1}{p_m})$。</p>\n<p>性质2：当$n&gt;1$时，与n互质的数的和为$n/2\\cdot\\varphi(n)$。</p>\n<p>证明：若c是n的约数，那么n-c也是n的约数，所以与n不互质的数成对出现，和都为n，那么平均值就是$n/2$，所以和n互质的数的平均值也是$n/2$，于是与n互质的数的和就是$n/2\\cdot\\varphi(n)$。</p>\n<p>性质3：若$a,b$互质，那么$\\varphi(ab) = \\varphi(a)\\cdot\\varphi(b)$。</p>\n<p>证明：直接按定义式计算即可。</p>\n<p>虽然这个性质看上去比较显然，但是由此我们可以引出一个重要的东西：积性函数。</p>\n<p>如果当a和b互质时，有$f(ab) = f(a)\\cdot f(b)$，那么称函数$f(x)$为积性函数。</p>\n<p>性质4：对于所有积性函数$f(x)$，$f(n) = \\Pi_{i=1}^mf(p_i^{c_i})$，此处$p_i$和$c_i$是n按照算数基本定理分解出来的质因数和对应的幂。</p>\n<p>证明：因为对于任意两个不相同的$p_i$来说，它们肯定互质，所以可以按照积性函数的性质乘起来，之后就得到了n。</p>\n<p>性质5：若$p|n$且$p^2|n$，则$\\varphi(n) = \\varphi(n/p)\\cdot p$，这个可以由定义得到。</p>\n<p>性质6：若$p|n$且$p^2\\nmid n$，则$\\varphi(n) = \\varphi(n/p)\\cdot p\\cdot \\frac{p-1}{p} = \\varphi(n)\\cdot(p-1)$。</p>\n<p>性质7：$\\sum_{d\\mid n}\\varphi(d) = n$。</p>\n<p>证明：好像还不会证。。。</p>\n","tags":["Knowledge","数学"]},{"title":"网络流初步","url":"/2022/03/07/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%88%9D%E6%AD%A5/","content":"<h2 id=\"求解最大流\"><a href=\"#求解最大流\" class=\"headerlink\" title=\"求解最大流\"></a>求解最大流</h2><h3 id=\"Edmond-Karp算法（EK算法）\"><a href=\"#Edmond-Karp算法（EK算法）\" class=\"headerlink\" title=\"Edmond Karp算法（EK算法）\"></a>Edmond Karp算法（EK算法）</h3><p>这种算法不是很常用，但是比较好理解，没有什么分层图之类的优化技巧，可以直接感性理解求解网络流问题的基本思想。此算法复杂度为$O(nm^2)$，虽说很多时候卡不满，但是和SPFA一样，<strong>有被不经意间（刻意）卡掉的风险</strong>。</p>\n<span id=\"more\"></span>\n<p>首先，我们要知道什么是一个<strong>网络</strong>。其实是给你一张图，其中有一个<strong>源点</strong>$s$，一个<strong>汇点</strong>$t$，源点负责发放流量，汇点负责收集流量，网络中的边都有<strong>流量限制</strong>，也就是说经过这条边的流量不能超过这个限制。我们要的是到达汇点的流量最大。其中源点供应的流量是无限的。</p>\n<p>遍历整个图，每次尝试寻找一条<strong>增广路</strong>（一条从$s$到$t$的路径，其中所有边的剩余流量都大于$0$），在找不到增广路时就找到了<strong>最大流</strong>。每找到一条增广路，我们就把这条路的所有边的剩余容量减少，表示有流从这里经过。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/flow1.png\" alt=\"\"></p>\n<p>我们先走$4 \\rightarrow 2 \\rightarrow3$，这样有20的流量从$2$到达$3$，我们将$4\\rightarrow2\\rightarrow3$这条增广路的剩余流量修改一下，$4\\rightarrow2$变成$10$，$2\\rightarrow3$变成$0$，这样我们就得到了一个<strong>残量网络</strong>（即已经有部分流量被占用了）。再走$4\\rightarrow3$，$4\\rightarrow3$修改为$0$。走$4\\rightarrow2\\rightarrow1\\rightarrow3$，由于最小的边是$4\\rightarrow2$，所以只有$10$的流量流到$3$。</p>\n<p>于是，我们就得到了这个网络的最大流量：$50$。</p>\n<p>但是，随便找一条增广路就是最优的吗，显然不是：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/1.png\" alt=\"\"></p>\n<p>如上图，每条边的容量都是$1$，那么我们随便选一个增广路：$s\\rightarrow1\\rightarrow2\\rightarrow t$，这样我们就得到了$1$的流量，但是$s\\rightarrow2$和$1\\rightarrow t$都流不了任何东西了。</p>\n<p>换一种选法：$s\\rightarrow1\\rightarrow t$和$s\\rightarrow2\\rightarrow t$，这样我们就可以得到$2$的流量，比之前瞎选的优。</p>\n<p>如果不能瞎选，该如何解决这种问题呢？</p>\n<p>由于网络有很多种，我们显然不能针对每种情况都设计一个算法，使得每次选择的路径都是最优的，更好的方法是不断尝试，逐渐把不优的替换掉，而这种替换需要一个反悔的工具：<strong>反向边</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/bowenOne580/MyImages/img/2.png\" style=\"zoom:67%;\" /></p>\n<p>我们再次从$s$开始寻找增广路，可以从$s\\rightarrow2\\rightarrow1\\rightarrow t$，这样就可以得到最大流量$2$了。</p>\n<p>但这样为什么是对的呢？</p>\n<p>这一次走了从$2\\rightarrow1$的反向边，可以看作$1$原来流到$2$的流回去了（反向边相当于把流送回去），再流向之后走的$1\\rightarrow t$，而原来流向$2\\rightarrow t$的流量由$s\\rightarrow2$提供，这样就可以得到一条增广路了。当没有增广路时，说明我们找到了最大流（虽然我并不会证明这个的正确性）。</p>\n<p>时间复杂度简易证明：</p>\n<p>假设网络上有$n$个点，$m$条边。</p>\n<p>第一个结论：在EK算法中，$t$和$s$间的最短路长度一定是不降的，因为每次增广一个路径，这个路径按照$BFS$是最短的路径，所以每次必然减少一个最短路径，我们考虑最坏的情况，变成一个二分图之类的东西，最短路的长度都为$3$，这时需要增广$m$次，也就是说最短路的长度不变时，最多增广$m$次。</p>\n<p>第二个结论：每次$BFS$的时间复杂度为$O(m)$。</p>\n<p>第三个结论：每次增广中必然出现一个边，其剩余流量被完全占用，这条边要再有流量，需要反向边被增广，也就是说它再有剩余流量时，肯定是$t$和$s$之间的最短距离增加$2$时，才能被再次增广。由于一共只有$n$个点，最短路的长度最大是$n$，改变次数最多为$n/2$次。</p>\n<p>综合一、三结论，可得增广复杂度最多为$O(nm)$，而每次增广的复杂度最多时$O(m)$，所以EK算法的时间复杂度是$O(nm^2)$。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,tim = <span class=\"number\">1</span>,vis[N],inc[N],pre[N],Max;</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\tq.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">\tvis[s] = tim;</span><br><span class=\"line\">\tinc[s] = inf;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; vis[y]!=tim)&#123;</span><br><span class=\"line\">\t\t\t\tinc[y] = <span class=\"built_in\">min</span>(inc[x],edge[i].w);</span><br><span class=\"line\">\t\t\t\tpre[y] = i;</span><br><span class=\"line\">\t\t\t\tvis[y] = tim;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = t,incf = inc[t];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (now!=s)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> i = pre[now];</span><br><span class=\"line\">\t\tedge[i].w-=incf;</span><br><span class=\"line\">\t\tedge[i^<span class=\"number\">1</span>].w+=incf;</span><br><span class=\"line\">\t\tnow = edge[i^<span class=\"number\">1</span>].to;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tMax+=incf;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,w;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,w);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">\t\ttim++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">update</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;Max&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"Dinic算法\"><a href=\"#Dinic算法\" class=\"headerlink\" title=\"Dinic算法\"></a>Dinic算法</h3><p>主要思想：</p>\n<p>先做一次BFS将图按到$s$的最短路长度分层，之后做一次DFS（每次增广时可以多路增广），每次只向最短路长度比它大$1$的点输出流量，这样找下去，直到$t$到$s$没有路径，说明没有增广路了，也就是找到了最大流。</p>\n<p>时间复杂度证明：</p>\n<p>第一个结论：每次增广，必然把所有能够增广的都增广了，也就是说$t$到$s$的最短路的长度至少增加$1$，最多增加$n$次</p>\n<p>第二个结论：每次$BFS$，时间复杂度为$O(m)$，每次$DFS$，我们都要维护一个当前弧，也就是说当前弧最多变化$nm$次，于是单次增广的时间复杂度最大为$O(nm)$</p>\n<p>综合一、二结论，Dinic算法的时间复杂度最大为$O(n^2m)$</p>\n<p>也就是说，它适合处理稠密图，但在$n$是$1e3$级别，$m$是$1e5$级别，Dinic算法可能无法在给定时间内处理所有情况，这时就需要用到HLPP了。</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>,inf = <span class=\"number\">0x7fffffff</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,s,t,head[N],tot = <span class=\"number\">1</span>,d[N],now[N];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> ans;</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(d,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(d));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(s);</span><br><span class=\"line\">\td[s] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\tnow[s] = head[s];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; !d[y])&#123;</span><br><span class=\"line\">\t\t\t\tq.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">\t\t\t\td[y] = d[x]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\tnow[y] = head[y];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (y == t) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> flow)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (u == t) <span class=\"keyword\">return</span> flow;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v,use,res = flow,i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=now[u];i &amp;&amp; res;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\tnow[u] = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (edge[i].w &amp;&amp; d[v] == d[u]+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tuse = <span class=\"built_in\">dfs</span>(v,<span class=\"built_in\">min</span>(edge[i].w,res));</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!use) d[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tedge[i].w-=use;</span><br><span class=\"line\">\t\t\tedge[i^<span class=\"number\">1</span>].w+=use;</span><br><span class=\"line\">\t\t\tres-=use;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> flow-res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,w;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(x,y,w);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(y,x,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> flow;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">bfs</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tflow = <span class=\"built_in\">dfs</span>(s,inf);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!flow) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tans+=flow;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","网络流"]},{"title":"约数个数和 题解","url":"/2022/05/29/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"约数个数和-题解\"><a href=\"#约数个数和-题解\" class=\"headerlink\" title=\"约数个数和 题解\"></a>约数个数和 题解</h1><h2 id=\"Rating-For-advancer\"><a href=\"#Rating-For-advancer\" class=\"headerlink\" title=\"Rating: For advancer\"></a>Rating: For advancer</h2><p>这篇题解是首个版本，可能会有部分不严谨的地方，有些方法还没有想过，但是足以指导您做出此题。</p>\n<h2 id=\"题目大意：\"><a href=\"#题目大意：\" class=\"headerlink\" title=\"题目大意：\"></a>题目大意：</h2><p>$\\sum_{i=1}^n\\sum_{j=1}^md(ij)$，其中$d(x)$表示$x$的约数个数。</p>\n<h2 id=\"引理1：\"><a href=\"#引理1：\" class=\"headerlink\" title=\"引理1：\"></a>引理1：</h2><p>$d(ij) = \\sum_{p|i}\\sum_{q|j}[\\gcd(p,q) = 1]$</p>\n<h3 id=\"证明：\"><a href=\"#证明：\" class=\"headerlink\" title=\"证明：\"></a>证明：</h3><p>使用反证法。设有两个约数$i,j$，满足$\\gcd(i,j) = d(d\\neq 1)$。</p>\n<span id=\"more\"></span>\n<p>显然，$\\gcd(\\frac{i}{d},jd) = 1$，且$\\frac{i}{d}\\cdot jd = i\\cdot j$。</p>\n<p>于是，$\\gcd(i,j)\\neq 1$的$i,j$没有贡献。</p>\n<p>这其实算性质吧，但是我感觉没见过不是很好往这个方向推。</p>\n<p>总之，要求的式子转化成了：</p>\n<p>$\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{p|i}\\sum_{q|j}[\\gcd(p,q) = 1]$</p>\n<p>这里的$p,q$不是很好处理，考虑把它们提出来：</p>\n<p>$\\sum_{p=1}^n\\sum_{q=1}^m[\\gcd(p,q) = 1] \\lfloor \\frac{n}{p}\\rfloor \\lfloor \\frac{m}{q}\\rfloor$</p>\n<p>之后用反演结论：</p>\n<p>$\\sum_{p=1}^n\\sum_{q=1}^m\\lfloor \\frac{n}{p}\\rfloor \\lfloor \\frac{m}{q} \\rfloor\\sum_{k|\\gcd(p,q)}\\mu(k)$</p>\n<p>枚举$\\gcd$：</p>\n<p>$\\sum_{k=1}^{\\min(n,m)}\\mu(k)\\sum_{k|p,p\\leq n}\\sum_{k|q,q\\leq m}\\lfloor \\frac{n}{p}\\rfloor \\lfloor \\frac{m}{q}\\rfloor$</p>\n<p>发现中间两个求和等价于</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=k;p&lt;=n;p+=k)</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> q=k;q&lt;=m;q+=k)</span><br></pre></td></tr></table></figure>\n<p>于是可以设$p’ = \\frac{p}{k}$，$q’ = \\frac{q}{k}$，将式子进一步化简：</p>\n<p>$\\sum_{k=1}^{min(n,m)}\\mu(k)\\sum_{p’=1}^{\\frac{n}{k}}\\sum_{q’ = 1}^{\\frac{m}{k}}\\lfloor \\frac{n}{p’k}\\rfloor \\lfloor \\frac{m}{q’k}\\rfloor$</p>\n<p>由于$p’$相对固定，所以可以各回各家：</p>\n<p>$\\sum_{k=1}^{min(n,m)}\\mu(k)\\sum_{p’=1}^{\\frac{n}{k}}\\lfloor \\frac{n}{p’k}\\rfloor\\sum_{q’=1}^{\\frac{m}{k}}\\lfloor \\frac{m}{q’k}\\rfloor$</p>\n<p>用三次整除分块！但是数据太多，过不了。</p>\n<p>既然有多组数据，就意味着要预处理出一些值才能快速处理每组数据。</p>\n<p>发现，后面两个求和的形式很相像，把它抽象出来：</p>\n<p>$\\sum_{i=1}^{\\frac{a}{b}}\\lfloor \\frac{a}{b\\cdot c}\\rfloor$</p>\n<h2 id=\"引理2：\"><a href=\"#引理2：\" class=\"headerlink\" title=\"引理2：\"></a>引理2：</h2><p>$\\lfloor \\frac{a}{b\\cdot c}\\rfloor = \\lfloor \\frac{\\lfloor \\frac{a}{c}\\rfloor}{b}\\rfloor$</p>\n<h3 id=\"证明：-1\"><a href=\"#证明：-1\" class=\"headerlink\" title=\"证明：\"></a>证明：</h3><p>设$a = kc+r(r&lt;c)$，则$\\lfloor \\frac{kc+r}{b\\cdot c}\\rfloor \\iff \\lfloor \\frac{k}{b}+\\frac{r}{b\\cdot c}\\rfloor$，$\\lfloor \\frac{\\lfloor \\frac{a}{c}\\rfloor}{b}\\rfloor\\ \\iff \\lfloor \\frac{\\lfloor k+\\frac{r}{c}\\rfloor}{b}\\rfloor \\iff \\lfloor \\frac{k}{b}\\rfloor$。</p>\n<p>在题目中，所有的$b$都是正整数，所以$\\frac{r}{b\\cdot c}&lt; 1$，即左右两边相等。</p>\n<p>于是，我们转化为了下面的式子：</p>\n<p>$\\sum_{i=1}^x\\lfloor \\frac{x}{i}\\rfloor$</p>\n<p>这可以用整除分块$O(n\\sqrt n)$求出。</p>\n<p>这样，每次询问就可以用整除分块求出$\\frac{n}{k}$相等的部分，$O(\\sqrt n)$求解。</p>\n<p>总时间复杂度为$O(n\\sqrt n+T\\sqrt n)$，可以通过本题。</p>\n<h2 id=\"Code：\"><a href=\"#Code：\" class=\"headerlink\" title=\"Code：\"></a>Code：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,m,vis[N],pri[N],tot,mu[N],sum[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> lim = <span class=\"number\">5e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) mu[i]+=mu[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>;l&lt;=i;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tr = i/(i/l);</span><br><span class=\"line\">\t\t\tsum[i]+=(r-l+<span class=\"number\">1</span>)*(i/l);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> Min = <span class=\"built_in\">min</span>(n,m),r,ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>;l&lt;=Min;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tr = <span class=\"built_in\">min</span>(n/(n/l),m/(m/l));</span><br><span class=\"line\">\t\t\tans+=(mu[r]-mu[l<span class=\"number\">-1</span>])*sum[n/l]*sum[m/l];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout&lt;&lt;ans&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","数学","数论","莫比乌斯反演","整除分块"]},{"title":"线段树优化建图","url":"/2023/02/01/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE/","content":"<h1 id=\"线段树优化建图\"><a href=\"#线段树优化建图\" class=\"headerlink\" title=\"线段树优化建图\"></a>线段树优化建图</h1><h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>有一些题目，需要我们从某个点向一个区间中的所有点连边，这时一个一个连必然超时。</p>\n<p>注意到这些区间都是连续的，我们仿照线段树的思想，把它们分成 $\\log n$ 段，这样就只用向这 $\\log n$ 个区间连边了。</p>\n<span id=\"more\"></span>\n<h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><p><a href=\"https://www.luogu.com.cn/problem/CF786B\">Legacy</a></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>说一下具体的实现方法。</p>\n<p>假设你有两棵线段树，代表我们分的区间。</p>\n<p>你可以把两棵线段树理解为一条有向边的出发点和结束点，我们每次从出发点所在的线段树（第 $2$ 棵），向结束点在的线段树（第 $1$ 棵）连边即可。</p>\n<p>操作 $1$ 就是叶子节点连边，因为到了叶子节点，这个区间就成了一个点，我们从第 $2$ 棵向第 $1$ 棵连边，就相当于点对点连边。</p>\n<p>第 $2$ 棵中的叶子节点向第 $1$ 棵里面组成一个区间的所有子区间连边，就代表这个点到区间内的所有点都连了一条边，对应操作 $2$。</p>\n<p>第 $2$ 棵中组成一个区间的所有子区间向第 $1$ 棵连边，就是操作 $3$ 了。</p>\n<p>但是，我们只从所有子区间连边，并没有对这些子区间下面的点连边！</p>\n<p>我们可以让出发点线段树的儿子向父亲连边，结束点线段树的父亲向儿子连边，这样能保证从一个点出发，能走到它所在的区间再出发，走到一个结束点区间后，能到达具体的某一个点。</p>\n<p>但是，如果我们仅连这些边，那路径的长度最大只能为 $2$，因为所有的结束点都没有出边！</p>\n<p>为了避免这样的情况，我们还要在第 $1$ 棵线段树和第 $2$ 棵中相同的叶子节点之间连边，表示结束点转变为下一个出发点。</p>\n<p>连完之后，跑一遍最短路即可。</p>\n<p>不难发现，我们需要线段树提供的信息，只有节点编号，于是不用真的建出线段树，只需要对两棵线段树都标个号即可。</p>\n<p>由于线段树的节点数为 $n\\log n$ 级别，每次操作涉及的点数最大也是 $\\log n$ 级别，所以总空间复杂度为 $O(n\\log n)$，但是，由于我们还建了许多其他的边，并且有两棵线段树，建议真正用的时候开大一点，造极限数据看是否 RE。</p>\n<p>由于最后还要跑一个最短路，所以时间复杂度为 $O(n\\log^2n)$。</p>\n<h3 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> mp make_pair</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,qq,s,head[N*<span class=\"number\">45</span>],tot,dt[N][<span class=\"number\">2</span>],glv,vis[N*<span class=\"number\">45</span>],Max;</span><br><span class=\"line\">ll dis[N*<span class=\"number\">45</span>];</span><br><span class=\"line\">priority_queue&lt;pair&lt;ll,<span class=\"type\">int</span>&gt; &gt; q;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">70</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\tMax = <span class=\"built_in\">max</span>(Max,node);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">\t\tdt[l][<span class=\"number\">0</span>] = node;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>(node&lt;&lt;<span class=\"number\">1</span>,l,mid);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">add</span>(node,node&lt;&lt;<span class=\"number\">1</span>,<span class=\"number\">0</span>),<span class=\"built_in\">add</span>(node,node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">add</span>((node&lt;&lt;<span class=\"number\">1</span>)+Max,node+Max,<span class=\"number\">0</span>),<span class=\"built_in\">add</span>((node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>)+Max,node+Max,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(node&lt;&lt;<span class=\"number\">1</span>,l,mid);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateOut</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> beg,<span class=\"type\">int</span> en,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l&gt;en || r&lt;beg) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l&gt;=beg &amp;&amp; r&lt;=en)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(dt[glv][<span class=\"number\">1</span>],node,v);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">updateOut</span>(node&lt;&lt;<span class=\"number\">1</span>,l,mid,beg,en,v);</span><br><span class=\"line\">\t<span class=\"built_in\">updateOut</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r,beg,en,v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateIn</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> beg,<span class=\"type\">int</span> en,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l&gt;en || r&lt;beg) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l&gt;=beg &amp;&amp; r&lt;=en)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(node+Max,dt[glv][<span class=\"number\">0</span>],v);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">updateIn</span>(node&lt;&lt;<span class=\"number\">1</span>,l,mid,beg,en,v);</span><br><span class=\"line\">\t<span class=\"built_in\">updateIn</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r,beg,en,v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dij</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dis,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(dis));</span><br><span class=\"line\">\tq.<span class=\"built_in\">push</span>(<span class=\"built_in\">mp</span>(<span class=\"number\">0</span>,dt[s][<span class=\"number\">1</span>]));</span><br><span class=\"line\">\tdis[dt[s][<span class=\"number\">1</span>]] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = q.<span class=\"built_in\">top</span>().second,y;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (vis[x]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tvis[x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dis[y]&gt;dis[x]+edge[i].w)&#123;</span><br><span class=\"line\">\t\t\t\tdis[y] = dis[x]+edge[i].w;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!vis[y]) q.<span class=\"built_in\">push</span>(<span class=\"built_in\">mp</span>(-dis[y],y));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;qq&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) dt[i][<span class=\"number\">1</span>] = dt[i][<span class=\"number\">0</span>]+Max,<span class=\"built_in\">add</span>(dt[i][<span class=\"number\">0</span>],dt[i][<span class=\"number\">1</span>],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> op,v,l,r,w;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=qq;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;op;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;v&gt;&gt;l&gt;&gt;w;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(dt[v][<span class=\"number\">1</span>],dt[l][<span class=\"number\">0</span>],w);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (op == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;v&gt;&gt;l&gt;&gt;r&gt;&gt;w;</span><br><span class=\"line\">\t\t\tglv = v;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">updateOut</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r,w);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;v&gt;&gt;l&gt;&gt;r&gt;&gt;w;</span><br><span class=\"line\">\t\t\tglv = v;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">updateIn</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r,w);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dij</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cout&lt;&lt;(dis[dt[i][<span class=\"number\">1</span>]] == <span class=\"number\">0x3f3f3f3f3f3f3f3f</span>?<span class=\"number\">-1</span>:dis[dt[i][<span class=\"number\">1</span>]])&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例2\"><a href=\"#例2\" class=\"headerlink\" title=\"例2\"></a>例2</h2><p><a href=\"https://www.luogu.com.cn/problem/P5025\">P5025 [SNOI2017]炸弹</a></p>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>我们把每个炸弹向能引爆的炸弹连边，不考虑连锁引爆。显然能被引爆的炸弹是在一个范围内的，所以可以用线段树优化建图。</p>\n<p>最好把这个图变成 DAG，方便统计。直接在原图上缩点，是对的吗？</p>\n<p>假设真正的图上，有一个连通块，任意两点都可以相互到达。</p>\n<p>现在，我们从这个连通块的一个叶子节点出发，想到达另一个叶子节点，显然也是可以的。</p>\n<p>由于我们所有操作都是一个点到一个区间的连边，所以不需要建两棵线段树，只需要从 $n$ 个初始点向线段树上的点连边即可。</p>\n<p>缩点之后成了 DAG。我们就是要求每个点经过的点个数。</p>\n<p>虽然没有什么好的办法能统计 DAG 中每个点经过的点数，但是这道题中，经过的点必然是一个区间内的所有点，我们只需要维护左端点和右端点即可。</p>\n<p>码量可能有点大，但是基本上就是板子集合。</p>\n<h3 id=\"思路-2\"><a href=\"#思路-2\" class=\"headerlink\" title=\"思路\"></a>思路</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e5</span>+<span class=\"number\">10</span>,mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,dt[N][<span class=\"number\">2</span>],head[N*<span class=\"number\">23</span>],tot,dfn[N*<span class=\"number\">23</span>],low[N*<span class=\"number\">23</span>],cnt,sta[N*<span class=\"number\">23</span>],ins[N*<span class=\"number\">23</span>],tp,scc,c[N*<span class=\"number\">23</span>],indeg[N*<span class=\"number\">23</span>],tf[N*<span class=\"number\">23</span>],L[N*<span class=\"number\">23</span>],R[N*<span class=\"number\">23</span>];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[N*<span class=\"number\">23</span>];</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; g[N*<span class=\"number\">23</span>];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,fro;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">24</span>];</span><br><span class=\"line\">ll a[N],b[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].fro = x;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">\t\tdt[l][<span class=\"number\">0</span>] = node+n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">add</span>(node+n,(node&lt;&lt;<span class=\"number\">1</span>)+n);</span><br><span class=\"line\">\t<span class=\"built_in\">add</span>(node+n,(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>)+n);</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(node&lt;&lt;<span class=\"number\">1</span>,l,mid);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateOut</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> beg,<span class=\"type\">int</span> en,<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l&gt;en || r&lt;beg) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l&gt;=beg &amp;&amp; r&lt;=en)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(u,node+n);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">updateOut</span>(node&lt;&lt;<span class=\"number\">1</span>,l,mid,beg,en,u);</span><br><span class=\"line\">\t<span class=\"built_in\">updateOut</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r,beg,en,u);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tdfn[u] = low[u] = ++cnt;</span><br><span class=\"line\">\tsta[++tp] = u,ins[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!dfn[v])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t\t\tlow[u] = <span class=\"built_in\">min</span>(low[u],low[v]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ins[v]) low[u] = <span class=\"built_in\">min</span>(low[u],dfn[v]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dfn[u] == low[u])&#123;</span><br><span class=\"line\">\t\tscc++;</span><br><span class=\"line\">\t\tL[scc] = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tv = sta[tp],tp--,ins[v] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tc[v] = scc;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tf[v]) L[scc] = <span class=\"built_in\">min</span>(L[scc],tf[v]),R[scc] = <span class=\"built_in\">max</span>(R[scc],tf[v]);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (v == u) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=scc;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!indeg[i]) q.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(g[i].<span class=\"built_in\">begin</span>(),g[i].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> siz = g[x].<span class=\"built_in\">size</span>(),y;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;siz;i++)&#123;</span><br><span class=\"line\">\t\t\ty = g[x][i];</span><br><span class=\"line\">\t\t\tindeg[y]--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!indeg[y]) q.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i &amp;&amp; g[x][i] == g[x][i<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tL[y] = <span class=\"built_in\">min</span>(L[y],L[x]);</span><br><span class=\"line\">\t\t\tR[y] = <span class=\"built_in\">max</span>(R[y],R[x]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i]&gt;&gt;b[i],dt[i][<span class=\"number\">1</span>] = i;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"built_in\">add</span>(dt[i][<span class=\"number\">0</span>],dt[i][<span class=\"number\">1</span>]),tf[dt[i][<span class=\"number\">0</span>]] = tf[dt[i][<span class=\"number\">1</span>]] = i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l = <span class=\"built_in\">lower_bound</span>(a+<span class=\"number\">1</span>,a+<span class=\"number\">1</span>+n,a[i]-b[i])-a,r = <span class=\"built_in\">upper_bound</span>(a+<span class=\"number\">1</span>,a+<span class=\"number\">1</span>+n,a[i]+b[i])-a<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">updateOut</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,l,r,i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!dfn[i]) <span class=\"built_in\">dfs</span>(i,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = c[edge[i].fro],y = c[edge[i].to];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == y || !x || !y) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tg[y].<span class=\"built_in\">pb</span>(x),indeg[x]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">bfs</span>();</span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) ans = (ans+<span class=\"number\">1ll</span>*(R[c[i]]-L[c[i]]+<span class=\"number\">1</span>)*i%mod)%mod;</span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例3\"><a href=\"#例3\" class=\"headerlink\" title=\"例3\"></a>例3</h2><p><a href=\"https://www.luogu.com.cn/problem/P3588\">P3588 [POI2015] PUS</a></p>\n<h3 id=\"思路-3\"><a href=\"#思路-3\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>这种大小关系可以用边限制，一个点向另一个点连边，就代表这个点比那个点大。</p>\n<p>我们可以建一个虚点，从这 $k$ 个点连向它，之后连接剩下的 $k+1$ 个区间，这样就可以了。</p>\n<p>再加入初始的限制。</p>\n<p>但是，判断无解并不等于判环，因为还有一开始给出的点值。</p>\n<p>我们发现，连一条边，代表终点的值至少要比起点的值少 $1$，贪心的想，只 $-1$ 显然是最优的，其他的辅助边没啥影响，边权可以设成 $0$。</p>\n<p>把这两个判掉就行了。</p>\n<h3 id=\"Code-1\"><a href=\"#Code-1\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,s,m,b[N],head[N*<span class=\"number\">45</span>],tot,dt[N][<span class=\"number\">2</span>],Max,indeg[N*<span class=\"number\">45</span>],dis[N*<span class=\"number\">45</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">aa</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p,d;</span><br><span class=\"line\">&#125; a[N];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[N*<span class=\"number\">50</span>];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">\tindeg[y]++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(aa x,aa y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x.d&lt;y.d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\tMax = <span class=\"built_in\">max</span>(Max,node+n);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r)&#123;</span><br><span class=\"line\">\t\tdt[l][<span class=\"number\">0</span>] = node+n;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">add</span>(node+n,(node&lt;&lt;<span class=\"number\">1</span>)+n,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">add</span>(node+n,(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>)+n,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(node&lt;&lt;<span class=\"number\">1</span>,l,mid);</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">updateIn</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> beg,<span class=\"type\">int</span> en,<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l&gt;en || r&lt;beg) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l&gt;=beg &amp;&amp; r&lt;=en)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(u,node+n,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">updateIn</span>(node&lt;&lt;<span class=\"number\">1</span>,l,mid,beg,en,u);</span><br><span class=\"line\">\t<span class=\"built_in\">updateIn</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r,beg,en,u);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">topo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=Max;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!indeg[i]) q.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">\t\tdis[i] = <span class=\"number\">1e9</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=s;i++) dis[dt[a[i].p][<span class=\"number\">0</span>]] = a[i].d;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = q.<span class=\"built_in\">front</span>(),y;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\tdis[y] = <span class=\"built_in\">min</span>(dis[y],dis[x]-edge[i].w);</span><br><span class=\"line\">\t\t\tindeg[y]--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!indeg[y]) q.<span class=\"built_in\">push</span>(y);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;s&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=s;i++) cin&gt;&gt;a[i].p&gt;&gt;a[i].d;</span><br><span class=\"line\">\t<span class=\"built_in\">build</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) dt[i][<span class=\"number\">1</span>] = i,<span class=\"built_in\">add</span>(dt[i][<span class=\"number\">0</span>],dt[i][<span class=\"number\">1</span>],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> l,r,k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;l&gt;&gt;r&gt;&gt;k;</span><br><span class=\"line\">\t\tMax++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=k;j++)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;b[j];</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(b[j],Max,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> las = l;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=k;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (las&gt;b[j]<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t\tlas = b[j]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">updateIn</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,las,b[j]<span class=\"number\">-1</span>,Max);</span><br><span class=\"line\">\t\t\tlas = b[j]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (las&lt;=r) <span class=\"built_in\">updateIn</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n,las,r,Max);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">topo</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=Max;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (indeg[i] || dis[i]&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tflag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=s;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dis[dt[a[i].p][<span class=\"number\">0</span>]]!=a[i].d) flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (flag)&#123;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;TAK\\n&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cout&lt;&lt;dis[dt[i][<span class=\"number\">0</span>]]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;NIE\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例4\"><a href=\"#例4\" class=\"headerlink\" title=\"例4\"></a>例4</h2><p><a href=\"https://www.luogu.com.cn/problem/P5471\">P5471 [NOI2019] 弹跳</a></p>\n<h3 id=\"思路-4\"><a href=\"#思路-4\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>subtask 1 提示我们只要把图建完，跑一遍最短路即可。</p>\n<p>subtask 2 也很水。</p>\n<p>subtask 3 中，是一条链，想到了线段树优化建图。</p>\n<p>于是，可以扩展一下，维护一棵二维线段树，即可解决问题。</p>\n<p>但是，直接维护，空间太大，加上最短路，时间复杂度也相应的来到了恐怖的 $O(\\log^3n)$。</p>\n<p>我们发现，如果普通的在第一维维护 $x$ 坐标，第二维维护 $y$ 坐标，每次有可能遍历到所有的 $n$ 个点。</p>\n<p>但是，这 $n$ 个点中，并不是所有点都有用！</p>\n<p>根据 Dijstra 算法的思想，我们每次都从最短的点扩展，这样它就不会再被扩展了，也就是说，这个点就没用了。</p>\n<p>所以，我们需要及时删除访问过的点。</p>\n<p>我们发现，set 可以很好的支持以上操作。</p>\n<p>而且，每次插入一个点时，我们只会把它插入到 $\\log n$ 个 set 中，虽然 set 的空间复杂度是 $O(n\\log n)$ 级别的，也就是线段树套 set 这整个数据结构的空间复杂度是 $O(n\\log^2n)$，但是，我们每次只用从 set 中取出一个点，而不是 $\\log n$ 个点，每个点最多被取出和删除一次，所以总访问点数就是 $O(n\\log n)$，而最短路的时间复杂度是和总访问点数相关的，所以总时间复杂度是 $O(n\\log^2n)$。</p>\n<p>还有一个细节，就是我们不要在求最短路时存点，而是变成存边，因为一个点在被访问之后会被删掉，不方便进行之后的枚举出边操作。</p>\n<h3 id=\"Code-2\"><a href=\"#Code-2\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pb push_back</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1.5e5</span>+<span class=\"number\">10</span>,M = <span class=\"number\">7e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,w,h,dis[M];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">citis</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,id;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span> &lt;(citis a) <span class=\"type\">const</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> y == a.y?id&lt;a.id:y&lt;a.y;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; a[M];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p,t,l,r,d,u;</span><br><span class=\"line\">&#125; edge[N];</span><br><span class=\"line\">set&lt;citis&gt; s[M*<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">aa</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,v;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span> &lt;(aa a) <span class=\"type\">const</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v&gt;a.v;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; x;</span><br><span class=\"line\">priority_queue&lt;aa&gt; q;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; g[M];</span><br><span class=\"line\">queue&lt;<span class=\"type\">int</span>&gt; tag;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> pos,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\ts[node].<span class=\"built_in\">insert</span>(a[v]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pos&lt;=mid) <span class=\"built_in\">update</span>(node&lt;&lt;<span class=\"number\">1</span>,l,mid,pos,v);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">update</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r,pos,v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ers</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> pos,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\ts[node].<span class=\"built_in\">erase</span>(a[v]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (pos&lt;=mid) <span class=\"built_in\">ers</span>(node&lt;&lt;<span class=\"number\">1</span>,l,mid,pos,v);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"built_in\">ers</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r,pos,v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">del</span><span class=\"params\">(<span class=\"type\">int</span> node,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,<span class=\"type\">int</span> id,<span class=\"type\">int</span> v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> beg = edge[id].l,en = edge[id].r;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l&gt;en || r&lt;beg) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l&gt;=beg &amp;&amp; r&lt;=en)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> it = s[node].<span class=\"built_in\">lower_bound</span>(&#123;<span class=\"number\">0</span>,edge[id].d,<span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (;it!=s[node].<span class=\"built_in\">end</span>() &amp;&amp; it-&gt;y&lt;=edge[id].u;it++)&#123;</span><br><span class=\"line\">\t\t\tdis[it-&gt;id] = v,tag.<span class=\"built_in\">push</span>((*it).id);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x:g[it-&gt;id]) q.<span class=\"built_in\">push</span>(&#123;x,v+edge[x].t&#125;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!tag.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> x = tag.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\t\t\ttag.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">ers</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,w,a[x].x,x);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = (l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">del</span>(node&lt;&lt;<span class=\"number\">1</span>,l,mid,id,v);</span><br><span class=\"line\">\t<span class=\"built_in\">del</span>(node&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r,id,v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;w&gt;&gt;h;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class=\"line\">\t\ta[i].id = i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i!=<span class=\"number\">1</span>) <span class=\"built_in\">update</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,w,a[i].x,i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;edge[i].p&gt;&gt;edge[i].t&gt;&gt;edge[i].l&gt;&gt;edge[i].r&gt;&gt;edge[i].d&gt;&gt;edge[i].u;</span><br><span class=\"line\">\t\tg[edge[i].p].<span class=\"built_in\">pb</span>(i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (edge[i].p == <span class=\"number\">1</span>) q.<span class=\"built_in\">push</span>(&#123;i,edge[i].t&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\tx = q.<span class=\"built_in\">top</span>(),q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"built_in\">del</span>(<span class=\"number\">1</span>,<span class=\"number\">1</span>,w,x.x,x.v);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++) cout&lt;&lt;dis[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"例5\"><a href=\"#例5\" class=\"headerlink\" title=\"例5\"></a>例5</h2><p><a href=\"https://www.luogu.com.cn/problem/P5344\">P5344 【XR-1】逛森林</a></p>\n<h3 id=\"思路-5\"><a href=\"#思路-5\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>考虑到没有连通，一条边就没有了，所以可以预处理出哪些边是存在的，用并查集维护连通性即可。</p>\n<p>现在，就是如何将一条路径上的所有点连到另一条路径上去。</p>\n<p>我们可以建一个虚点，之后把这些点都连到虚点上去，但是点数仍然可能很大。</p>\n<p>考虑把路径拆成 $u\\rightarrow lca$ 和 $v\\rightarrow lca$。</p>\n<p>我们在跳祖先时，可以对每一跳建立一个节点，像线段树那样把倍增数组上的节点连起来，就可以了。</p>\n<p>总点数为 $O(n\\log n)$，总边数为 $O((n+m)\\log n)$，勉强通过。</p>\n<p>我们发现，其实重边对答案不会有影响，因为边权都是 $0$，只要保证虚点能够访问到区间内的点即可，所以可以用 RMQ 中的思想，只连 $u/v$ 和 $lca$ 的倍增数组节点，边数降低为 $O(n\\log n+m)$。</p>\n<p>具体写起来要点时间，而且空间十分玄学。</p>\n<h3 id=\"Code-3\"><a href=\"#Code-3\" class=\"headerlink\" title=\"Code\"></a>Code</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> mp make_pair</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">5e4</span>+<span class=\"number\">10</span>,M = <span class=\"number\">1e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,s,head[N*<span class=\"number\">65</span>],tot,f[N],st[N][<span class=\"number\">17</span>],cnt,dep[N],dt[N][<span class=\"number\">17</span>][<span class=\"number\">2</span>],dis[N*<span class=\"number\">65</span>];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[N*<span class=\"number\">65</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">e</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> next,to,w;</span><br><span class=\"line\">&#125; edge[M*<span class=\"number\">16</span>];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">opr</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> op,u1,v1,u2,v2,w;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> ok;</span><br><span class=\"line\">&#125; a[M];</span><br><span class=\"line\">priority_queue&lt;pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; &gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x == f[x]) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> f[x] = <span class=\"built_in\">get</span>(f[x]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">int</span> w)</span></span>&#123;</span><br><span class=\"line\">\tedge[++tot].to = y;</span><br><span class=\"line\">\tedge[tot].next = head[x];</span><br><span class=\"line\">\tedge[tot].w = w;</span><br><span class=\"line\">\thead[x] = tot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> fa)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v;</span><br><span class=\"line\">\tvis[u] = <span class=\"number\">1</span>,st[u][<span class=\"number\">0</span>] = fa,dep[u] = dep[fa]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\tv = edge[i].to;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (v == fa) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(v,u);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcnt = n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!st[i][<span class=\"number\">0</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tdt[i][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = ++cnt; <span class=\"comment\">//入边 </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(dt[i][<span class=\"number\">0</span>][<span class=\"number\">0</span>],i,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(dt[i][<span class=\"number\">0</span>][<span class=\"number\">0</span>],st[i][<span class=\"number\">0</span>],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tdt[i][<span class=\"number\">0</span>][<span class=\"number\">1</span>] = ++cnt; <span class=\"comment\">//出边 </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(i,dt[i][<span class=\"number\">0</span>][<span class=\"number\">1</span>],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(st[i][<span class=\"number\">0</span>],dt[i][<span class=\"number\">0</span>][<span class=\"number\">1</span>],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">16</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\t\tst[j][i] = st[st[j][i<span class=\"number\">-1</span>]][i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!st[j][i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tdt[j][i][<span class=\"number\">0</span>] = ++cnt;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(dt[j][i][<span class=\"number\">0</span>],dt[j][i<span class=\"number\">-1</span>][<span class=\"number\">0</span>],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(dt[j][i][<span class=\"number\">0</span>],dt[st[j][i<span class=\"number\">-1</span>]][i<span class=\"number\">-1</span>][<span class=\"number\">0</span>],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\tdt[j][i][<span class=\"number\">1</span>] = ++cnt;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(dt[j][i<span class=\"number\">-1</span>][<span class=\"number\">1</span>],dt[j][i][<span class=\"number\">1</span>],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">add</span>(dt[st[j][i<span class=\"number\">-1</span>]][i<span class=\"number\">-1</span>][<span class=\"number\">1</span>],dt[j][i][<span class=\"number\">1</span>],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lca</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dep[x]&gt;dep[y]) <span class=\"built_in\">swap</span>(x,y);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">16</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (dep[st[y][i]]&lt;dep[x]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\ty = st[y][i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x == y) <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">16</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (st[x][i] == st[y][i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tx = st[x][i],y = st[y][i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> st[x][<span class=\"number\">0</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">calc1</span><span class=\"params\">(<span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = a[i].u1,y = a[i].v1,z = <span class=\"built_in\">lca</span>(x,y),k,tar;</span><br><span class=\"line\">\tcnt++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x!=z)&#123;</span><br><span class=\"line\">\t\tk = <span class=\"built_in\">log2</span>(dep[x]-dep[z]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(dt[x][k][<span class=\"number\">1</span>],cnt,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\ttar = dep[z]+(<span class=\"number\">1</span>&lt;&lt;k);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">16</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dep[st[x][i]]&gt;=tar) x = st[x][i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(dt[x][k][<span class=\"number\">1</span>],cnt,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (y!=z)&#123;</span><br><span class=\"line\">\t\tk = <span class=\"built_in\">log2</span>(dep[y]-dep[z]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(dt[y][k][<span class=\"number\">1</span>],cnt,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\ttar = dep[z]+(<span class=\"number\">1</span>&lt;&lt;k);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">16</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dep[st[y][i]]&gt;=tar) y = st[y][i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(dt[y][k][<span class=\"number\">1</span>],cnt,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x == y) <span class=\"built_in\">add</span>(x,cnt,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">calc2</span><span class=\"params\">(<span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x = a[i].u2,y = a[i].v2,z = <span class=\"built_in\">lca</span>(x,y),k,tar;</span><br><span class=\"line\">\tcnt++;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x!=z)&#123;</span><br><span class=\"line\">\t\tk = <span class=\"built_in\">log2</span>(dep[x]-dep[z]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(cnt,dt[x][k][<span class=\"number\">0</span>],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\ttar = dep[z]+(<span class=\"number\">1</span>&lt;&lt;k);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">16</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dep[st[x][i]]&gt;=tar) x = st[x][i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(cnt,dt[x][k][<span class=\"number\">0</span>],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (y!=z)&#123;</span><br><span class=\"line\">\t\tk = <span class=\"built_in\">log2</span>(dep[y]-dep[z]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(cnt,dt[y][k][<span class=\"number\">0</span>],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\ttar = dep[z]+(<span class=\"number\">1</span>&lt;&lt;k);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">16</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dep[st[y][i]]&gt;=tar) y = st[y][i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(cnt,dt[y][k][<span class=\"number\">0</span>],<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x == y) <span class=\"built_in\">add</span>(cnt,x,<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dij</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dis,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(dis));</span><br><span class=\"line\">\tq.<span class=\"built_in\">push</span>(<span class=\"built_in\">mp</span>(<span class=\"number\">0</span>,s));</span><br><span class=\"line\">\tdis[s] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x = q.<span class=\"built_in\">top</span>().second,y;</span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (vis[x]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\tvis[x] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=head[x];i;i = edge[i].next)&#123;</span><br><span class=\"line\">\t\t\ty = edge[i].to;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dis[y]&gt;dis[x]+edge[i].w)&#123;</span><br><span class=\"line\">\t\t\t\tdis[y] = dis[x]+edge[i].w;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!vis[y]) q.<span class=\"built_in\">push</span>(<span class=\"built_in\">mp</span>(-dis[y],y));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) f[i] = i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;a[i].op;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[i].op == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;a[i].u1&gt;&gt;a[i].v1&gt;&gt;a[i].u2&gt;&gt;a[i].v2&gt;&gt;a[i].w;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> x1 = <span class=\"built_in\">get</span>(a[i].u1),y1 = <span class=\"built_in\">get</span>(a[i].v1),x2 = <span class=\"built_in\">get</span>(a[i].u2),y2 = <span class=\"built_in\">get</span>(a[i].v2);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x1!=y1 || x2!=y2) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\ta[i].ok = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tcin&gt;&gt;a[i].u1&gt;&gt;a[i].v1&gt;&gt;a[i].w;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> x = <span class=\"built_in\">get</span>(a[i].u1),y = <span class=\"built_in\">get</span>(a[i].v1);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (x == y) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\tf[x] = y,<span class=\"built_in\">add</span>(a[i].u1,a[i].v1,a[i].w),<span class=\"built_in\">add</span>(a[i].v1,a[i].u1,a[i].w);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i]) <span class=\"built_in\">dfs</span>(i,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(<span class=\"type\">bool</span>)*(n+<span class=\"number\">10</span>));</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!a[i].ok) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">calc1</span>(i);</span><br><span class=\"line\">\t\t<span class=\"built_in\">calc2</span>(i);</span><br><span class=\"line\">\t\t<span class=\"built_in\">add</span>(cnt<span class=\"number\">-1</span>,cnt,a[i].w);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">dij</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cout&lt;&lt;(dis[i] == <span class=\"number\">0x3f3f3f3f</span>?<span class=\"number\">-1</span>:dis[i])&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","图论","线段树","优化建图"]},{"title":"线性代数入门","url":"/2022/11/04/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%85%A5%E9%97%A8/","content":"<h1 id=\"线性代数入门\"><a href=\"#线性代数入门\" class=\"headerlink\" title=\"线性代数入门\"></a>线性代数入门</h1><p>还在咕的内容：矩阵求逆，矩阵树定理，LGV 引理。</p>\n<h2 id=\"线性方程组\"><a href=\"#线性方程组\" class=\"headerlink\" title=\"线性方程组\"></a>线性方程组</h2><p>就是给你 $n$ 元 $1$ 次方程，让你解出每一个未知数。常见的做法是高斯消元。</p>\n<p>这里讲解更方便的高斯—约旦消元法，它有更好的精度，而且不用回带，代码简单，只是常数略大。</p>\n<span id=\"more\"></span>\n<h2 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h2><p><a href=\"https://www.luogu.com.cn/problem/P2455\">P2455 [SDOI2006]线性方程组</a></p>\n<p>消元的过程很简单：</p>\n<p>我们有 $n$ 个未知数，每次按顺序找到第一个没有进行消元的，在所有方程中找到系数最大的一个方程，把它放到我们现在处理到的方程的位置上（据说这样能增加精度）。</p>\n<p>之后，我们的目标变为把所有其他的方程的这一项系数都变成 $0$，想想初中是如何消元的：不就是把我们现在的方程整体乘上一个系数，再和其他的方程相减吗。</p>\n<p>由于我们是按顺序消元的，所以处理到这个方程，前面所有已消元的项，系数都是 $0$，和其他方程相减，不会影响答案。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> now = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> Max = now;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=now+<span class=\"number\">1</span>;j&lt;=n;j++) <span class=\"keyword\">if</span> (<span class=\"built_in\">fabs</span>(a[j][i])&gt;<span class=\"built_in\">fabs</span>(a[Max][i])) Max = j;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">fabs</span>(a[Max][i])&lt;eps) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(a[Max],a[now]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j == now) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">double</span> div = a[j][i]/a[now][i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=i;p&lt;=n+<span class=\"number\">1</span>;p++)&#123;</span><br><span class=\"line\">\t\t\ta[j][p]-=a[now][p]*div;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnow++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码就是我们刚刚消元的过程啦，但是，其中有一行我们还没有提及：第 $5$ 行。</p>\n<p>想象一下，如果你的方程组中，某一个未知数前面的系数都是 $0$，那这个未知数可以被解出吗？不行！</p>\n<p>这也就是第一种特殊情况：多解。</p>\n<p>判断起来很简单，只用判断 $now$ 是否等于 $n+1$ 即可。</p>\n<p>再看看这个方程组：</p>\n<p>$x = 1$</p>\n<p>$x = 2$</p>\n<p>我们尝试消元，于是得到：</p>\n<p>$0 = 1$</p>\n<p>显然，这个式子不成立，也就是说，这个方程无解。那么无解的情况就是左边都是 $0$，但是右边不为 $0$。</p>\n<p>判断也只用判断在我们还未进行消元的方程组中，是否有这样的情况即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (now&lt;=n)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=now;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">fabs</span>(a[i][n+<span class=\"number\">1</span>])&gt;eps)&#123; <span class=\"comment\">//判断是否为 0，需要避免精度误差，不能直接写 == 0</span></span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"number\">-1</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>; <span class=\"comment\">//无解</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>; <span class=\"comment\">//多解</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这就是最基本的高斯消元解线性方程组了。</p>\n<h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><p><a href=\"http://poj.org/problem?id=1830\">1830 — 开关问题</a></p>\n<p>其实，高斯消元除了能解加法方程组，还能解异或方程组。不过，我们先看怎么把这个问题转化成异或方程组。</p>\n<p>由于每个灯只能进行一次操作，所以我们可以用 $x_i$ 表示灯 $i$ 是否被操作。</p>\n<p>灯被操作后，还会给受它影响的灯带来影响，而且最终状态只有两种，这启示我们用异或表示灯的状态。</p>\n<p>设 $a[i][j]$ 表示 $j$ 的开关是否能影响 $i$，则可以列出下列方程组：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{equation}\n\\left\\{\n\\begin{aligned}\nstart_1\\oplus a_{1,1}x_1\\oplus a_{1,2}x_2\\cdots = end_1\\\\\nstart_2\\oplus a_{2,1}x_1\\oplus a_{2,2}x_2\\cdots = end_2\\\\\n\\cdots\n\\end{aligned}\n\\right.\n\\end{equation}</script><p>再左右同时异或 $start_i$，就变成了标准的异或方程组。</p>\n<p>解法也很简单，我们要让某一个未知数前面的系数都变成 $1$，也就是让所有的原本系数为 $1$ 的变成 $0$，只要找到一个系数为 $1$ 的，之后对所有为 $1$ 的做异或即可，为 $0$ 的显然就不用操作了。</p>\n<p>由于这里的 $n$ 不超过 $28$，所以可以用 int 存下前面的系数，简化代码。</p>\n<p>练习：<a href=\"https://www.luogu.com.cn/problem/P2447\">P2447 [SDOI2010] 外星千足虫</a></p>\n","tags":["Knowledge","数学","线性代数","高斯消元"]},{"title":"背包问题浅析","url":"/2022/02/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/","content":"<h2 id=\"最基础的背包——01背包\"><a href=\"#最基础的背包——01背包\" class=\"headerlink\" title=\"最基础的背包——01背包\"></a>最基础的背包——01背包</h2><p>问题：</p>\n<p>给定一个容量为$w$的背包，有$n$件物品，每件物品都有一个价值$v$和一个体积$c$，问背包能装下的物品的最大价值和</p>\n<p>思路：</p>\n<p>每件物品都有选或不选(0或1)两种状态，考虑用此作为$dp$的一个维度，对于特定容量的价值，是从之前的容量的价值递推出来的，故可以用此作为$dp$的第二个维度，于是就有了$dp$数组$f[i][j]$表示考虑了前$i$个物品，容量为$j$时的最大价值</p>\n<p>如何转移呢？</p>\n<span id=\"more\"></span>\n<p>对$f$数组的修改必然涉及到一个变量：价值$v$，所以需要$v$参与$dp$的转移方程，稍加考虑即可推出一个简明的方程：</p>\n<p>$f[i][j] = max(f[i-1][j],f[i-1][j-c[i]]+v[i])$</p>\n<p>$max$的第一项表示不选择这个物品，直接使用$i-1$个物品的最大价值；第二项表示选择这个物品，所获得的价值是不放这个物品的背包的最大价值加上这个物品的价值</p>\n<p>可以发现，这个方程只和第$i$项和第$i-1$项有关，所以可以使用滚动数组做空间优化，即$f[j] = max(f[j],f[j-c[i]]+v[i])$</p>\n<p>但是，需要注意此处可能对$f[j]$进行修改，但是我们需要用的是修改之前的值，所以需要倒序修改$f[j]$，防止$f[j-c[i]]$变成了现在的价值，而不是在放入$i-1$个物品的价值</p>\n<p>时间复杂度：$O(nw)$</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1048\">P1048 采药</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> w,n,v[<span class=\"number\">105</span>],c[<span class=\"number\">105</span>],f[<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;w&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;c[i]&gt;&gt;v[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=w;j&gt;=c[i];j--) f[j] = <span class=\"built_in\">max</span>(f[j],f[j-c[i]]+v[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[w]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"01背包的变形——完全背包\"><a href=\"#01背包的变形——完全背包\" class=\"headerlink\" title=\"01背包的变形——完全背包\"></a>01背包的变形——完全背包</h2><p>问题：</p>\n<p>给定一个容量为$w$的背包，有$n$<strong>种</strong>物品，每<strong>种</strong>物品都有一个价值$v$和一个体积$c$，<strong>且数量无限</strong>，问背包能装下的物品的最大价值和</p>\n<p>思路：</p>\n<p>还是考虑原来的$dp$方程：</p>\n<p>$f[j] = max(f[j],f[j-c[i]]+v[i])$</p>\n<p>把修改顺序变为正序修改，思考一下$f[j]$的意义</p>\n<p>当$j’ = j+c[i]$时，$f[j’] = f[j]+v[i]$，此时的$f[j]$表示的是考虑<strong>前$i$个</strong>物品的最大值，显然当前物品放入的情况也被考虑进去了，所以此时正序递推正好满足题目要求</p>\n<p>时间复杂度：$O(nw)$</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1616\">P1616 疯狂的采药</a></p>\n<p><strong>注意：</strong></p>\n<p>1.数据范围更改了</p>\n<p>2.由于$w$可能到$1e7$，而且每种物品的价值可能到$1e4$，如果一件物品，它的价值是$1e4$，体积是$1$，那么结果可能会到$1e11$，需要开$long\\ long$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> w,n,v[<span class=\"number\">10005</span>],c[<span class=\"number\">10005</span>];</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> f[<span class=\"number\">10000005</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;w&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;c[i]&gt;&gt;v[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=c[i];j&lt;=w;j++) f[j] = <span class=\"built_in\">max</span>(f[j],f[j-c[i]]+v[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[w]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"优化后的01背包——多重背包\"><a href=\"#优化后的01背包——多重背包\" class=\"headerlink\" title=\"优化后的01背包——多重背包\"></a>优化后的01背包——多重背包</h2><p>问题：</p>\n<p>给定一个容量为$w$的背包，有$n$种物品，每种物品都有一个价值$v$和一个体积$c$，<strong>且数量为$m$个</strong>，问背包能装下的物品的最大价值和</p>\n<p>因为每种物品数量有限，所以无法用完全背包求解（可能会使用多于$m$个物品），考虑将其转化为01背包</p>\n<p>最朴素的想法是把每种物品拆成$m$个单独的物品，把所有的物品都单独拿出来，这样就变成了01背包问题</p>\n<p>但是，这样做的复杂度是$O(nmw)$的，在$n \\geq 1000$时就跑不过了，所以要考虑优化</p>\n<p>由于二进制的很多特殊性质，以及对$log$的谜之追求，出现了一种优化方法：二进制拆分</p>\n<p><del>众所周知，任何一个数都可以被表示为二进制形式</del></p>\n<p>例如：$ 42 = (101010)_2$</p>\n<p>所以，我们把这$m$个物品拆成一堆二进制，例如上面的$42$可以拆成$(1)_2=1$,$(10)_2=2$,$(100)_2=4$,$(1000)_2=8$,$(10000)_2=16$,最后剩下来一个$11$。</p>\n<p>不难看出，前面$5$个二进制可以组成$0 \\sim 31$中的任何一个数，而其中的$32 \\sim 42$中的所有数都可以由$21 \\sim 31$加上$11$得到，所以$0 \\sim 42$中的所有数都可以由这些拆出来的数组合得到</p>\n<p>这样，我们可以把每个背包拆成这些物品，之后当作01背包求解，于是复杂度就降低到了$O(n \\log mw)$</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P6567\">P6567 买表</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">4e2</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,k[N],a[N],t,f[<span class=\"number\">500010</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;k[i]&gt;&gt;a[i];</span><br><span class=\"line\">\tf[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> bas = k[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">30</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (a[i]&lt;(<span class=\"number\">1</span>&lt;&lt;j)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">500005</span>;p&gt;=bas;p--) <span class=\"keyword\">if</span> (f[p-bas]) f[p] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tbas&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\ta[i]-=(<span class=\"number\">1</span>&lt;&lt;j);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a[i])&#123;</span><br><span class=\"line\">\t\t\tbas = a[i]*k[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">500005</span>;j&gt;=bas;j--) <span class=\"keyword\">if</span> (f[j-bas]) f[j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;t;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (f[t]) cout&lt;&lt;<span class=\"string\">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> cout&lt;&lt;<span class=\"string\">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"融合的01背包——分组背包\"><a href=\"#融合的01背包——分组背包\" class=\"headerlink\" title=\"融合的01背包——分组背包\"></a>融合的01背包——分组背包</h2><p>问题：</p>\n<p>给你$n$个物品，每个物品属于一个组，同一组中只能选择一个物品，问容量为$m$的背包的最大价值</p>\n<p>思路：</p>\n<p>同一组中的所有物品都只能选一次，我们通过01背包来限制选择的次数</p>\n<p>同一组中的所有物品只能选一个，我们通过同一价值来避免一个组中选择多个物品</p>\n<p>时间复杂度：$O(nm)$</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P1757\">P1757 通天之分组背包</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,f[N];</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; v[N],w[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;m&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"type\">int</span> x,y,z;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class=\"line\">\t\tw[z].<span class=\"built_in\">push_back</span>(x);</span><br><span class=\"line\">\t\tv[z].<span class=\"built_in\">push_back</span>(y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> sz = w[i].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=m;j&gt;=<span class=\"number\">0</span>;j--)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p=<span class=\"number\">0</span>;p&lt;sz;p++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (j&gt;=w[i][p])&#123;</span><br><span class=\"line\">\t\t\t\t\tf[j] = <span class=\"built_in\">max</span>(f[j],f[j-w[i][p]]+v[i][p]);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","tags":["Knowledge","DP"]},{"title":"能量采集 题解","url":"/2022/05/26/%E8%83%BD%E9%87%8F%E9%87%87%E9%9B%86-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"能量采集-题解\"><a href=\"#能量采集-题解\" class=\"headerlink\" title=\"能量采集 题解\"></a>能量采集 题解</h1><p>$\\sum_{i=1}^n\\sum_{j=1}^m\\gcd(i,j)\\cdot 2 -1$</p>\n<h2 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h2><p>枚举$\\gcd$：</p>\n<p>$\\sum_{d=1}^{min(n,m)}d\\cdot 2\\sum_{i=1}^n\\sum_{j=1}^m[gcd(i,j) = d]-nm$</p>\n<p>同时除以$d$：</p>\n<p>$2\\sum_{d=1}^{min(n,m)}d\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{m}{d}}[gcd(i,j) = 1]-nm$</p>\n<span id=\"more\"></span>\n<p>把$\\gcd$变成$\\mu$：</p>\n<p>$2\\sum_{d=1}^{min(n,m)}d\\sum_{i=1}^{\\frac{n}{d}}\\sum_{j=1}^{\\frac{m}{d}}\\sum_{k|gcd(i,j)}\\mu(k)-nm$</p>\n<p>枚举$k$：</p>\n<p>$2\\sum_{d=1}^{min(n,m)}d\\sum_{k=1}^{min(\\frac{n}{d},\\frac{m}{d})}\\mu(k)\\lfloor \\frac{n}{dk}\\rfloor \\lfloor \\frac{m}{dk}\\rfloor-nm$</p>\n<p>时间复杂度为$O(n\\sqrt n)$，勉强可以通过。</p>\n<h2 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h2><p>但是，我们要把它往欧拉函数推：</p>\n<p>$2\\sum_{i=1}^{n}\\sum_{j=1}^m\\gcd(i,j)-nm$</p>\n<p>运用$\\sum_{k|n}\\varphi(k) = n$的性质：</p>\n<p>$2\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{k|\\gcd(i,j)}\\varphi(k)-nm$</p>\n<p>把$k$提到前面去：<br>$2\\sum_{k=1}^{min(n,m)}\\varphi(k)\\lfloor \\frac{n}{k}\\rfloor \\lfloor \\frac{m}{k}\\rfloor-nm$</p>\n<p>运用整除分块，可以在$O(\\sqrt n)$的时间内求出这个式子。</p>\n<p>预处理欧拉函数前缀和是$O(n)$的。</p>\n<p>总时间复杂度为$O(n+\\sqrt n)$。</p>\n","tags":["Editorial","数论","莫比乌斯函数"]},{"title":"自建题目目录与解答","url":"/2022/01/15/%E8%87%AA%E5%BB%BA%E9%A2%98%E7%9B%AE%E7%9B%AE%E5%BD%95%E4%B8%8E%E8%A7%A3%E7%AD%94/","content":"<h2 id=\"Tri\"><a href=\"#Tri\" class=\"headerlink\" title=\"Tri\"></a><a href=\"https://www.luogu.com.cn/problem/U198025\">Tri</a></h2><p>首先考虑最暴力的做法，只用把所有的三角形数都枚举一遍，再看看因数数量即可，但是，假设判断了$q$个三角形数，其中每个数为$m$，如果$\\sqrt m$判断因数是否符合条件，会让总复杂度达到$q \\sqrt m$级别的，这显然是无法接受的</p>\n<p>于是想到一个定理：</p>\n<p>如果一个数$p$能够被表示为$p = {a_1}^{k1}+{a_2}^{k2}+…+{a_n}^{k_n}$，那么$p$的因数个数即为$(k_1+1)<em>(k_2+1)</em>…*(k_n+1)$，这代表我们只需要知道一个数的所有质因数，就可以知道它的约数个数，于是总时间复杂度就被降低到了$O(q\\log m)$级别的，有了很可观的改善</p>\n<span id=\"more\"></span>\n<p>$Sample \\ Code:$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e6</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n = <span class=\"number\">1e6</span>,k,vis[N*<span class=\"number\">2</span>],pri[N],tot;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"type\">long</span> sum;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i*pri[j]&gt;N || vis[i]&lt;pri[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">chk</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">1</span>,coun;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot &amp;&amp; x;i++)&#123;</span><br><span class=\"line\">\t\tcoun = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%pri[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tcoun++;</span><br><span class=\"line\">\t\t\tx/=pri[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt*=coun;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cnt&gt;k) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tsum+=i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">chk</span>(sum)) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;sum&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>但是对于$n\\geq 1200$，这种算法也无法在$1.5s$的时限内跑完，所以还需要优化</p>\n<p>如何优化呢？</p>\n<p>因为三角形数是形为$p*(p+1)/2$的数，所以这个$p$必然是根号级别的，可以从这里下手</p>\n<p>而且易证$p$和$p+1$是互质的，其中包含的质因数必然完全不同，所以三角形数的因数可以由$p$的因数和$p+1$的因数相乘得到</p>\n<p>可以先把一定范围内的数的因数预处理出来，之后判断时直接调用即可</p>\n<p>这里采用了与上一份代码类似的因数个数计算方法</p>\n<p>$Sample \\ Code:$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1.5e5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n = <span class=\"number\">1e5</span>,k,vis[N*<span class=\"number\">2</span>],pri[N],tot,v[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (i*pri[j]&gt;N || vis[i]&lt;pri[j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">1</span>,coun;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=tot;i++)&#123;</span><br><span class=\"line\">\t\tcoun = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%pri[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tcoun++;</span><br><span class=\"line\">\t\t\tx/=pri[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcnt*=coun;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (x == <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++) v[i] = <span class=\"built_in\">get</span>(i);</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i%<span class=\"number\">2</span>) ans = v[i]*v[(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = v[i/<span class=\"number\">2</span>]*v[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans&gt;k)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"number\">1ll</span>*i*(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;Set n to a bigger value&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>但是，对于更大的$n$，这种算法却出奇的慢，原因就在于$get$函数中大量使用取模和除法操作，而且判断了很多不能整除的质数，最后可能还没有最简单的加法来得快</p>\n<p>而且一个一个累加，虽然看上去很慢，但是每一个因数都累加到了，绝无重复操作和无用操作，极大的提高了算法的效率</p>\n<p>这里采用尝试法，把所有因数都试出来，虽然看上去接近于$O(n^2)$，但是由于每个数的平均质因数在$log$级别，所以其实是接近$O(n*\\log n)$再带一个大常数的（前$1e7$个数的因数计算花费$2s$）</p>\n<p>$Sample \\ Code:$</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2.8e6</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n = <span class=\"number\">2.5e6</span>,k,v[N*<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcin&gt;&gt;k;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=N;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=i;j&lt;=N;j+=i) v[j]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ans;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i&amp;<span class=\"number\">1</span>) ans = v[i]*v[(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ans = v[i/<span class=\"number\">2</span>]*v[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ans&gt;k)&#123;</span><br><span class=\"line\">\t\t\tcout&lt;&lt;<span class=\"number\">1ll</span>*i*(i+<span class=\"number\">1</span>)/<span class=\"number\">2</span>&lt;&lt;endl;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;<span class=\"string\">&quot;Set n to a bigger value&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>于是，这个简短的代码就是这道题目前的最优解了，题解愉快的结束了！</p>\n<p>为了防止不必要的卡常，已把本题时限开到$2s$，默认开启$O2$优化，即使你的$N$设置的不是那么微妙，也是可以轻松通过的</p>\n","tags":["Knowledge","Misc"]},{"title":"莫队算法初步","url":"/2022/02/09/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/","content":"<h2 id=\"莫队的基本思想\"><a href=\"#莫队的基本思想\" class=\"headerlink\" title=\"莫队的基本思想\"></a>莫队的基本思想</h2><p>简单的莫队是针对这样一种题目：给定很多离线的询问，没有修改，而且数据范围根号算法能过。</p>\n<p>一般的算法都是对单次查询过程进行优化，但莫队对询问进行了优化：</p>\n<span id=\"more\"></span>\n<p>把询问可能出现的区间分成$\\sqrt n$个块，再将询问排序，具体规则是先对左端点所在的块排序，如果左端点在同一块中，就对右端点升序排序。</p>\n<p>这样，我们把排序好的询问一个个计算，定义$L$为当前左端点，$R$为当前右端点，处理每个询问时把左端点和右端点都移动到当前询问的左、右端点处，移动时用$O(1)$或接近的时间复杂度维护$L$和$R$之间的答案，移动好时，这个询问对应的答案就成了$L$和$R$之间的答案。</p>\n<p>但是莫队为什么快呢？因为对于每个块中的询问，左端点都是在这个块中活动$q$次询问可能会卡成$q \\times \\sqrt n$，假设每个询问都倍卡，左端点移动的复杂度最大就是$O(q \\times \\sqrt n)$。再看右端点，如果每个块中右端点都从这个块的起点移动到了最后一个块的终点，右端点移动的复杂度最大就是$O(n \\times \\sqrt n)$。如果$L$和$R$移动的代价为$w$，总共的复杂度最大就是$O(w \\times (n+q) \\times \\sqrt n)$。</p>\n<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><p><a href=\"https://www.luogu.com.cn/problem/P2709\">P2709 小B的询问</a></p>\n<p><a href=\"http://zhengruioi.com/contest/966/problem/1992\">ZROI 奇数</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/SP3267\">SP3267 DQUERY</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/CF86D\">CF86D Powerful array</a></p>\n<p>To be added.</p>\n<h2 id=\"带修莫队\"><a href=\"#带修莫队\" class=\"headerlink\" title=\"带修莫队\"></a>带修莫队</h2>","tags":["Knowledge","分块"]},{"title":"超能粒子炮 题解","url":"/2022/04/12/%E8%B6%85%E8%83%BD%E7%B2%92%E5%AD%90%E7%82%AE-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"超能粒子炮-题解\"><a href=\"#超能粒子炮-题解\" class=\"headerlink\" title=\"超能粒子炮 题解\"></a>超能粒子炮 题解</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>让你求$(\\sum_{i=0}^kC_n^i \\mod 2333) \\mod 2333$。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>题目中没有明确说明$k$和$n$的关系，如果$k\\geq n$，那么答案就是$2^n\\mod 2333$。</p>\n<p>现在，我们只用考虑$k&lt;n$的情况了。</p>\n<p>$k$最大可以到$1e18$，显然无法直接计算。</p>\n<span id=\"more\"></span>\n<p>但是这个模数较小，于是我们想到了Lucas定理，这样我们所有计算的东西都在2333以内了。</p>\n<p>手动模拟一下，当$i\\geq2333$时，我们使用Lucas定理将式子变成$C_{n\\mod 2333}^{i\\mod 2333}\\cdot C_{n/2333}^{i/2333}$。</p>\n<p>当$2333\\leq i&lt; 4666$时，后面的东西没有变化，前面的就是$2^{n\\mod 2333}-1$。这启示我们这个式子中存在很多一样的东西，我们可以把它们捆绑在一起来降低复杂度。</p>\n<p>前面的东西就是一直循环的，我们现在需要计算后面的东西，而后面的东西也可以用Lucas定理化简：</p>\n<p>$C_{n/2333}^{i/2333} = C_{n/2333\\mod 2333}^{i/2333\\mod 2333}\\cdot C_{n/{2333^2}}^{i/{2333^2}}$。</p>\n<p>前面的东西每2333个数变化一次，后面的又可以重复计算，这不就可以用递归解决吗？</p>\n<p>设$f(x,n)$表示计算$\\sum_{i=0}^x C_{n}^i$。这个式子可以简化成$\\sum_{i=0}^{x/p-1}C_{n/2333}^i\\cdot (\\sum_{j=0}^{2332}C_{n\\mod 2333}^j)+C_{n/2333}^{x/2333}\\cdot \\sum_{i=0}^{x\\mod 2333}C_{n\\mod 2333}^i$。</p>\n<p>前面的一坨显然可以化为$f(k/p-1,n/2333)$，这样就可以递归解决这个问题了。</p>\n<p>先花$2333^2$的时间预处理出组合数和前缀和，之后用$T\\log^2 p$的时间解决问题（有一个$\\log$花在求$C_{n/2333}^{k/2333}$上）。</p>\n<h2 id=\"Code-：\"><a href=\"#Code-：\" class=\"headerlink\" title=\"$Code$：\"></a>$Code$：</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">3e3</span>+<span class=\"number\">10</span>,p = <span class=\"number\">2333</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> t,n,k,c[N][N],sum[N][N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tc[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;p;j++) sum[<span class=\"number\">0</span>][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;p;i++)&#123;</span><br><span class=\"line\">\t\tc[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=i;j++) c[i][j] = (c[i<span class=\"number\">-1</span>][j]+c[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>])%p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;p;j++) sum[i][j] = sum[i][j<span class=\"number\">-1</span>]+c[i][j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lucas</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!x) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c[y%p][x%p]*<span class=\"built_in\">lucas</span>(x/p,y/p)%p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&lt;<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"built_in\">f</span>(x/p<span class=\"number\">-1</span>,n/p)*sum[n%<span class=\"number\">2333</span>][p<span class=\"number\">-1</span>]%p+<span class=\"built_in\">lucas</span>(x/p,n/p)*sum[n%<span class=\"number\">2333</span>][x%<span class=\"number\">2333</span>]%p)%p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\tcin&gt;&gt;t;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t--)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"built_in\">f</span>(k,n)&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","数学","组合数学"]},{"title":"近代物理","url":"/2024/03/09/%E8%BF%91%E4%BB%A3%E7%89%A9%E7%90%86/","content":"<h1 id=\"近代物理\"><a href=\"#近代物理\" class=\"headerlink\" title=\"近代物理\"></a>近代物理</h1><h2 id=\"黑体辐射\"><a href=\"#黑体辐射\" class=\"headerlink\" title=\"黑体辐射\"></a>黑体辐射</h2><p><img src=\"https://s2.loli.net/2024/03/09/KlSp1y5eIYDFtov.png\" alt=\"image.png\"></p>\n<p>黑体就是将入射的电磁波全部吸收，而不反射的物体。虽然不反射，但可以向外辐射电磁波，称为黑体辐射。</p>\n<p><strong>黑体辐射只和温度有关，温度高，辐射强度高，峰值向低波段平移</strong>。可以理解为温度大，能量高，频率大，波长小。</p>\n<span id=\"more\"></span>\n<h2 id=\"光电效应\"><a href=\"#光电效应\" class=\"headerlink\" title=\"光电效应\"></a>光电效应</h2><p>光电子：能量为 $E = hv$。（$v$ 是光的频率）给波长就变形，$v = \\frac{c}{\\lambda},E = \\frac{hc}{\\lambda}$。</p>\n<p>光电效应实验就是用一束光照射金属板，之后金属的电子逸出，形成电流。</p>\n<p>首先，电子是围绕金属原子的原子核运动的，需要吸收一定能量才能逸出，这个能量叫<strong>逸出功</strong>，记作 $W_0$。</p>\n<p>这个能量，就是由光电子提供的。一个电子，只能吸收一个光电子，不能累积多个光电子的能量。</p>\n<p>如果能量不够，就把光电子吐出来，回到原来的位置。</p>\n<p>如果能量足够，在克服逸出功后，还会剩一点能量，这就是电子的<strong>最大初动能</strong>（这里的最大指最外层的电子逸出，它本来带的能量最高，需要的能量最小）。</p>\n<p>$E_k = hv-W_0$</p>\n<p>如果刚好逸出，$E_k = 0$，$hv = W_0,v = \\frac{W_0}{h}$，这个 $v$ 叫<strong>极限频率</strong>，也叫<strong>截止频率</strong>。</p>\n<p><strong>光强</strong>：光子密度 $\\times$ 光子能量。光子密度越大，相同时间内光电子越多，电子逸出越多，于是电流 $I$ 增大。需要注意的是，光强相同的红光和紫光，由于紫光光子能量大，所以光子密度小。</p>\n<p><img src=\"https://s2.loli.net/2024/03/09/mxDuURvEOJzVqnL.png\" alt=\"image.png\"></p>\n<p>如果是这样的正向电压，只要超过截止频率，就有电流，正向电压越大，电流越大，但是电流的变化不是线性的，而是最后接近一个定值，这个定值就是<strong>饱和光电流</strong>。</p>\n<p>原因：加电压使电子运动时速度水平分量大，更容易打到极板上，当电压足够大时，看成单位时间内逸出的所有电子，都打到极板上，电流达到理论最大值。</p>\n<p><strong>光强增大，饱和光电流增大</strong>。因为单位时间逸出的电子多。</p>\n<p><img src=\"https://s2.loli.net/2024/03/09/9iXurdhymWpOg1C.png\" alt=\"image.png\"></p>\n<p>和上面的过程相反，如果一个电子拥有最大初动能，在电场力的作用下，打到极板前速度正好变为 $0$，就不会有电流。</p>\n<p>$eU = E_k = hv-W_0$</p>\n<p>$U = \\frac{hv-W_0}{e}$</p>\n<p>这里的 $U$ 称为<strong>遏止电压</strong>。它和 $v$ 正相关，和 $W_0$ 负相关。</p>\n<p>需要注意的是，如果不加电源，也会有电流，因为电子还是可以打到极板上。</p>\n<p><img src=\"https://s2.loli.net/2024/03/09/Spf3UYkjzgQrJ6e.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/03/09/kxMZntcA2VrOylD.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/03/09/RAZ9SgJ3cxQBLds.png\" alt=\"image.png\"></p>\n<p>主要还是考图像题，坐标建议现场推，不是很费时间。</p>\n<h2 id=\"康普顿效应\"><a href=\"#康普顿效应\" class=\"headerlink\" title=\"康普顿效应\"></a>康普顿效应</h2><p>光子也具有动量，$p = \\frac{h}{v}$。</p>\n<p>从这里也可以看出，微观世界不遵循宏观的动量和能量公式，做题的时候要注意。</p>\n<h2 id=\"波粒二象性\"><a href=\"#波粒二象性\" class=\"headerlink\" title=\"波粒二象性\"></a>波粒二象性</h2><p>粒子性：黑体辐射，光电效应，康普顿效应。</p>\n<p>波动性：干涉，衍射，偏振，多普勒效应。</p>\n<p>一般，粒子性是研究单个粒子，波动性则是研究大量光子组成的波。</p>\n<p><strong>波长越大，频率越小，波动性越明显。</strong></p>\n<h2 id=\"原子结构\"><a href=\"#原子结构\" class=\"headerlink\" title=\"原子结构\"></a>原子结构</h2><p>汤姆孙：研究阴极射线，发现电子，证明<strong>原子</strong>有复杂结构，提出枣糕模型。</p>\n<p>卢瑟福：$\\alpha$ 粒子散射实验，绝大多粒子原方向，少量粒子偏转，极少量弹回，证明原子核有一个质量极大，体积极小的原子核。</p>\n<p>首先，这个实验可以说明正电荷分布不均匀，<strong>如果分布均匀，那应该全部沿原方向前进</strong>。</p>\n<p>其次，$\\alpha$ 粒子是 $He$ 核，<strong>带有两个正电荷</strong>，所以会有部分因库仑力被弹回。</p>\n<p>玻尔：按卢瑟福的模型，如果按圆周运动，电子会撞上核，于是提出能量量子化。</p>\n<p>电子从基态到激发态，只能吸收<strong>特定频率的光子</strong>，其能量恰好等于能级能量之差，多了少了都不行。</p>\n<p>从激发态到基态，如果是一个电子，最多发出 $n-1$ 种（$n$ 到 $n-1$，$n-1$ 到 $n-2$…），如果是一群，最多发出 $C_n^2$。</p>\n<p>有些题目会用<strong>电子</strong>（除光子之外的实物粒子都符合）轰击原子。首先电子之间碰撞时，能量会有损失，所以<strong>不一定能使基态转为激发态</strong>。其次电子碰撞完，自己可以保留一部分动能，所以<strong>只要电子的能量大于两能级之差</strong>，就<strong>可能</strong>可以发生跃迁。</p>\n<p>轨道量子化：$r_n = n^2r_1$。</p>\n<p>能量量子化：$E_n = \\frac{E_1}{n^2}$。这里的 $E$ 都是负值，原理和天体运动时，卫星的机械能类似，虽然 $E$ 逐渐变大，但绝对值是逐渐变小的。</p>\n<h2 id=\"原子核\"><a href=\"#原子核\" class=\"headerlink\" title=\"原子核\"></a>原子核</h2><p><img src=\"https://s2.loli.net/2024/03/09/O68NGuyI4Cvw1nF.png\" alt=\"image.png\"></p>\n<p>动能：</p>\n<p>动量：</p>\n<p>这些射线的产生，能证明<strong>原子核</strong>内有复杂结构。</p>\n<p>射线的粒子都来自原子核内部，包括 $\\beta$ 射线的电子。</p>\n<p>$\\alpha$ 衰变：两个中子和两个质子结合成一个 $He$ 核放出。</p>\n<p>$\\beta$ 衰变：一个中子转化为一个质子和一个电子。</p>\n<p>半衰期：原子核半数发生衰变所需时间。<strong>只适用于大量粒子，只与元素本身有关，和外界环境没有任何关系</strong>。</p>\n<p><img src=\"https://s2.loli.net/2024/03/09/6ok5ndftER1iel8.png\" alt=\"image.png\"></p>\n<p><img src=\"https://s2.loli.net/2024/03/09/RfrQzVpu6hMCKyj.png\" alt=\"image.png\"></p>\n<p>原子核由<strong>核子</strong>组成。把原子核分解为核子，需要吸收能量；把核子结合成原子核，会出现质量亏损，会释放能量。</p>\n<p>这里，一个原子核分解成核子吸收的能量，和核子结合成这个原子核释放的能量，是相等的，这个能量称为<strong>结合能</strong>。</p>\n<p><strong>比结合能</strong>：把结合能均分给每一个核子，<strong>单个核子</strong>的能量就是比结合能。一般代表物质的稳定性，核反应生成物比结合能一般大于反应物的。</p>\n<p>计算时，可能会设计能量的计算，可以使用 $E = \\Delta mc^2$。</p>\n<h2 id=\"附加知识\"><a href=\"#附加知识\" class=\"headerlink\" title=\"附加知识\"></a>附加知识</h2><ol>\n<li><p>质量相等的核燃料，轻核的聚变比重核裂变释放更多的核能。</p>\n</li>\n<li><p>光子的能量等于光子的动能，因为宏观物理的 $E_k = \\frac{1}{2}mv^2$ 只是近似结果，其中有一个表达和 $\\frac{v}{c}$ 有关。</p>\n<p>$E = E_k = mc^2$</p>\n<p>这里的 $m$ 是动质量，和平常理解的质量不同。</p>\n<p>但是，动量定理在微观世界同样适用，$p = mc$。</p>\n<p>于是，可以推出 $E = pc$。</p>\n</li>\n</ol>\n","tags":["Knowledge","物理","原子物理"]},{"title":"近期博客Latex渲染失败的说明","url":"/2022/06/05/%E8%BF%91%E6%9C%9F%E5%8D%9A%E5%AE%A2Latex%E6%B8%B2%E6%9F%93%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%AF%B4%E6%98%8E/","content":"<h1 id=\"近期博客Latex渲染失败的说明\"><a href=\"#近期博客Latex渲染失败的说明\" class=\"headerlink\" title=\"近期博客Latex渲染失败的说明\"></a>近期博客Latex渲染失败的说明</h1><h2 id=\"问题所在\"><a href=\"#问题所在\" class=\"headerlink\" title=\"问题所在\"></a>问题所在</h2><p>由于某些众所周知的原因，负责cdn加速的jsdelivr被-Wall了，造成了在国内无法获取一个叫mathjax.min.js的东西，进而导致博客渲染失败。这也是本博客内一些托管于github的图片访问失败的原因。</p>\n<h2 id=\"如何解决\"><a href=\"#如何解决\" class=\"headerlink\" title=\"如何解决\"></a>如何解决</h2><p>找了一些博客，发现cdn服务提供商远不止jsdelivr一个，我们可以使用其他的诸如cdnjs的cdn提供商，而我对cdn所知甚少，就选择了在config.yml文档中预留的katex的cdnjs服务，没想到这让$\\LaTeX$的渲染成功了。</p>\n<h2 id=\"启示\"><a href=\"#启示\" class=\"headerlink\" title=\"启示\"></a>启示</h2><p>在渲染失败的问题出现的最初几天，我百思不得其解，换了至少$4$个渲染引擎，把能够在设置文档里面调的设置都调了，却无果而终。</p>\n<p>之后的几个月里，我从图床加载不了的问题中，隐隐约约感觉到是jsdelivr的问题，但是没有深究。</p>\n<p>在最近的几天，我忘记了回国，在国外访问了我的博客，却意外的发现$\\LaTeX$全都安然无恙，也就是说，jsdelivr被<del>[强调]</del>了。</p>\n<p>今天，在闲暇之余搜了jsdelivr，果不其然的发现有一堆人讨论这个问题，最终从config.yml中找到了解决方案。</p>\n<p>问题的解决往往不是一瞬间的，又常常是一刹那的。</p>\n<p>无论身处何处，面对何事，都要保持一颗对问题乐于探索、敢于质疑、勇于突破的心。</p>\n<p>May humans win.</p>\n","tags":["Life"]},{"title":"质数","url":"/2022/04/01/%E8%B4%A8%E6%95%B0/","content":"<h1 id=\"质数\"><a href=\"#质数\" class=\"headerlink\" title=\"质数\"></a>质数</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>每个所有因数只有自己和1的数叫做<strong>质数</strong>，而其他不符合这个条件的数叫做<strong>合数</strong>。</p>\n<h2 id=\"筛出质数\"><a href=\"#筛出质数\" class=\"headerlink\" title=\"筛出质数\"></a>筛出质数</h2><ul>\n<li>暴力筛法<ul>\n<li>每次取出所有小于它的不是1的数，判断是否为它的因数，如果全都不是，那么这个数就是质数。</li>\n<li>时间复杂度$O(n)$。</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n<ul>\n<li>优化过的暴力筛法<ul>\n<li>每次取出所有小于等于根号它的数，判断是否为它的因数，如果全都不是，那么这个数就是质数。</li>\n<li>正确性：每个合数必然有一个小于等于根号它的因数，可以用反证法证明。</li>\n<li>时间复杂度$O(\\sqrt{n})$</li>\n</ul>\n</li>\n<li>埃氏筛<ul>\n<li>每一个是质数的数都标记它的倍数为合数，所有没有被标记的就是质数。</li>\n<li>正确性：每个合数必然有至少一个质因子，而每个质数的质因子只有它本身。</li>\n<li>时间复杂度$O(n\\log \\log n)$。（反正接近线性，应该也没人会特意卡这个）</li>\n</ul>\n</li>\n<li>欧式筛<ul>\n<li>我们模拟一下，可以发现埃氏筛中，有些数会被筛很多次，如12即被2筛过，也被3筛过，这样会浪费大量时间，如果我们规定每个数只能被它的最小质因子筛，那就不会重复筛一个数了。</li>\n<li>正确性：一个数的质因子之间有大小关系，我们只要让这个数被最小的质因子筛，顺序就是唯一的。</li>\n<li>时间复杂度$O(n)$。比较推荐使用这种筛法，因为它还可以筛一些积性函数。</li>\n</ul>\n</li>\n</ul>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P3383\">P3383</a></p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e8</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,vis[N],pri[N],tot,lim;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">euler</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123; <span class=\"comment\">//是质数 </span></span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (pri[j]&gt;vis[i] || <span class=\"number\">1ll</span>*pri[j]*i&gt;lim) <span class=\"keyword\">break</span>; <span class=\"comment\">//只能由最小的因数筛掉 </span></span><br><span class=\"line\">\t\t\tvis[pri[j]*i] = pri[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;lim&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"built_in\">euler</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\tcin&gt;&gt;x;</span><br><span class=\"line\">\t\tcout&lt;&lt;pri[x]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"质因数分解\"><a href=\"#质因数分解\" class=\"headerlink\" title=\"质因数分解\"></a>质因数分解</h2><p>从2~$\\sqrt{n}$里面枚举因数，一直除，直到这个数不含有此因数为止。</p>\n<p>有没有可能除了一个合数呢？不可能。</p>\n<p>因为每个合数必然由比它小的质数组成，而我们把所有组成它的质数都除掉了，所以不可能出现合数。</p>\n<p>时间复杂度为$O(\\sqrt{n})$，你大可无视里面不断除的过程，这个过程在long long范围内也不会超过64次。</p>\n<p>题目：<a href=\"https://www.luogu.com.cn/problem/P2043\">P2043</a></p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e4</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,cnt[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">work</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> k = <span class=\"built_in\">sqrt</span>(x);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=k;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (x%i == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\tx/=i;</span><br><span class=\"line\">\t\t\tcnt[i]++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&gt;<span class=\"number\">1</span>) cnt[x]++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++) <span class=\"built_in\">work</span>(i);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">if</span> (cnt[i]) cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;cnt[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当$n$更大时，可以配合埃氏筛，先把所有质数筛出来，1~$n$中是质数和质数的任意次方的倍数的数都对质因子有贡献。时间复杂度为$O(n\\log n)$。（虽然埃氏筛要带两$\\log$，但是这里就忽略不计了，你也可以用线性筛实现）</p>\n<p>$Code$：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e6</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,cnt[N],vis[N];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> las = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n/i;j++)&#123;</span><br><span class=\"line\">\t\t\t\tvis[i*j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (j/las == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\t\t\tcnt[i]+=<span class=\"number\">1ll</span>*n/j/i;</span><br><span class=\"line\">\t\t\t\t\tlas*=i;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"keyword\">if</span> (cnt[i]) cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;cnt[i]&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Fun-Facts\"><a href=\"#Fun-Facts\" class=\"headerlink\" title=\"Fun Facts\"></a>Fun Facts</h2><p>1~1000中有168个质数</p>\n<p>1~10000中有1229个质数</p>\n<p>1~100000中有9592个质数</p>\n<p>1~1000000中有78498个质数</p>\n<p>1~$2^{32}$中有203280221个质数</p>\n<p>$1$ ~ $n$ 内的质数大概是 $\\frac{n}{\\log n}$ 级别的。</p>\n<p>在$10^{18}$内的最大质数间隙不超过1500</p>\n","tags":["Knowledge","数学"]},{"title":"选必1 3.1 免疫系统的组成和功能","url":"/2022/11/27/%E9%80%89%E5%BF%851-3-1-%E5%85%8D%E7%96%AB%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%E5%92%8C%E5%8A%9F%E8%83%BD/","content":"<h1 id=\"选必1-3-1-免疫系统的组成和功能\"><a href=\"#选必1-3-1-免疫系统的组成和功能\" class=\"headerlink\" title=\"选必1 3.1 免疫系统的组成和功能\"></a>选必1 3.1 免疫系统的组成和功能</h1><p>Warning：这是我的第一篇文化课博客，其测试性较强，请选择阅读。</p>\n<h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p>这代表着我们的学习进入到了新的阶段：免疫系统。</p>\n<p>这一节是对免疫系统的介绍：由什么组成，功能是什么。</p>\n<p>一般介绍性的东西，要背的较多，需要理解的相对少一点。</p>\n<span id=\"more\"></span>\n<h2 id=\"免疫系统要对付谁\"><a href=\"#免疫系统要对付谁\" class=\"headerlink\" title=\"免疫系统要对付谁\"></a>免疫系统要对付谁</h2><p>正常人的认知里，免疫系统是将入侵身体的病毒清除出去的，但是远不止于此。</p>\n<ol>\n<li><strong>病原体</strong>：致病的<strong>细菌，真菌，病毒</strong>等。</li>\n</ol>\n<p>（快复习一下病毒：是生物，不是细胞！）</p>\n<ol>\n<li>自身细胞：衰老、损伤、癌变的细胞。</li>\n</ol>\n<p>这两个东西都要清除出去。</p>\n<h2 id=\"免疫系统的组成\"><a href=\"#免疫系统的组成\" class=\"headerlink\" title=\"免疫系统的组成\"></a>免疫系统的组成</h2><p>从大的层面来说，免疫系统由<strong>免疫器官、免疫细胞、免疫活性物质</strong>组成。</p>\n<p>可以形象的理解为<strong>军事基地、士兵、武器</strong>。</p>\n<p>从这里也可以看出，免疫细胞在免疫器官里（大部分），免疫活性物质由免疫细胞产生。</p>\n<ol>\n<li><p>免疫器官：主要由淋巴组织构成，借助<strong>血液循环</strong>和<strong>淋巴循环</strong>相互联系。</p>\n<p>下面是课本中列举的 $5$ 个。</p>\n<p>胸腺和骨髓：免疫细胞<strong>产生并发育成熟</strong>的地方。</p>\n<p>脾、淋巴结和扁桃体：免疫细胞<strong>集中分布</strong>的场所，<strong>防御和消灭病原体</strong>的阵地。</p>\n</li>\n<li><p>免疫细胞：执行免疫功能的细胞，来自骨髓的造血干细胞。</p>\n<p>包括淋巴细胞，吞噬细胞。这两个东西也叫<strong>白细胞</strong>。</p>\n<p>其中淋巴细胞有 T 细胞（胸腺）和 B 细胞（骨髓）。</p>\n<p>吞噬细胞有树突状细胞，巨噬细胞。</p>\n</li>\n</ol>\n<h2 id=\"免疫器官\"><a href=\"#免疫器官\" class=\"headerlink\" title=\"免疫器官\"></a>免疫器官</h2><p>下面的也是淋巴器官。</p>\n<h3 id=\"扁桃体\"><a href=\"#扁桃体\" class=\"headerlink\" title=\"扁桃体\"></a>扁桃体</h3><p>形状：扁桃状。</p>\n<p>位置：咽腭部（喉咙）。</p>\n<p>左右两个，具有防御功能。</p>\n<p>细胞：免疫细胞。</p>\n<p>特性：扁桃体肿大，是因为扁桃体发炎，是被病原体感染的体现。医生观察这里，是因为这里从外面就看得到，比较明显。但是，可能会产生脓肿，对身体不好。</p>\n<h3 id=\"胸腺\"><a href=\"#胸腺\" class=\"headerlink\" title=\"胸腺\"></a>胸腺</h3><p>形状：扁平椭圆形。</p>\n<p>位置：胸骨后面。</p>\n<p>左右<strong>两页</strong>，是 T 细胞（这个 T 和 DNA 里面的含义类似）<strong>分化、发育、成熟</strong>的场所。（这三个词要考的！注意不是产生，而是从骨髓迁移而来）</p>\n<p>细胞：T 细胞。</p>\n<p>特性：随年龄而增长，青春期时达到高峰，以后逐渐退化。</p>\n<p>胸腺既是免疫器官，也是内分泌腺，能产生促 T 细胞生长的胸腺激素。</p>\n<h3 id=\"淋巴结\"><a href=\"#淋巴结\" class=\"headerlink\" title=\"淋巴结\"></a>淋巴结</h3><p>形状：圆形或豆状。</p>\n<p>位置：沿淋巴管遍布全身，主要还是在<strong>颈部、腋窝和腹股沟</strong>等处。</p>\n<p>细胞：淋巴细胞。</p>\n<p>能阻止和消灭入侵的微生物。</p>\n<h3 id=\"脾\"><a href=\"#脾\" class=\"headerlink\" title=\"脾\"></a>脾</h3><p>形状：椭圆形。</p>\n<p>位置：胃的左侧。</p>\n<p>细胞：淋巴细胞（<strong>巨量！是身体内最大的免疫器官！</strong>）</p>\n<p>既可以防御，也参与<strong>制造新的血细胞</strong>和清<strong>除衰老的血细胞</strong>。</p>\n<p>（血细胞：红细胞、白细胞、血小板）</p>\n<h3 id=\"骨髓\"><a href=\"#骨髓\" class=\"headerlink\" title=\"骨髓\"></a>骨髓</h3><p>位置：骨髓腔、骨松质。</p>\n<p>细胞：B 细胞，造血干细胞。</p>\n<p>骨髓可以用<strong>造血干细胞</strong>产生<strong>各种免疫细胞</strong>，也是 B 细胞的<strong>分化、发育、成熟</strong>场所。</p>\n<p>（书上提及的所有免疫细胞都从这里产生，分化过程分两步，第一步变成红细胞、白细胞或血小板，第二步白细胞变成各种免疫细胞）</p>\n<h2 id=\"免疫细胞\"><a href=\"#免疫细胞\" class=\"headerlink\" title=\"免疫细胞\"></a>免疫细胞</h2><h3 id=\"淋巴细胞\"><a href=\"#淋巴细胞\" class=\"headerlink\" title=\"淋巴细胞\"></a>淋巴细胞</h3><p>位置：淋巴液、<strong>血液</strong>、淋巴结。（书上说的！必须背，别自己理解写个脾啥的上去）</p>\n<ol>\n<li>B 淋巴细胞，在骨髓里面。<ol>\n<li>浆细胞。（一般是这个产生抗体）</li>\n<li>记忆 B 细胞。</li>\n</ol>\n</li>\n<li>T 淋巴细胞，<strong>迁移到</strong>胸腺成熟（估计是从骨髓迁移过来的）。<ol>\n<li>辅助性 T 细胞。</li>\n<li>细胞毒性 T 细胞。</li>\n<li>记忆 T 细胞。</li>\n</ol>\n</li>\n</ol>\n<p>辨别方法：</p>\n<p><img src=\"https://s2.loli.net/2022/11/27/bSPMEW98DnyhHmx.png\" alt=\"Bcell\"></p>\n<p><img src=\"https://s2.loli.net/2022/11/27/jvpzyFGUolWPQsa.png\" alt=\"Tcell\"></p>\n<h3 id=\"吞噬细胞\"><a href=\"#吞噬细胞\" class=\"headerlink\" title=\"吞噬细胞\"></a>吞噬细胞</h3><ol>\n<li><p>树突状细胞，分布于皮肤、消化道、呼吸道等上皮组织（大概就是在表面的组织）和淋巴器官内。</p>\n<p>成熟时具有<strong>分支</strong>，有<strong>强大的吞噬，呈递抗原</strong>功能。</p>\n</li>\n<li><p>巨噬细胞，几乎分布于各种组织中。</p>\n<p>具有<strong>吞噬消化、抗原处理和呈递</strong>功能。</p>\n</li>\n</ol>\n<h3 id=\"抗原\"><a href=\"#抗原\" class=\"headerlink\" title=\"抗原\"></a>抗原</h3><p>这玩意不属于免疫细胞，但为什么要在这里讲呢？因为它和免疫细胞有很大的关系。</p>\n<p>位置：病原体表面、免疫细胞表面。</p>\n<p>特性：能与免疫细胞表面的受体结合，引发免疫反应的物质。</p>\n<p>化学本质：蛋白质、多糖、脂类。（反正是大分子物质）</p>\n<p><strong>与免疫细胞的关系</strong>：B 细胞，树突状细胞、巨噬细胞都能摄取和加工处理抗原，并可以将抗原信息暴露在细胞表面，以便呈递给其他免疫细胞。因此，这些细胞统称为<strong>抗原呈递细胞</strong>。</p>\n<p>你可能会问：这不对啊，这些细胞表面有抗原，那会不会引发免疫反应，被干掉呢？</p>\n<p>不会，因为它们是<strong>摄取和加工处理抗原</strong>，所以不会被错误识别。</p>\n<p>抗原不一定是外来的，衰老的细胞也会产生抗原。</p>\n<h2 id=\"免疫活性物质\"><a href=\"#免疫活性物质\" class=\"headerlink\" title=\"免疫活性物质\"></a>免疫活性物质</h2><h3 id=\"抗体\"><a href=\"#抗体\" class=\"headerlink\" title=\"抗体\"></a>抗体</h3><p>概念：机体产生的，专门应对抗原的蛋白质。</p>\n<p>特异性：一种抗体，只能与一种抗原相结合。</p>\n<p>分布：随血液循环和淋巴循环到达各个部位，主要在<strong>血清</strong>中，也可以分布在外分泌液（乳汁）中。</p>\n<p>抗体不一定是自身产生的，比如打血清。</p>\n<h3 id=\"细胞因子\"><a href=\"#细胞因子\" class=\"headerlink\" title=\"细胞因子\"></a>细胞因子</h3><p>来源：辅助 T 细胞分泌。</p>\n<p>常见：白细胞介素、干扰素、肿瘤坏死因子。</p>\n<h3 id=\"溶菌酶\"><a href=\"#溶菌酶\" class=\"headerlink\" title=\"溶菌酶\"></a>溶菌酶</h3><p>来源：唾液腺细胞、泪腺细胞等。</p>\n<p>作用：使细菌的细胞膜溶解、病毒失活。</p>\n<h2 id=\"免疫系统\"><a href=\"#免疫系统\" class=\"headerlink\" title=\"免疫系统\"></a>免疫系统</h2><p>免疫系统是免疫调节的<strong>结构和物质基础</strong>。</p>\n<h3 id=\"人的三道防线\"><a href=\"#人的三道防线\" class=\"headerlink\" title=\"人的三道防线\"></a>人的三道防线</h3><ol>\n<li><p>皮肤、黏膜。</p>\n<p>黏膜上的纤毛（胃上皮纤毛）。</p>\n<p>皮肤分泌物（唾液、胃液）。</p>\n</li>\n<li><p>杀菌物质（溶菌酶）和吞噬细胞（树突状细胞、巨噬细胞）。</p>\n</li>\n</ol>\n<p>这两道防线生来就有，是遗传的，对多种病原体都有效，是非特异性免疫。</p>\n<ol>\n<li><p>在发育过程中和病原体接触获得的，主要针对特定的抗原起作用。</p>\n<p>体液免疫：B 细胞为主，抗体起主要作用。</p>\n<p>细胞免疫：T 细胞为主，直接接触靶细胞。</p>\n</li>\n</ol>\n<p>具有特异性，叫特异性免疫</p>\n<p>三道防线是<strong>统一的整体</strong>，共同实现<strong>免疫防御、免疫自稳、免疫监视</strong>的三大基本功能。</p>\n<h3 id=\"免疫防御\"><a href=\"#免疫防御\" class=\"headerlink\" title=\"免疫防御\"></a>免疫防御</h3><p>排除外来抗原性异物，免疫系统<strong>最基本的功能</strong>。</p>\n<p>免疫反应过强、过弱或缺失，可能会导致<strong>组织损伤</strong>或<strong>易被病原体感染</strong>等问题。</p>\n<h3 id=\"免疫自稳\"><a href=\"#免疫自稳\" class=\"headerlink\" title=\"免疫自稳\"></a>免疫自稳</h3><p>清楚衰老或损伤的细胞，进行自身调节，维持内环境稳态。</p>\n<p>功能异常，容易发生<strong>自身免疫病</strong>。（自己杀和自己一伙的）</p>\n<h3 id=\"免疫监视\"><a href=\"#免疫监视\" class=\"headerlink\" title=\"免疫监视\"></a>免疫监视</h3><p>识别和清除突变的细胞，防止肿瘤。</p>\n<p>功能低下或失调，会有肿瘤发生或持续的病毒感染。</p>\n","tags":["文化课","生物","选择性必修1","免疫系统"]},{"title":"退役","url":"/2022/11/27/%E9%80%80%E5%BD%B9/","content":"<h1 id=\"退役\"><a href=\"#退役\" class=\"headerlink\" title=\"退役\"></a>退役</h1><p>这一天的到来，是否太早了一点。</p>\n<h2 id=\"Day-0\"><a href=\"#Day-0\" class=\"headerlink\" title=\"Day 0\"></a>Day 0</h2><p>早上起来，预感自己可能撑不过这次 NOIP，于是肝完了所有的已尝试的题目，晚上看了很多板子，但是总感觉会漏掉什么东西（比如点双缩点），睡觉时就觉得明天可能不会很顺利。</p>\n<h2 id=\"Day-1\"><a href=\"#Day-1\" class=\"headerlink\" title=\"Day 1\"></a>Day 1</h2><p>早上雾有些大，看不清前方 20m 的东西，进校园时，雾越发大了起来，似乎注定这是一次不同平常的经历。</p>\n<p>先是查验 CCF 要求准备的材料，不过我前面的一个人貌似没准备全？也不知道最后进去了没，华师一这方面做的还是挺严格的。</p>\n<p>考场好像在 $4$ 楼，与以前在华科考试不同，这次是走楼梯上去，不过相比 WHEZ 的 $6$ 楼，其实还好。</p>\n<p>进了考场，看到 Win10 的电脑，倍感熟悉，大概到 8:02 分才让碰键盘，之后先把代码模板打了，再打了个对拍的，最后打了一个乘法逆元，发现速度海星。</p>\n<p>大概到 8:25 的时候，下发了压缩包的密码，结果打开一看，PDF 还有一层密码，CCF 看来认真了啊。</p>\n<p>这次是 8:30 准时开题。</p>\n<p>T1 的标题和题面很唬人，但是稍加观察，就会发现，就是求两个前缀和，再乘一下就好了，细节有一点，大概到 9:30 才拍上。</p>\n<p>于是我果断开 T2，想着至少拿个比暴力高的分。</p>\n<p>题面的描述倒是很清晰，但是看了两眼，发现是我最不擅长的构造题，本着 T2 应该不会很难的思想，我还是硬着头皮做了。</p>\n<p>先看到 k，它的取值只有两个，显然要从这里入手。$k = 2n-2$ 就是一个很典的构造，$k = 2n-1$ 的就是在这基础上处理新的数。</p>\n<p>我模拟了一下，发现 $n = 2$ 时，是可以一个空栈和两个都放一个相互转化的，但是无论如何，都无法扩展到更大的情况。</p>\n<p>于是我想了 1.5h？</p>\n<p>最后，看到尝试无果，我还是选择了放弃，由于时间不够了，就打了我会的部分分上去，也没检查（貌似多测都没清空），直接开 T3 去了。</p>\n<p>T3 的题面很清楚，想了一下，环里面的肯定随便选，缩点之后变成一个没有环的无向图，貌似就要 dp 看两个点的情况，感觉短时间也写不了，就码了个暴力，走人。</p>\n<p>这时已经 12:45 了。</p>\n<p>我确信这次真的要退役了，以前挂在嘴边的词，今天却成为了现实，不过，这结果也不算出人意料。</p>\n<p>只是学了两年 OI，都没拿到一个省一，让我有点不甘心。</p>\n<p>考试结束后，由于疫情的原因，也没到哪里完，果断选择下午睡大觉，睡醒起来，发现 LG 上已经可以测 T1 了，好像没挂分，之后看到 Uoj 群里面有人讲了 T2 做法，不是很懂，于是去问 cyh 巨巨，cyh 很良心的讲了题，发现对栈底的处理不够深入，想歪了，那一个空位是必然要留的，而不是通过转化。</p>\n<p>听懂之后，感觉自己又行了，于是开始码 T2，花了 45min 过了样例，结果各大 OJ 都没分！（这次的样例很水实锤了）发现一些细节出了问题，又调了亿会，结果只拿到了送给暴力的 20pts，大概想了 1h，才发现一个地方的处理完全错了，好不容易调完，交到 infoj，85pts？再交 cf，TLE？最后交 LG，过了？？？</p>\n<p>这时大概已经调了 3h 了，也不想再看了，可能等题解出来，我还会看一眼哪里出了问题吧。不过这也说明，即使我在考场上想出来，也绝对拿不到分，菜，又有什么办法呢？</p>\n<p>晚上也没睡好，一直在想之后 WHK 的事情，我掉的实在太多了，而以 WHEZ 的风格，是绝对不可能有时间干自己的事的，感觉怎么想都是个死胡同。不过，这是我终将踏上的道路，而 OI 也是我的选择，没有理由抱怨什么。</p>\n<p>往者不可谏，来者犹可追。</p>\n","tags":["Life"]},{"title":"选数 题解","url":"/2022/07/15/%E9%80%89%E6%95%B0-%E9%A2%98%E8%A7%A3/","content":"<h1 id=\"选数-题解\"><a href=\"#选数-题解\" class=\"headerlink\" title=\"选数 题解\"></a>选数 题解</h1><p>$\\color{lightgreen}Status: OK$</p>\n<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>在 $[l,r]$ 内选择 $n$ 个数，使其 $\\gcd = k$，问选数的方案数有多少。</p>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><p>由于 $\\gcd = k$，所以每个数必定是 $k$ 的倍数，转换为在 $[\\frac{l}{k},\\frac{r}{k}]$ 中选 $\\gcd = 1$ 的 $n$ 个数的组合。</p>\n<span id=\"more\"></span>\n<p>用式子表示是这样的：</p>\n<p>$\\sum_{a_1=\\frac{l}{k}}^\\frac{r}{k}\\cdots \\sum_{a_n=\\frac{l}{k}}^\\frac{r}{k}[\\gcd(a_1,a_2\\cdots a_n) = 1]$</p>\n<p>反演掉：</p>\n<p>$\\sum_{a_1=\\frac{l}{k}}^\\frac{r}{k}\\cdots \\sum_{a_n=\\frac{l}{k}}^\\frac{r}{k}\\sum_{d|\\gcd(a_1,a_2\\cdots a_n)}\\mu(d)$</p>\n<p>枚举 $d$：</p>\n<p>$\\sum_{d=1}^{\\frac{r}{k}}\\mu(d)(\\frac{r}{kd}-\\frac{l-1}{kd})^n$</p>\n<p>后面的东西是个整除分块加上一个快速幂，时间复杂度为 $O(\\sqrt n\\cdot \\log n)$。</p>\n<p>但是，我们无法在给定的时间内预处理出 $\\mu(d)$ 的前缀和，怎么办？亚线性在线回答！</p>\n<p>直接上杜教筛，时间复杂度降为 $O(n^{\\frac{2}{3}})$。</p>\n<p>虽然后面还要带个 $\\sqrt n$，但是由于前面求的都不是满的，所以复杂度应该不会很高。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e6</span>+<span class=\"number\">10</span>,lim = <span class=\"number\">1e6</span>,mod = <span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,a,b,vis[N],pri[N],tot,mu[N];</span><br><span class=\"line\">map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pre</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tmu[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=lim;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!vis[i])&#123;</span><br><span class=\"line\">\t\t\tvis[i] = i;</span><br><span class=\"line\">\t\t\tpri[++tot] = i;</span><br><span class=\"line\">\t\t\tmu[i] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=tot;j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]&lt;pri[j] || <span class=\"number\">1ll</span>*i*pri[j]&gt;lim) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\tvis[i*pri[j]] = pri[j];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (vis[i]!=pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=lim;i++) mu[i]+=mu[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ksm</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tll ret = <span class=\"number\">1</span>,bas = x;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (y)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (y&amp;<span class=\"number\">1</span>) ret = ret*bas%mod;</span><br><span class=\"line\">\t\tbas = bas*bas%mod;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">getmu</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x&lt;=lim) <span class=\"keyword\">return</span> mu[x];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (mp.<span class=\"built_in\">count</span>(x)) <span class=\"keyword\">return</span> mp[x];</span><br><span class=\"line\">\tll ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (ll l=<span class=\"number\">2</span>,r;l&lt;=x;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tr = x/(x/l);</span><br><span class=\"line\">\t\tans = (ans-(r-l+<span class=\"number\">1</span>)*<span class=\"built_in\">getmu</span>(x/l))%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> mp[x] = ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tcin&gt;&gt;n&gt;&gt;k&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">\t<span class=\"built_in\">pre</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> lim = b/k;</span><br><span class=\"line\">\ta--;</span><br><span class=\"line\">\tll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> l=<span class=\"number\">1</span>,r;l&lt;=lim;l = r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a/l) r = <span class=\"built_in\">min</span>(a/(a/l),b/(b/l));</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> r = b/(b/l);</span><br><span class=\"line\">\t\tans = (ans+(<span class=\"built_in\">getmu</span>(r)-<span class=\"built_in\">getmu</span>(l<span class=\"number\">-1</span>))*<span class=\"built_in\">ksm</span>(b/(<span class=\"number\">1ll</span>*k*l)-a/(<span class=\"number\">1ll</span>*k*l),n))%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout&lt;&lt;(ans%mod+mod)%mod&lt;&lt;endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","数学","莫比乌斯反演","杜教筛"]},{"title":"题解 UVA323 Jury Compromise","url":"/2022/03/19/%E9%A2%98%E8%A7%A3-UVA323-Jury-Compromise/","content":"<h1 id=\"题解-UVA323-Jury-Compromise\"><a href=\"#题解-UVA323-Jury-Compromise\" class=\"headerlink\" title=\"题解 UVA323 Jury Compromise\"></a>题解 UVA323 Jury Compromise</h1><h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>有 $n$ 个人，从中选出$m$个人，每个人有两个得分值$a$和$b$，我们要使$|\\sum^{m}_{i=1}a[i]-\\sum^{m}_{i=1}b[i]|$最小，如果有多种情况满足，选择其中$\\sum^{m}_{i=1}a[i]+\\sum^{m}_{i=1}b[i]$最大的一个。输出最大分值和选择的方案。</p>\n<p>$n\\leq200$</p>\n<p>$m\\leq20$</p>\n<p>$0\\leq a,b\\leq20$</p>\n<span id=\"more\"></span>\n<h2 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h2><h3 id=\"O-2-n-算法\"><a href=\"#O-2-n-算法\" class=\"headerlink\" title=\"$O(2^n)$算法\"></a>$O(2^n)$算法</h3><p>第一眼看上去，好像没有任何思路，贪心也不太可行。</p>\n<p>于是考虑暴力。。。</p>\n<p>最暴力的想法是枚举选的人，求出最值。注意到，题目中的分值范围很小，所有人分差最大也只是$400$，所以这$2^{200}$种选择里面，必然有很多种选择，它们的分差是一样的，这就导致了很多重复计算，我们不如枚举分差。</p>\n<p>枚举分差，显然不能直接搜索，而DP可以很好地解决这个问题。</p>\n<h3 id=\"O-nm-2-错误算法\"><a href=\"#O-nm-2-错误算法\" class=\"headerlink\" title=\"$O(nm^2)$错误算法\"></a>$O(nm^2)$错误算法</h3><p>我们初步的想法是设$f[i]$表示分差为$i$时，能够取到的最大分值，每次加入一个人时，我们枚举分差，更新数组即可。</p>\n<p>第$j$个人加入后得到$i$的分差的转移方程：$f[i] = max(f[i],f[i-a[j]+b[j]]+a[j]+b[j])$</p>\n<p>但是，这样做会有后效性，在$j$不变时，我们可能先改动了$f[i-a[j]+b[j]]$的值，导致这里的$f[i-a[j]+b[j]]$不是上一次的值，导致使用多次第$j$个人。</p>\n<p>如果判断$a[j]-b[j]$的正负来确定枚举顺序的确可以解决这个问题，但是这样不好处理之后的输出方案问题，于是我们索性多开一个维度。</p>\n<h3 id=\"O-nm-2-正确算法\"><a href=\"#O-nm-2-正确算法\" class=\"headerlink\" title=\"$O(nm^2)$正确算法\"></a>$O(nm^2)$正确算法</h3><p>设$f[i][j]$表示选择了$i$个人，分差为$j$的方案数。</p>\n<p>第$p$个人加入后得到$j$的分差的转移方程：$f[i][j] = max(f[i][j],f[i-1][j-a[p]+b[p]]+a[p]+b[p])$</p>\n<p>由于下标不能出现负数，我们把所有的分差都加上$400$，这样就没有负数了。</p>\n<p>初始化时，将所有数都设为负无穷，$f[0][400] = 0$，这样可以保证不会从不合法的状态转移。</p>\n<p>输出时我们找到一个和$400$最近的，值最大且大于$0$的就行了。</p>\n<h3 id=\"剩下的输出\"><a href=\"#剩下的输出\" class=\"headerlink\" title=\"剩下的输出\"></a>剩下的输出</h3><p>我们不仅要输出最大值，还要输出选择的方案，我们考虑用一个数组记录转移的情况。</p>\n<p>设$d[i][j][p]$表示前$i$个人中，选择了$j$个人，得到$p$的分差，最后选择的是哪个人。</p>\n<p>转移时先把上一次的照搬过来，对应不选第$i$个人的情况，之后如果这一次能够让$f[j][p]$更大，就更新$d[i][j][p]$。</p>\n<p>输出方案时，我们从$d[n][m][Min]$开始输出，每次$Min-=a[d[n[m][Min]]]-b[d[n][m][Min]]$，$m-=1$，$n$转移到$d[n][m][Min]-1$，一直到$m=0$时结束。</p>\n<p>之后倒序输出就行了</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>前面的DP应该不是很难想到，但是各种细节需要注意：</p>\n<ol>\n<li>数组下标不能为负数，要加一个基准值</li>\n<li>转移时记录转移情况，方便输出方案</li>\n<li>数组要初始化为负无穷，避免从不合法的情况转移</li>\n<li>多测要清空</li>\n</ol>\n<p>本题实际上是将每个人视为一个物品，做了一次01背包。考察了背包和输出方案。</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e3</span>+<span class=\"number\">10</span>,M = <span class=\"number\">25</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,f[M][N],p[N],q[N],d[<span class=\"number\">205</span>][M][N],totp,totq,per[M];</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = m,nnow = n;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (now)&#123;</span><br><span class=\"line\">\t\tnnow = d[nnow][now][x];</span><br><span class=\"line\">\t\tper[now] = nnow;</span><br><span class=\"line\">\t\ttotp+=p[nnow];</span><br><span class=\"line\">\t\ttotq+=q[nnow];</span><br><span class=\"line\">\t\tx = x-p[nnow]+q[nnow];</span><br><span class=\"line\">\t\tnnow--;</span><br><span class=\"line\">\t\tnow--;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">\tcin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> now = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!n &amp;&amp; !m) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\tnow++;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(f,<span class=\"number\">-0x3f</span>,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">\t\ttotp = totq = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) cin&gt;&gt;p[i]&gt;&gt;q[i];</span><br><span class=\"line\">\t\tf[<span class=\"number\">0</span>][<span class=\"number\">400</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p1=<span class=\"number\">1</span>;p1&lt;=n;p1++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=m;i++)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">800</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\td[p1][i][j] = d[p1<span class=\"number\">-1</span>][i][j];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=m;i&gt;=<span class=\"number\">1</span>;i--)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;=<span class=\"number\">800</span>;j++)&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ((j-p[p1]+q[p1])&lt;<span class=\"number\">0</span> || (j-p[p1]+q[p1])&gt;<span class=\"number\">800</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (f[i][j]&lt;f[i<span class=\"number\">-1</span>][j-(p[p1]-q[p1])]+p[p1]+q[p1])&#123;</span><br><span class=\"line\">\t\t\t\t\t\tf[i][j] = f[i<span class=\"number\">-1</span>][j-(p[p1]-q[p1])]+p[p1]+q[p1];</span><br><span class=\"line\">\t\t\t\t\t\td[p1][i][j] = p1;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> Min = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">800</span>;i++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (f[m][i]&gt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(Min<span class=\"number\">-400</span>) == <span class=\"built_in\">abs</span>(i<span class=\"number\">-400</span>))&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (f[m][i]&gt;=f[m][Min]) Min = i;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"built_in\">abs</span>(Min<span class=\"number\">-400</span>)&gt;<span class=\"built_in\">abs</span>(i<span class=\"number\">-400</span>)) Min = i;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">get</span>(Min);</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;Jury #&quot;</span>&lt;&lt;now&lt;&lt;endl;</span><br><span class=\"line\">\t\tcout&lt;&lt;<span class=\"string\">&quot;Best jury has value &quot;</span>&lt;&lt;totp&lt;&lt;<span class=\"string\">&quot; for prosecution and value &quot;</span>&lt;&lt;totq&lt;&lt;<span class=\"string\">&quot; for defence:&quot;</span>;</span><br><span class=\"line\">\t\tcout&lt;&lt;endl;</span><br><span class=\"line\">\t\t<span class=\"built_in\">sort</span>(per+<span class=\"number\">1</span>,per+<span class=\"number\">1</span>+m);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++) cout&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;per[i];</span><br><span class=\"line\">\t\tcout&lt;&lt;endl&lt;&lt;endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","tags":["Editorial","DP"]},{"title":"随机放送1：论二次函数区间整数解个数","url":"/2023/07/11/%E9%9A%8F%E6%9C%BA%E6%94%BE%E9%80%811%EF%BC%9A%E8%AE%BA%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0%E5%8C%BA%E9%97%B4%E6%95%B4%E6%95%B0%E8%A7%A3%E4%B8%AA%E6%95%B0/","content":"<h1 id=\"随机放送1：论二次函数区间整数解个数\"><a href=\"#随机放送1：论二次函数区间整数解个数\" class=\"headerlink\" title=\"随机放送1：论二次函数区间整数解个数\"></a>随机放送1：论二次函数区间整数解个数</h1><h2 id=\"T1\"><a href=\"#T1\" class=\"headerlink\" title=\"T1\"></a>T1</h2><h3 id=\"题面\"><a href=\"#题面\" class=\"headerlink\" title=\"题面\"></a>题面</h3><p>$x^2-(k-3)x-k+4 = 0$ 的解均为整数，求出所有满足条件的实数 $k$。</p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>解是整数，首先要有解，所以判别式要 $\\geq 0$。</p>\n<span id=\"more\"></span>\n<p>$\\Delta = k^2-2k-7\\geq 0$</p>\n<p>$k\\leq 1-2\\sqrt 2$ 或 $k\\geq 1+2\\sqrt 2$。</p>\n<p>之后，不妨把解用求根公式表示：</p>\n<p>$x = \\frac{k-3\\pm \\sqrt \\Delta}{2}$</p>\n<p>也就是说，$\\Delta$ 必须是一个完全平方数。</p>\n<p>$(k-1)^2-8 = A^2(A\\geq 0)$</p>\n<p>这里就可以用到我做 Codeforces 时了解的技巧：</p>\n<p>$(k-1)^2-A^2 = 8$</p>\n<p>$(k-1+A)(k-1-A) = 8$</p>\n<p>又因为，$x = \\frac{k-3\\pm A}{2}$ 是整数，所以 $k\\pm A$ 是奇数。</p>\n<p>于是，$k-1+A,k-1-A$ 都是整数，所以对 $8$ 分解，有四种情况：$1\\times 8,(-1)\\times(-8),2\\times 4,(-2)\\times (-4)$。</p>\n<p>分别求得 $k = 5.5,-3.5,4,-2$，其中只有 $k = 4,-2$ 满足 $k\\pm A$ 是奇数。</p>\n<p>所以 $k = 4$ 或 $-2$。</p>\n<h2 id=\"T2\"><a href=\"#T2\" class=\"headerlink\" title=\"T2\"></a>T2</h2><h3 id=\"题面-1\"><a href=\"#题面-1\" class=\"headerlink\" title=\"题面\"></a>题面</h3><p>$x^2-(a+2)x+2-a&lt;0$ 有且只有一个整数 $x$，求正实数 $a$ 的取值范围。</p>\n<h3 id=\"解析-1\"><a href=\"#解析-1\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>这种有动二次函数，但是 $a$ 不变的，可以考虑分离成确定的二次函数和动一次函数，即参变分离。</p>\n<p>$x^2-2x+2&lt;ax+a$</p>\n<p>右边的一次函数过定点 $(-1,0)$，于是可以通过数形结合判断。</p>\n<p>最极限的情况是相切，算出切点横坐标为 $\\sqrt 5-1$，而二次函数的对称轴是 $x = 1$，离的很近。于是考虑是否包含 $x = 1$ 或 $x = 2$。</p>\n<p>当直线过 $(1,1)$ 时，算出 $a = \\frac{1}{2}$；当直线过 $(2,2)$ 时，算出 $a = \\frac{2}{3}$。</p>\n<p>要注意，当直线过 $(1,1)$ 时，实际上在 $x = 1$ 时并不满足 $x^2-(a+2)x+2-a&lt;0$，所以不能取。</p>\n<p>$a\\in (\\frac{1}{2},\\frac{2}{3}]$</p>\n<h2 id=\"T3\"><a href=\"#T3\" class=\"headerlink\" title=\"T3\"></a>T3</h2><h3 id=\"题面-2\"><a href=\"#题面-2\" class=\"headerlink\" title=\"题面\"></a>题面</h3><p>正数 $a,b$ 满足 $b-a&lt;2$，若 $(a^2-4)x^2+4bx-b^2&lt;0$ 的解集中整数解恰有 $4$ 个，求 $a$ 的取值范围。</p>\n<h3 id=\"解析-2\"><a href=\"#解析-2\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>虽然有两个变量，但是我们先不管它们之间的不等关系，当作已知量处理。</p>\n<p><del>不</del>容易发现，这个二次函数很有特点：</p>\n<p>$a^2x^2&lt;4x^2-4bx+b^2$</p>\n<p>$(ax)^2&lt;(2x-b)^2$</p>\n<p>$(ax+2x-b)(ax-2x+b)&lt;0$</p>\n<p>显然两根为 $\\frac{b}{a+2},\\frac{b}{2-a}$。</p>\n<p>当 $\\frac{b}{a+2}&gt;\\frac{b}{2-a}$ 时，解得 $a&gt;2$。</p>\n<p>再看原来的函数，如果 $a^2-4<0$ 的话，解就有无穷个了，所以 $a>2$。</p>\n<p>于是，解集为 $(\\frac{b}{2-a},\\frac{b}{a+2})$。</p>\n<p>再看不等关系，$b&lt;a+2$，所以 $0&lt;\\frac{b}{a+2}&lt;1$。</p>\n<p>这样一来，整数解就只可能为 $0,-1,-2,-3$ 了。</p>\n<p>于是，转化为函数在 $(0,1)$ 和 $(-4,-3)$ 区间内分别有一个解。</p>\n<p>所以，$-4\\leq \\frac{b}{2-a}&lt;-3$。</p>\n<p>$3a-6&lt;b\\leq 4a-8$</p>\n<p>$3a-6&lt;a+2$</p>\n<p>$a&lt;4$</p>\n<p>所以，$a\\in (2,4)$。</p>\n","tags":["数学","文化课","函数"]},{"title":"高中三年","url":"/2024/07/22/%E9%AB%98%E4%B8%AD%E4%B8%89%E5%B9%B4/","content":"<p>三年的时光，说来很长，实则短暂，但却不失色彩。</p>\n<p>黑色与白色交织的，是初进校园的一年。刚从金华参加集训返程的我，对信息竞赛有着一腔热忱，日夜与黑白的命令行相处。无论是变幻的树上节点，还是精密又简洁的状态转移方程，亦或是如机器般庞大高效的数据结构，都令我心醉神迷。处于上升期的我，有着无限的可能，每次掌握新知，都意味着离目标越来越近，看着不断上升的排名，我更坚定了信心，习得更多知识。这时，我仿佛置身世外，隔壁班高耸的卷子，走廊里奔走的人影，都与我无关。一切努力，都有着立竿见影的效果。午后阳光正好，我注视着屏幕中跳动的黑白，却未曾注意，此时的我，在阳光下多么耀眼。</p>\n<span id=\"more\"></span>\n<p>绿色与红色相间的，是我在二中度过的第二年。虽然我仍然在停课准备竞赛，但是迟迟没能突破瓶颈。高二，是一个信竞选手生涯的最后一年，没有了高一的从容与安定，我变得不太正常。一个测试点，正确是绿，错误是红；一场比赛，排名上升是绿，下降是红；一张健康码，正常是绿，疑似是红。而此时的我，拼命地在一望无际的红中，寻找星星点点的绿。也许，我在找寻的，是迷茫中的一点希望吧。</p>\n<p>可是，那个春天，还是来的太晚了。在 NOIP 的考场上，我一心想证明自己的能力，死磕 1.5 小时题 2，导致后面的题丢掉基础分，得分 115 遗憾离场，而一等奖的分数线是 120 分。要知道，只要多对一个测试点，就是 5 分。之后，疫情扩散，我成了全班第一个感染的人，在家对着熟悉的电脑，我却兴趣全无。虽然来年春天的省选全力发挥，但也无力回天。我不会怨恨那道难度过高的题 2，只会感慨，那个初三以来一直无所不能的我，已经离开了。</p>\n<p>蓝色与金色渐变的，是回归综合的高三。九调出分后，我买了一份从未吃过的炒饭，摆在课桌上，总觉得浅蓝的课桌与金黄的饭粒，甚是搭配。那餐吃的很香，虽然之后经常买那家炒饭，但从未觉得如此美味，只记得那次，我从年级 400 名进步到了 200 多名。11 月初，我在十一校联考中，排到了 90 名，全然不觉，这个成绩，只是偶然一次的超常发挥，不代表着实打实的进步。之后的几周，一写完作业，我便全身心投入 osu! 中（甚至在凌晨 12：45 刷出了目前的 bp2？），可想而知，我在 11 月末的鄂东南联考中光速退步了 100 名，原形毕露。看见成绩的我，痛心疾首，开始狂补物化生，没日没夜地做题、刷卷子，可是罗马还未建成，考试先至。即使重点突击了一个月，元调时，我的物化生成绩仍然雷打不动。有些焦虑，有些慌张，可时间还在流逝，高一高二借走的慢悠悠、无忧无虑的日子，只能用现在来偿还。之后，我的眼中，便只有清晨天空的蔚蓝，和深夜台灯的金色辉光。每次调考结束，学校都会组织我们去江滩散步，我不再低头看着自己的脚步，而是望向前方，那里除了江畔的春景，还有我心中逐渐清晰的终点。</p>\n<p>在六月回望，我不愿意再过高三的日子，但我却珍视这段经历。它让我明白，我不是无所不能的，但也绝不会一事无成，拼尽全力去做，就会改变，分数如此，人生亦如此。</p>\n<p>色彩将回忆装点，未来也会四季分明。广阔的天空将我们分隔，也将我们连结，无论人生是旷野还是轨道，我们都要尽力飞驰。晴空万里，微风吹拂，稍作休整，顺风启航。</p>\n","tags":["Life","文化课"]},{"title":"高维前缀和初步","url":"/2022/10/26/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E5%88%9D%E6%AD%A5/","content":"<h1 id=\"高维前缀和初步\"><a href=\"#高维前缀和初步\" class=\"headerlink\" title=\"高维前缀和初步\"></a>高维前缀和初步</h1><h2 id=\"什么是前缀和\"><a href=\"#什么是前缀和\" class=\"headerlink\" title=\"什么是前缀和\"></a>什么是前缀和</h2><p>众所周知，一维前缀和的计算是对每个数，都加上前面的一个数的计算结果，如果将前面一个数看作前面的前缀和，那这一位也是前缀和。</p>\n<p>二维前缀和虽然可以用容斥做，但是并不能扩展到更高的维度。</p>\n<span id=\"more\"></span>\n<p>我们有另一种实现方式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\tsum[i][j]+=sum[i][j<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">\t\tsum[i][j]+=sum[i<span class=\"number\">-1</span>][j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以理解为，先对每一个横行求一维前缀和，之后每一个数就代表着从当前行开始的前缀和，我们再把这些数求一次前缀和，就是每个位置所在的矩形的前缀和了，可以画图加深理解。</p>\n<p>高维前缀和就是每次选择要扩展的一维，保持其他维度不动，对这一维求前缀和，最后求出来的就是高维前缀和了。</p>\n<p>听上去很抽象，没事，我们看一看它的应用。</p>\n<h2 id=\"例1\"><a href=\"#例1\" class=\"headerlink\" title=\"例1\"></a>例1</h2><p> <a href=\"https://www.luogu.com.cn/problem/P5495\">P5495 Dirichlet 前缀和</a> </p>\n<p>给你一个序列 $a$，求序列 $b$，满足 $b_i = \\sum_{j|i}a_j$。</p>\n<p>首先，考虑一个数能从哪里转移过来。</p>\n<p>假设 $i = \\prod p_i^{c_i}$。</p>\n<p>则能转移过来的数必然满足所有的 $c’_i&lt;=c_i$。</p>\n<p>我们将这个数看成高维空间内的一个点，每个维度都是 $p_i$，则能转移过来的点就是高维空间内的前缀和。</p>\n<p>考虑如何求高维空间前缀和，我们枚举当前求的维度 $i$，把每个数向它的 $i$ 倍转移，根据上面的高位前缀和算法，可以得知我们求的是对的。（不用想这个东西实际的意义是啥，反正我没想清楚，只要用高维前缀和的思想去理解就好了）</p>\n","tags":["Knowledge","数学","DP"]}]